# Two approaches, one object

There are two main ways to initiate a plotly object in R. The `plot_ly()` function transforms _data_ into a plotly object, while the `ggplotly()` function transforms a _ggplot object_ into a plotly object [@ggplot2]; [@plotly]. Regardless how plotly object is created, printing it results in an interactive web-based visualization with tooltips, zooming, and panning enabled by default. It is also possible to enable more advanced interactive techniques, such as [animation](#animation) and [linked highlighting](#linked-highlighting).

The initial inspiration for the `plot_ly()` function was to support [plotly.js](https://github.com/plotly/plotly.js) chart types that **ggplot2** doesn't support, such as 3D surface and mesh plots. Over time, this effort snowballed into a full-blown interface to the entire plotly.js graphing library with additional abstractions inspired by the grammar of graphics [@Wilkinson:2005]. This "non-ggplot2" interface to plotly.js is (somewhat intentionally) not as fully featured as **ggplot2** to provide more efficient alternative for certain plots. Also, by having high-level functions that can modify plotly objects, we're also able to [Extend `ggplotly()`](#extend-ggplotly). In the next section, we introduce some similarities and differences between `ggplotly()` and `plot_ly()` through a case study.

## A case study of housing sales in Texas

The **plotly** package depends on **ggplot2** which bundles a data set on monthly housing sales in Texan cities acquired from the [TAMU real estate center](http://recenter.tamu.edu/). After the loading the package, the data is "lazily loaded" into your session, so you may reference it by name:

```{r}
library(plotly)
txhousing
```

In attempt to understand house price behavior over time, we could plot `date` on x, `median` on y, and group the lines connecting these x/y pairs by `city`. Using **ggplot2**, we can _initiate_ a ggplot object with the `ggplot()` function which accepts a data frame and a mapping from data variables to visual aesthetics. By just initiating the object, **ggplot2** won't know how to geometrically represent the mapping until we add a layer to the plot via one of `geom_*()` (or `stat_*()`) functions (in this case, we want `geom_line()`). In this case, it is also a good idea to specify alpha transparency so that 5 lines plotted on top of each other appear as solid black, to help avoid overplotting.

```{block, type='rmdtip'}
If you're new to **ggplot2**, the [ggplot2 cheatsheet](https://www.rstudio.com/wp-content/uploads/2015/12/ggplot2-cheatsheet-2.0.pdf) provides a nice quick overview. The [online docs](http://docs.ggplot2.org/current/) or [R graphics cookbook](http://www.cookbook-r.com/Graphs/) are helpful for learning by example, and the [ggplot2 book](https://github.com/hadley/ggplot2-book) provides a nice overview of the conceptual underpinnings.
```

```{r}
p <- ggplot(txhousing, aes(date, median, group = city)) +
  geom_line(alpha = 0.2)
```

Now that we have a valid **ggplot2** object, `p`, the **plotly** package provides the `ggplotly()` function which converts a ggplot object to a plotly object. By default, it supplies the entire aesthetic mapping to the tooltip, but the `tooltip` argument provides a way to restrict tooltip info to a subset of that mapping. Furthermore, in cases where the statistic of a layer is something other than the identity function (e.g., `geom_bin2d()` and `geom_hex()`), relevant "intermediate" variables generated in the process are also supplied to the tooltip. This provides a nice mechanism for decoding visual aesthetics (e.g., color) used to represent a measure of interest (e.g, count/value). In Figure \@ref(fig:ggsubplot), the `subplot()` function from the **plotly** package (discussed in more detail in [subplots](#subplot)), which accepts a collection of ggplot and/or plotly objects, helps to concisely display tooltips for a number of scenarios, and how to suppress them.

```{r ggsubplot, fig.cap = "By default all aesthetic mappings are displayed upon hover. The tooltip argument provides a way to display a subset of the mapping."}
subplot(
  p, ggplotly(p, tooltip = "city"), 
  ggplot(txhousing, aes(date, median)) + geom_bin2d(),
  ggplot(txhousing, aes(date, median)) + geom_hex(),
  nrows = 2, shareX = TRUE, shareY = TRUE,
  titleY = FALSE, titleX = FALSE
)
```

```{block, type='rmdtip'}
Although **ggplot2** does not have a `text` aesthetic, the `ggplotly()` function recognizes this aesthetic and displays it in the tooltip by default. In addition to providing a way to supply "meta" information, it also provides a way to customize your tooltips (do this by restricting the tooltip to the text aesthetic -- `ggplotly(p, tooltip = "text")`)
```

### The `plot_ly()` interface {#plot_ly}

The `plot_ly()` function draws inspiration from the grammar of graphics, but in contrast to `ggplotly()`, it provides a more flexible and direct interface to [plotly.js](https://github.com/plotly/plotly.js). It is more direct in the sense that it doesn't call **ggplot2**'s sometimes expensive plot building routines, and it is more flexible in the sense that data frames are not required, which is useful for visualizing matrices, as shown in [Get Started](#get-started). Although data frames are not required, it is recommended to use them whenever possible, especially when constructing a plot with multiple layers. 

When a data frame is associated with a **plotly** object, it allows us to manipulate the data underlying that object in the same way we would directly manipulate the data. Since every **plotly** function is designed to modify a plotly object (and the data underlying that object), we can express complex multi-layer plots as a sequence (or, more specifically, a directed acyclic graph) of data manipulations and mappings to the visual space. Moreover, **plotly** functions are designed to take a plotly object as input, and return a modified plotly object, making it easy to chain together operations via the pipe operator (`%>%`) from the **magrittr** package (something I'll refer to as the data-plot-pipeline). 

```{r}
base <- txhousing %>%
  plot_ly(x = ~date, y = ~median) %>%
  group_by(city) %>%
  add_lines(alpha = 0.2, name = "Texan Cities", hoverinfo = "none")

base %>%
  filter(city == "Houston") %>%
  add_lines(color = I("red"), name = "Houston")
```

TODO:
(1) example with data passed explicity to data argument
(2) example of multi layer plot without data frames

This "data-plot-pipeline" is desirable for a number of reasons: (1) makes your code easier to read and understand (2) any generic function that modifies a data frame can be incorporated into the pipeline (TODO: write a section on writing S3 methods?) (3) as discussed in [Linked Highlighting](#linked-highlighting), it provides a natural mechanism for implementing the pipelines necessary for interactive graphics [@plumbing].

Note that, similar to `ggplot()`, `plot_ly()` only initiatizes the plot with "global" visual attributes



This plot doesn't tell us much (other than prices seems to be increasing overall) since it's hard to see what's happening in individual cities. We could highlight a particular series by subsetting the data 

```{r}
base %>%
  group_by(date) %>% 
  summarise(
    q1 = quantile(median, 0.25, na.rm = TRUE),
    m = median(median, na.rm = TRUE),
    q3 = quantile(median, 0.75, na.rm = TRUE)
  ) %>%
  add_lines(y = ~m, color = I("red"), name = "median") %>%
  add_ribbons(ymin = ~q1, ymax = ~q3, color = I("red"), name = "IQR")
```



## Combining the two

```{r}
p <- ggplot(txhousing, aes(x = date, y = median)) +
  geom_line(aes(group = city), alpha = 0.3) +
  geom_smooth()

ggplotly(p) %>%
  filter(city == "Houston") %>%
  add_lines(color = I("red"), name = "Houston")
```

* Expose the pre-statistics data. 



## Choosing an interface {sec: choosing}


```{r}
library(plotly)
d <- subset(diamonds, carat <= 2)
p <- ggplot(d, aes(log(carat), log(price))) + 
  geom_hex() + 
  geom_smooth(method = "lm", colour = "red", se = FALSE)
ggplotly(p)
```



That's great, but there are a few reasons why this approach is limited:

1. ggplot2's interface wasn't designed for interactive graphics. Directly extending the grammar to support more advanced types of interaction (e.g., linked brushing) is a risky endeavor.
2. ggplot2 requires data frame(s) and can be inefficient (especially for time series).
3. ggplot2 does not have a functional interface (making it awkward to combine with modern functional interfaces such as dplyr), and does not satisfy [referential transparency](https://en.wikipedia.org/wiki/Referential_transparency) (making it easier to program with -- for more details, see )
4. `ggplotly()` tries to replicate _exactly_ what you see in the corresponding static ggplot2 graph. To do so, it sends axis tick information to plotly as [tickvals](https://plot.ly/r/reference/#layout-xaxis-tickvals)/[ticktext](https://plot.ly/r/reference/#layout-xaxis-ticktext) properties, and consequently, axis ticks do not update on zoom events.
