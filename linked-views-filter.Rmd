
## Highlight versus filter events {#filter}

Section \@ref(graphical-queries) provides an overview of **plotly**'s framework for *highlight* events, but it also supports *filter* events. These events trigger slightly different logic:

* A highlight event dims the opacity of existing marks, then adds an additional graphical layer representing the selection.
* A filter event completely remove existing marks and rescales axes to the remaining data.^[When using `ggplotly()`, you need to specify `dynamicTicks = TRUE`.]

Figure \@ref(fig:filter-highlight) provides a quick visual depiction in the difference between filter and highlight events. At least currently, filter events must be fired from filter widgets from the **crosstalk** package, and these widgets expect an object of class `SharedData` as input. As it turns out, the `highlight_key()` function, introduced in section \@ref(graphical-queries), creates a `SharedData` instance and is essentially a wrapper for `crosstalk::SharedData$new()`. 

```{r}
class(highlight_key(mtcars))
```

Figure \@ref(fig:filter-highlight) demonstrates the main difference in logic between filter and highlight events. Notice how, in the code implementation, the 'querying variable' definition for filter events is part of the filter widget. That is, `city` is defined as the variable of interest in `filter_select()`, not in the creation of `tx`. That is (intentionally) different from the approach for highlight events, where the 'querying variable' is a property of the dataset behind the graphical elements. 

```{r, eval = FALSE}
library(crosstalk)

# generally speaking, use a "unique" key for filter, 
# especially when you have multiple filters!
tx <- highlight_key(txhousing)
gg <- ggplot(tx) + geom_line(aes(date, median, group = city))
filter <- bscols(
  filter_select("id", "Select a city", tx, ~city),
  ggplotly(gg, dynamicTicks = TRUE),
  widths = c(12, 12)
)

tx2 <- highlight_key(txhousing, ~city, "Select a city")
gg <- ggplot(tx2) + geom_line(aes(date, median, group = city))
select <- highlight(
  ggplotly(gg, tooltip = "city"), 
  selectize = TRUE, persistent = TRUE
)

bscols(filter, select)
```

```{r filter-highlight, echo = FALSE, fig.cap = "Comparing filter to highlight events. Filter events completely remove existing marks and rescales axes to the remaining data."}
include_vimeo("307598256")
```

When using multiple filter widgets to filter the same dataset, as done in Figure \@ref(fig:multiple-filter-widgets), you should avoid referencing a non-unique querying variable (i.e., key-column) in the `SharedData` object used to populate the filter widgets. Remember that the default behavior of `highlight_key()` and `SharedData$new()` is to use the row-index (which is unique). This ensures the intersection of multiple filtering widgets queries the correct subset of data.

```{r}
library(crosstalk)
tx <- highlight_key(txhousing)
widgets <- bscols(
  widths = c(12, 12, 12),
  filter_select("city", "Cities", tx, ~city),
  filter_slider("sales", "Sales", tx, ~sales),
  filter_checkbox("year", "Years", tx, ~year, inline = TRUE)
)
bscols(
  widths = c(4, 8), widgets, 
  plot_ly(tx, x = ~date, y = ~median, showlegend = FALSE) %>% 
    add_lines(color = ~city, colors = "black")
)
```

```{r multiple-filter-widgets, echo=FALSE, fig.cap="Filtering on multiple variables."}
include_vimeo("307598347")
```

As Figure \@ref(fig:plotly-leaflet-filter) demonstrates, filter and highlight events can work in conjunction with various **htmlwidgets**. In fact, since the semantics of filter are more well-defined than highlight, linking filter events across **htmlwidgets** via **crosstalk** should generally be more well-supported.^[All R packages with **crosstalk** support are currently listed here -- https://rstudio.github.io/crosstalk/widgets.html]

```{r, eval = FALSE}
library(leaflet)

eqs <- highlight_key(quakes)
stations <- filter_slider("station", "Number of Stations", eqs, ~stations)

p <- plot_ly(eqs, x = ~depth, y = ~mag) %>% 
  add_markers(alpha = 0.5) %>% 
  highlight("plotly_selected")

map <- leaflet(eqs) %>% 
  addTiles() %>% 
  addCircles()

bscols(
  widths = c(6, 6, 3), 
  p, map, stations
)
```

```{r plotly-leaflet-filter, echo=FALSE, fig.cap="Linking **plotly** and **leaflet** through both **filter** and **highlight** events."}
include_vimeo("307597495")
```

When combining filter and highlight events, one (current) limitation to be aware of is that the highlighting variable has to be nested inside filter variable(s). For example, in Figure \@ref(fig:gapminder-filter-highlight), we can filter by continent and highlight by country, but there is currently no way to highlight by contintent and filter by country.

```{r, eval = FALSE}
library(gapminder)
g <- highlight_key(gapminder, ~country)
continent_filter <- filter_select("filter", "Select a country", g, ~continent)

p <- plot_ly(g) %>%
  group_by(country) %>%
  add_lines(x = ~year, y = ~lifeExp, color = ~continent) %>%
  layout(xaxis = list(title = "")) %>%
  highlight(selected = attrs_selected(showlegend = FALSE))

bscols(continent_filter, p, widths = 12)
```

```{r gapminder-filter-highlight, echo=FALSE, fig.cap="Combining filtering and highlighting with non-unique querying variables"}
include_vimeo("307598672")
```

<!--
PROBLEM: If you wanted to filter by continent and highlight by country using gapminder, you can't currently do that as plotly will lose the row index information. 

Have `highlight_key()` support a 

```r
library(gapminder)
g <- SharedData$new(gapminder)
continent_filter <- filter_select("filter", "Select a country", g, ~continent)

# PROPOSED SOLUTION: have this sort of use of highlight_key() somehow retain the row index information, but still query by country
p <- plot_ly(g) %>%
  highlight_key(~country) %>%
  group_by(country) %>%
  add_lines(x = ~year, y = ~lifeExp, color = ~continent) %>%
  layout(xaxis = list(title = ""))

bscols(continent_filter, p, widths = 12)
```

-->


