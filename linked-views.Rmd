# Linking views client-side

Linking of multiple data views offers a powerful approach to visualization as well as communication of structure in high-dimensional data. In particular, linking of multiple 1-2 dimensional statistical graphics can often lead to insight that a single view could not possibly reveal. For decades, statisticians and computer scientists have been using and authoring systems for multiple linked views, many of which can be found in the [ASA's video library](http://stat-graphics.org/movies). Some noteworthy videos include [focusing and linking](http://stat-graphics.org/movies/focussing-linking.html), [missing values](http://stat-graphics.org/movies/missing-data.html), and [exploring Tour De France data](http://stat-graphics.org/movies/tour-de-france.html) [@xgobi]; [@mondrianbook].

These early systems were incredibly sophisticated, but the interactive graphics they produce are not easily shared, replicated, or incorporated in a larger document. Web technologies offer the infrastructure to address these issues, which is a big reason why many modern interactive graphics systems are web based. When talking about interactive _web-based_ graphics, it's important to recognize the difference between a web application and a purely client-side webpage, especially when it comes to saving, sharing, and hosting the result. 

A web application relies on a client-server relationship where the client's (i.e., end user) web browser requests content from a remote server. This model is necessary whenever the webpage needs to execute computer code that is not natively supported by the client's web browser. As Section \@ref(linking-server-side) details, the flexibility that a web application framework, like **shiny**, offers is an incredibly productive and powerful way to link multiple data views; but when it comes to distributing a web application, it introduces a lot of complexity and computational infrastructure that may or may not be necessary.

Figure \@ref(fig:server-client) is a basic illustration of the difference between a web application and a purely client-side web page. Thanks to `JavaScript` and `HTML5`, purely client-side web pages can still be dynamic without any software dependencies besides a modern web browser. In fact, Section \ref(graphical-queries) outlines **plotly**'s graphical querying framework for linking multiple plots entirely client-side, which makes the result very easy to distribute (see Section \ref(saving)). There are, of course, many useful examples of linked and dynamic views that can not be easily expressed as a database query, but a suprising amount actually can, and the remainder can likely be quickly implemented as a **shiny** web application.

```{r server-client, echo = FALSE, fig.cap = "A diagram of the graphical querying framework underlying Figure \\@ref(fig:txhousing-aggregates)."}
knitr::include_graphics("images/server-client.svg")
```

The graphical querying framework implemented by **plotly** is inspired by @Buja:1991vh, where direct manipulation of graphical elements in multiple linked plots is used to perform data base queries and visually reveal high-dimensional structure in real-time. @Cook:2007uk goes on to argue this framework is preferable to posing data base queries dynamically via a menus, as described by @Ahlberg:1991, and goes on to state that "Multiple linked views are the optimal framework for posing queries about data". The next section shows you how to implement similar graphical queries in a standalone webpage using R code.

## Graphical queries

This section focuses on a particular approach to linking views known as graphical (database) queries using the R package **plotly**. With **plotly**, one can write R code to pose graphical queries that operate entirely client-side in a web browser (i.e., no special web server or callback to R is required). In addition to teaching you how to pose queries with the `highlight_key()` function, this section shows you how to control how queries are triggered and visually rendered via the `highlight()` function.

Figure \@ref(fig:link-intro) shows a scatterplot of the relationship between weight and miles per gallon of 32 cars. It also uses `highlight_key()` to assign the number of cylinders to each point so that when a particular point is 'queried' all points with the same number of cylinders are highlighted (the number of cylinders is displayed with text just for demonstration purposes). By default, a mouse click triggers a query, and a double-click clears the query, but both of these events can be customized through the `highlight()` function. By typing `help(highlight)` in your R console, you can learn more about what events are supported for turning graphical queries `on` and `off`.

```{r link-intro, fig.cap = "A visual depiction of how `highlight_key()` attaches metadata to graphical elements to enable graphical database queries. Each point represents a different car and the number of cylinders (`cyl`) is assigned as metadata so that when a particular point is queried all points with the same number of cylinders are highlighted."}
library(plotly)
mtcars %>%
  highlight_key(~cyl) %>%
  plot_ly(x = ~wt, y = ~mpg, text = ~cyl, mode = "markers+text", textposition = "top", hoverinfo = "x+y") %>%
  highlight(on = "plotly_hover", off = "plotly_doubleclick")
```

Generally speaking, `highlight_key()` assigns data values to graphical marks so that when graphical mark(s) are *directly manipulated* through the `on` event, it uses the corresponding data values (call it `$SELECTION_VALUE`) to perform an SQL query of the following form.

```sql
SELECT * FROM mtcars WHERE cyl IN $SELECTION_VALUE
```

For a more compelling application, lets use graphical querying to explore the `txhousing` dataset first introduced in Section \@ref(txhousing-case-study). Recall how Figure \@ref(fig:houston-vs-sa) shows Houston and San Antonio housing prices relative to other Texan cities by programmatically highlighting their time series. Instead of highlighting with code, we could allow anyone to explore prices in any city through graphical queries, as shown in Figure \@ref(fig:txmissing). One subtlety to be aware of in terms of the implementation of this graphical query is that every point along a line may have a different data value assigned to it. In this case, since the `city` column is used as both the visual grouping and interactive querying variable, we can query an individual time series by clicking on a point along that line. Section \@ref(trellis-linking) has examples of using different grouping and querying variables to query multiple related groups of visual geometries at once, which can be a powerful technique.^[This sort of idea relates closely to the notion of generalized selections as described in @heer2008generalized.]

```{r txmissing, fig.cap = "Graphical query of housing prices in various Texas cities. The query in this particular example must be triggered through clicking directly on a time series."}
# set `city` as the SQL 'query by' column
tx <- highlight_key(txhousing, ~city)

# initiate a plotly object
base <- plot_ly(tx, color = I("black")) %>% 
  group_by(city)

# create a time series of median house price
time_series <- base %>%
  group_by(city) %>%
  add_lines(x = ~date, y = ~median)

# set a default query to 'South Padre Island' which can be changed via mouse click 
highlight(time_series, on = "plotly_click", defaultValue = "South Padre Island")
```

Querying a city via direct manipulation is somewhat helpful for focusing on a particular time series, but it's not so helpful for querying a city by name and/or comparing multiple cities at once. As it turns out, **plotly** makes it easy to add a selectize.js powered dropdown widget for querying by name (aka indirect manipulation) by setting `selectize = TRUE`.^[The title that appears in the dropdown can be controlled via the `group` argument in the `highlight_key()` function. The primary purpose of the `group` argument is to isolate one group of linked plots from others.] When it comes to comparing multiple cities, we want to be able to both retain previous selections (`persistent = TRUE`) as well as control the highlighting color (`dynamic = TRUE`). This videos explains how to use these features in Figure \@ref(fig:txmissing-modes) to compare pricing across different cities.

```{r, echo = FALSE}
# hack to isolate the querying
tx <- highlight_key(txhousing, ~city, " ")
base <- plot_ly(tx, color = I("black")) %>% 
  group_by(city)
time_series <- base %>%
  group_by(city) %>%
  add_lines(x = ~date, y = ~median)
```

```{r txmissing-modes, fig.cap = "Using a selectize dropdown widget to search for cities by name and comparing multiple cities through persistent selection with a dynamic highlighting color. See [this video](https://vimeo.com/202647310) for a demo and audio explanation."}
highlight(time_series, on = "plotly_click", selectize = TRUE, dynamic = TRUE, persistent = TRUE)
```

By querying a few different cities in Figure \@ref(fig:txmissing-modes), one obvious thing we can learn is that not every city has complete pricing information (e.g., South Padre Island, San Marcos, etc). To learn more about what cities are missing information as well as how that missingness is structured, Figure \@ref(fig:txmissing-linked) links a view of the raw time series to a dot-plot of the corresponding number of missing values per city. In addition to making it easy to see how cities rank in terms of missing house prices, it also provides a way to query the corresponding time series (i.e., reveal the structure of those missing values) by brushing cities in the dot-plot. This general pattern of linking aggregated views of the data to more detailed views fits the famous and practical information visualization advice from @details-on-demand: "Overview first, zoom and filter, then details on demand".

```{r, echo = FALSE}
tx <- highlight_key(txhousing, ~city, "  ")
base <- plot_ly(tx, color = I("black")) %>% 
  group_by(city)
time_series <- base %>%
  group_by(city) %>%
  add_lines(x = ~date, y = ~median)
```

```{r txmissing-linked, fig.cap="Linking a dot-plot of the number of missing housing prices with the raw time series. By brushing markers on the dot-plot, their raw time series is highlighted on the right hand side."}
# remember, `base` is a plotly object, but we can use dplyr verbs to
# manipulate the input data 
# (`txhousing` with `city` as a grouping and querying variable)
dot_plot <- base %>%
  summarise(miss = sum(is.na(median))) %>%
  filter(miss > 0) %>%
  add_markers(x = ~miss, y = ~forcats::fct_reorder(city, miss), hoverinfo = "x+y") %>%
  layout(
    xaxis = list(title = "Number of months missing"),
    yaxis = list(title = "")
  ) 

subplot(dot_plot, time_series, widths = c(0.2, 0.8), titleX = TRUE) %>%
  layout(showlegend = FALSE) %>%
  highlight(on = "plotly_selected", dynamic = TRUE, selectize = TRUE)
```


How does **plotly** know to highlight the time series when markers in the dot-plot are selected? The answer lies in what data values are embedded in the graphical markers via `highlight_key()`. When 'South Padre Island' is selected, like in Figure \@ref(fig:pipeline-diagram), it seems as though the logic says to simply change the color of any graphical elements that match that value, but the logic behind **plotly**'s graphical queries is a bit more subtle and powerful. Another, more accurate, framing of the logic is to first imagine a linked database query being performed behind the scenes (as in Figure \@ref(fig:pipeline-diagram)). When 'South Padre Island' is selected, it first filters the aggregated dot-plot data down to just that one row, then it filters down the raw time-series data down to every row with 'South Padre Island' as a city. The drawing logic will then call [`Plotly.addTrace()`](https://plot.ly/javascript/plotlyjs-function-reference/#plotlyaddtraces) with the newly filtered data which adds a new graphical layer representing the selection, allowing us to have finely-tuned control over the visual encoding of the data query.

```{r pipeline-diagram, echo = FALSE, fig.cap = "A diagram of the graphical querying framework underlying Figure \\@ref(fig:txmissing-linked)."}
knitr::include_graphics("images/pipeline.svg")
```

The biggest advantage of drawing an entirely new graphical layer with the filtered data is that it becomes easy to leverage [statistical trace types](https://plot.ly/r/statistical-charts/) for producing summaries that are conditional on the query. Figure \@ref(fig:txhousing-aggregates) leverages this functionality to dynamically produce probability densities of house price in response to a query events. Section \@ref(statistical-queries) has more examples of leveraging statistical trace types with graphical queries.

```{r, echo = FALSE}
tx <- highlight_key(txhousing, ~city, "   ")
base <- plot_ly(tx, color = I("black")) %>% 
  group_by(city)
time_series <- base %>%
  group_by(city) %>%
  add_lines(x = ~date, y = ~median)
```

```{r txhousing-aggregates, fig.cap = "Linking house prices as a function of time with their probability density estimates."}
hist <- base %>% add_histogram(x = ~median, histnorm = "probability density")
subplot(time_series, hist, nrows = 2) %>%
  layout(barmode = "overlay", showlegend = FALSE) %>%
  highlight(dynamic = TRUE, selectize = TRUE, selected = attrs_selected(opacity = 0.3))
```

Another neat consequence of drawing a completely new layer is that we can control the  plotly.js attributes in that layer through the `selected` argument of the `highlight()` function. In Figure \@ref(fig:txhousing-aggregates) we use it to ensure the new highlighting layer has some transparency to more easily compare the city specific distribution to the overall distribution.

<!--
Figure \@ref(fig:txhousing-miss) is a fairly simple example of how **plotly**'s graphical querying framework allows you to think of linking of plots similar to how you'd link tables in a SQL database. This approach, although perhaps not completely intuitive at first, grants a nice balance between flexibility and productiveness when creating linked views.
-->

This section is designed to help give you a foundation for leveraging graphical queries in your own work. Hopefully by now you have a rough idea what graphical queries are, how they can be useful, and how to create them with `highlight_key()` and `highlight()`. Understanding the basic idea is one thing, but applying it effectively to new problems is another thing entirely. To help spark your imagination and demonstrate what's possible, Section \@ref(querying-examples) has numerous subsections each with numerous examples of graphical queries in action. 
