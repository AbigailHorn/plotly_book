# Linking views server-side {#linking-server-side}

Section \@ref(graphical-queries) covers an approach to linking views client-side with graphical database queries, but not every linked data view can be reasonably framed as a database query. If you need more control, you have at least two more options: add custom JavaScript (covered in section \@ref(javascript)) and/or link views server-side via a web application. Some concepts useful for the former approach are covered in \@ref(javascript), but this chapter is all about the latter approach.

There are several different frameworks for creating web applications via R, but we'll focus our attention on linking **plotly** graphs with **shiny** -- an R package for creating reactive web applications entirely in R. **Shiny**'s reactive programming model allows R programmers to build upon their existing R knowledge and create data-driven web applications without any prior web programming experience. **Shiny** itself is largely agnostic to the engine used to render data views (that is, you can incorporate any sort of R output), but **shiny** itself also adds some special support for interacting with static R graphics and images [@shiny-plot-interaction].

When linking graphics in a web application, there are tradeoffs to consider when using static R plots over web-based graphics. As it turns out, those tradeoffs complement nicely with the relative strengths and weaknesses of linking views with **plotly**, making their combination a powerful toolkit for linking views on the web from R. **Shiny** itself provides a way to access events with static graphics made with any of the following R packages: **graphics**, **ggplot2**, and **lattice**. These pac are very mature, fully-featured, well-tested, and support a incredibly wide range of graphics. Comparatively speaking, **plotly** does not have the same range and history. However, interacting with static graphics can lead to a poor user experience because everytime a static graphic needs to be updated, **shiny** must make a round-trip to the server and regenerate an entirely new image. On the other hand, since **plotly** is inherently web-based, it allows for more control over how the graphics update in response to user input (e.g., change the color of a few points instead of redrawing the entire image). This idea is explored in more depth in section \@ref(updating-views).

This chapter teaches you how to link both static R and **plotly** graphics inside **shiny**, how to get those graphics communicating with other types of data views, and how to do it all efficiently. Section \@ref(hello-shiny) provides an introduction to **shiny** it's reactive programming model, Section \@ref(shiny-inputs) shows how to access user input to both **plotly** and static graphics in **shiny**, Section \@ref(updating-views) shows how to update views based on these user input events, Section \@ref(targeting-views) shows how to target specific views, and Section \@ref(advanced-applications) demonstrates some advanced applications.

## Embedding plotly in shiny {#hello-shiny}

Before linking views with **plotly** inside **shiny**, let's first talk about how to embed **plotly** inside a basic **shiny** app! Through a couple basic examples, you'll learn the basic components of a **shiny** and get a feel for **shiny**'s reactive programming model, as well as pointers to more learning materials.

### Your first shiny app

The most common **plotly**+**shiny** pattern uses a **shiny** input to control a **plotly** output. Figure \@ref(fig:shiny-intro) gives a simple example of using **shiny**'s `selectizeInput()` function to create a dropdown that controls a **plotly** graph. This example, as well as every other **shiny** app, has two main parts:

1. The *user interface*, `ui`, defines how inputs and output widgets are displayed on the page. The `fluidPage()` function offers a nice and quick way get a grid-based responsive layout^[Read more about **shiny**'s responsive layout here https://shiny.rstudio.com/articles/layout-guide.html], but it's also worth noting the UI is completely customizable^[Read more about using custom HTML templates here https://shiny.rstudio.com/articles/html-ui.html], and packages such as **shinydashboard** make it easy to leverage more sophisticated layout frameworks [@shinydashboard]. 
2. The *server* function, `server`, defines a mapping from input values to output widgets. More specifically, the **shiny** `server` is an R `function()` between `input` values on the client and `output`s generated on the web server.

Every input widget, including the `selectizeInput()` in Figure \@ref(fig:shiny-intro), is tied to a input value that can be accesssed on the server inside a reactive expression. **Shiny**'s reactive expressions build a dependency graph between outputs (aka, reactive endpoints) and inputs (aka, reactive sources). The true power of reactive expressions lies in their ability to chain together and cache computations, but let's first focus on generating outputs. In order to generate an output, you have to choose a suitable function for rendering the result of a reactive expression.

Figure \@ref(fig:shiny-intro) uses the `renderPlotly()` function to render a reactive expression that generates a **plotly** graph. This expression depends in the input value `input$cities` (i.e., the input value tied to the input widget with an `inputId` of `"cities"`) and stores the output as `output$p`. This instructs **shiny** to insert the reactive graph into the `plotlyOutput(outputId = "p")` container defined in the user interface.

```r
library(shiny)
library(plotly)

ui <- fluidPage(
  selectizeInput(
    inputId = "cities", 
    label = "Select a city", 
    choices = unique(txhousing$city), 
    selected = "Abilene",
    multiple = TRUE
  ),
  plotlyOutput(outputId = "p")
)

server <- function(input, output, ...) {
  output$p <- renderPlotly({
    plot_ly(txhousing, x = ~date, y = ~median) %>%
      filter(city %in% input$cities) %>%
      group_by(city) %>%
      add_lines()
  })
}

shinyApp(ui, server)
```

```{r shiny-intro, echo=FALSE, fig.cap="Using a **shiny** input widget to control which time series are shown on a **plotly** graph."}
knitr::include_graphics("https://i.imgur.com/Qxf5bxP.gif")
```

If, instead of a **plotly** graph, a reactive expression generates a static R graphic, simply use `renderPlot()` (instead of `renderPlotly()`) to render it and `plotOutput()` (instead of `plotlyOutput()`) to position it. Other **shiny** output widgets also use this naming convention: `renderDataTable()`/`datatableOutput()`, `renderPrint()`/`verbatimTextOutput()`, `renderText()`/`textOutput()`, `renderImage()`/`imageOutput()`, etc. Packages that are built on the **htmlwidgets** standard (e.g. **plotly** and **leaflet**) are, in some sense, also **shiny** output widgets that are encouraged to follow this same naming convention (e.g. `renderPlotly()`/`plotlyOutput()` and `renderLeaflet()`/`leafletOutput()`).

**Shiny** also comes pre-packaged with a handful of other useful input widgets. Although many **shiny** apps use them straight "out-of-the-box", input widgets can easily be stylized with CSS and/or SASS, and even custom input widgets can be integrated [@sass, @shiny-custom-inputs].

* `selectInput()`/`selectizeInput()` for dropdown menus.
* `numericInput()` for a single number.
* `sliderInput()` for a numeric range.
* `textInput()` for a character string.
* `dateInput()` for a single date.
* `dateRangeInput()` for a range of dates.
* `fileInput()` for uploading files.
* `checkboxInput()`/`checkboxGroupInput()`/`radioButtons()` for choosing a list of options.

Going forward our focus is to link multiple graphs in **shiny** through direct manipulation, so we focus less on using these input widgets, and more on using **plotly** and static R graphics as inputs to other output widgets. Section \@ref(shiny-inputs) provides an introduction to this idea, but before we learn how to access these input events, you may want to know a bit more about rendering **plotly** inside **shiny**.

### Hiding and redrawing on resize

The `renderPlotly()` function renders anything that the `plotly_build()` function understands, including `plot_ly()`, `ggplotly()`, and **ggplot2** objects.^[The `plotly_build()` function is an S3 generic, so you can list all relevant the methods with `methods(plotly_build)`, and write you're own method to translate a custom object to **plotly**.] It also renders `NULL` as an empty HTML div, which is handy for certain cases where it doesn't make sense to render a graph. Figure \@ref(fig:shiny-ggplotly) leverages these features to render an empty div while `selectizeInput()`'s placeholder is shown, but then render a **plotly** graph via `ggplotly()` once cities have been selected. Figure \@ref(fig:shiny-ggplotly) also shows how to make the **plotly** output depend on the size of the container that holds the **plotly** graph. By default, when a browser is resized, the graph size is changed purely client-side, but this reactive expression will re-execute when the browser window is resized. Due to technical reasons this can improve `ggplotly()` resizing behavior^[In order to convert **grid** grobs that are relatively sized, the `ggplotly()` function uses the size of the current graphics device at print-time, meaning that resizing the browser window without a hook back to R can create wonky sizes.], but should be used with caution when handling large data and long render times.

```r
library(shiny)
library(plotly)

cities <- unique(txhousing$city)

ui <- fluidPage(
  selectizeInput(
    inputId = "cities", 
    label = NULL,
    # placeholder prompt is triggered when first choice is an empty string
    choices = c("Please choose a city" = "", cities), 
    multiple = TRUE
  ),
  plotlyOutput(outputId = "p")
)

server <- function(input, output, session, ...) {
  output$p <- renderPlotly({
    req(input$cities)
    if (identical(input$cities, "")) return(NULL)
    p <- ggplot(data = filter(txhousing, city %in% input$cities)) + 
      geom_line(aes(date, median, group = city))
    ggplotly(p, height = session$clientData$output_p_height, width = session$clientData$output_p_width)
  })
}

shinyApp(ui, server)
```

```{r shiny-ggplotly, echo=FALSE, fig.cap="Rendering a **plotly** graph in **shiny** if and only if the `selectizeInput()`'s dropdown is non-empty. When the graph is present, and the window is resized, then the reactive expression is re-evaluated."}
knitr::include_graphics("https://i.imgur.com/1yzHLF2.gif")
```


When a reactive expression inside `renderPlotly()` is re-executes, it triggers a full redraw of the **plotly** graph on the client. Generally speaking, this makes your **shiny** app logic easy to reason about, but it's not always performant enough. For example, say you have a scatterplot with 10s of thousands of points, and you just want to add a fitted line to those points (in respond to input event)? Instead of redrawing the whole plot from scratch, it can be way more performant to partially modify/add/remove things from the plot. Techniques for this use case are covered in section \@ref(performance).

<!--
The `renderPlotly()` function anticipates a reactive expression that generates a **plotly** object. **Shiny** itself provides a handful of similar functions that anticipate more "standard" R outputs, like data frames (`renderTable()` or `renderDataTable()`), output from the R graphics device (`renderPlot()`), and things printed to the R console (`renderPrint()` or `renderText()`). Other R packages sometimes provide a custom reactive for a custom R object, and in fact, the **htmlwidgets** package provides a standard way to scaffold this reactive glue which **plotly** implements with `renderPlotly()` and **leaflet** implements with `renderLeaflet()`.

Once a reactive expression generates a value, it needs to know where on the user interface to place the output result. That is why the result of `renderPlotly()` in Figure \@ref(fig:shiny-intro) is assigned to `output$p`. This information lets **shiny** know to insert the code result into `plotlyOutput("p")`, the UI output with an id of "p". At face value, it may seem like **shiny**'s reactive expressions can only produce output widgets, but `renderUI()` allows one to dynamically render input widgets on the server as well.
-->

## Using graphical output as a shiny input {#shiny-inputs}

Section \@ref(fig:shiny-intro) covered how to render **shiny** output widgets (e.g., `plotlyOutput()`) that depend on a input widget, but what if we want an output widget to server as an input to another output (i.e., link multiple graphs)? Generally speaking, it doesn't always make sense to have a shiny output function like an input to another output, but there are handful of output widgets that do make this possible, including but no limited to: `shiny::plotOutput()`, `plotly::plotlyOutput()`, `leaflet::leafletOutput()`, and `DT::dataTableOutput()`. Section \@ref(plotly-inputs) outlines the approach for `plotlyOutput()` and section \@ref(static-inputs) outlines the approach for `plotOutput()`.

### Accessing plotly input events {#plotly-inputs}

The `event_data()` function is the most straight-forward way to access a **plotly** input events in **shiny**. Just like any other **shiny** input, this function needs to be used inside a reactive context and should reference a particular type of **plotly** input event. Most of these available events are data-specific traces (e.g., `"plotly_hover"`, `"plotly_click"`, `"plotly_selected"`, etc), but there are also some that are layout-specific (e.g., `"plotly_relayout"`). 

The **shiny** app in Figure \@ref(fig:plotlyEvents) shows you how to access common trace events and print verbatim the corresponding data via `renderPrint()`. When using this event data to inform (i.e., update) another related data view, it's often necessary to know exactly what row(s) of data were queried in the event (i.e., the `x`/`y` positions alone may not be enough to uniquely identify a piece of information). For this reason, if a `key` attribute is supplied through to `plot_ly()`, or a `key` aesthetic to **ggplot2**, that information will be relayed along with the input event.

There are currently four different modes for click+drag interactions in plotly.js, but only two will trigger a `"plotly_selected"` event: rectangular and lasso selection. The other two drag modes, zoom and pan, both emit a `"plotly_relayout"` event which could be useful for, say, recomputing a model based on new x/y limits. Figure \@ref(fig:plotlyEvents) uses [dragmode](https://plot.ly/r/reference/#layout-dragmode) attribute to set the default click+drag mode rectangular selection, but the mode can also be changed interactively via the mode bar at the top of the graph.


```r
library(shiny)
library(plotly)

ui <- fluidPage(
  radioButtons("plotType", "Plot Type:", choices = c("ggplotly", "plotly")),
  plotlyOutput("plot"),
  verbatimTextOutput("hover"),
  verbatimTextOutput("click"),
  verbatimTextOutput("brush")
)

server <- function(input, output, session) {
  
  nms <- row.names(mtcars)
  
  output$plot <- renderPlotly({
    p <- if (identical(input$plotType, "ggplotly")) {
      ggplotly(
        ggplot(mtcars, aes(x = mpg, y = wt, key = nms)) + geom_point()
      )
    } else {
      plot_ly(mtcars, x = ~mpg, y = ~wt, key = nms)
    }
    layout(p, dragmode = "select")
  })
  
  output$hover <- renderPrint({
    d <- event_data("plotly_hover")
    if (is.null(d)) "Hover events appear here (unhover to clear)" else d
  })
  
  output$click <- renderPrint({
    d <- event_data("plotly_click")
    if (is.null(d)) "Click events appear here (double-click to clear)" else d
  })
  
  output$brush <- renderPrint({
    d <- event_data("plotly_selected")
    if (is.null(d)) "Click and drag events (i.e., select/lasso) appear here (double-click to clear)" else d
  })
  
}

shinyApp(ui, server, options = list(display.mode = "showcase"))
```

```{r plotlyEvents, echo=FALSE, fig.cap = "A video demonstration of plotly events in shiny. The video can be accessed [here](https://i.imgur.com/z6xNTtX.gif)"}
knitr::include_graphics("https://i.imgur.com/z6xNTtX.gif")
```

The `"plotly_click"` and `"plotly_hover"` events are supported for nearly every trace type (there are currently 35 types!), but `plotly_selected` is generally only available for 2D charts (i.e., it won't work for `scatter3d`, `surface`, `mesh`, etc.). One 2D trace type that does not support any of these events is `parcoords` -- it's overall design is quite different from the others in that it natively supports brushing lines along an axis dimension. However, as Figure \@ref(fig:shiny-parcoords) demonstrates, these brush events emit a `plotly_restyle` event with the range(s) of the highlighted dimension.^[To see how to map these ranges back to the highlighted observations, see the example `plotly_example("shiny", "event_data_parcoords")`]

```r
library(plotly)
library(shiny)

ui <- fluidPage(
  plotlyOutput("parcoords"),
  verbatimTextOutput("info")
)

server <- function(input, output, session) {
  
  output$parcoords <- renderPlotly({
    plot_ly(iris) %>%
      add_parcoords()
  })
  
  output$info <- renderPrint({
    d <- event_data("plotly_restyle")
    if (is.null(d)) "Brush along a dimension" else d
  })
  
}

shinyApp(ui, server)
```

```{r shiny-parcoords, echo=FALSE, fig.cap = "Using the `plotly_restyle` event to access brushed dimensions of a parallel coordinates plot."}
knitr::include_graphics("https://i.imgur.com/2f7MGCd.gif")
```

Beyond the `parcoords` edge case, the `plotly_restyle` and `plotly_relayout` events can also be used to detect any changes to plotly.js traces (restyle) and layout (relayout). More specifically, these events are emitted whenever the plotly.js functions `Plotly.restyle()` or `Plotly.relayout()` are called. As shown in section \@ref(performance), these functions are handy for partially modifying an existing plot (i.e., avoid performing a full redraw), and we can leverage them from R in a **shiny** app. As it turns out, sometimes these events are fired as a part of another, higher-order task, like dragging shapes.

Figure \@ref(fig:shiny-drag-circle) demonstrates dragging a circle shape and accessing the new positions of the circle though the `plotly_relayout` event. The ability to drag shapes can be enabled through the `config()` function through the `edits` attribute. This attribute allows you enable direct manipulation of certain aspects of the layout (note that traces can not be edited). In this case, we only want to drag shapes, but one could use `config(p, editable = TRUE)` to make everything in the layout editable (e.g. the plot and axis titles).

```r
library(shiny)
library(plotly)

ui <- fluidPage(
  plotlyOutput("p"),
  verbatimTextOutput("event")
)

server <- function(input, output, session) {
  
  output$p <- renderPlotly({
    plot_ly() %>%
      layout(
        xaxis = list(range = c(-10, 10)),
        yaxis = list(range = c(-10, 10)),
        shapes = list(
          type = "circle", 
          fillcolor = "gray",
          line = list(color = "gray"),
          x0 = -10, x1 = 10,
          y0 = -10, y1 = 10,
          xsizemode = "pixel", 
          ysizemode = "pixel",
          xanchor = 0, yanchor = 0
        )
      ) %>%
      config(edits = list(shapePosition = TRUE))
  })
  
  output$event <- renderPrint({
    event_data("plotly_relayout")
  })
  
}

shinyApp(ui, server)
```

```{r shiny-drag-circle, echo=FALSE, fig.cap = "Dragging a circle shape and accessing the positions in **shiny** via `event_data('plotly_relayout')`"}
knitr::include_graphics("https://i.imgur.com/FUxQXbY.gif")
```

Figure \@ref(fig:shiny-drag-line) uses the ability to react to the dragging of shapes to snap a vertical line shape to the closest point in a sequence of x values. It also places on a marker at the intersection of this vertical line shape and a line chart of random y values. Notice how, by accessing `event_data()` in this way (i.e., the source and target view of the event is the same), the chart is actually fully redrawn every time the line shape moves. If performance were an issue (i.e., we were dealing with lots of lines), this type of interaction likely won't be very responsive. In that case, you can use `event_data()` to trigger side-effects (i.e., partially modify the plot) which is covered in \@ref(performance).

```r
library(shiny)
library(plotly)

ui <- fluidPage(
  plotlyOutput("p"),
  verbatimTextOutput("event")
)

x <- seq(-10, 10)
y <- rnorm(length(x))

server <- function(input, output, session) {
  
  output$p <- renderPlotly({
    d <- event_data("plotly_relayout")
    selected_point <- if (!is.null(d[["shapes[0].x0"]])) {
      # 'snap' the x-position from the event to the closest `x` value
      xint <- d[["shapes[0].x0"]]
      xpt <- x[which.min(abs(x - xint))]
      list(x = xpt, y = y[which(x == xpt)])
    } else {
      # default to 
      list(x = 1, y = y[which(x == 1)])
    }
    
    plot_ly(color = I("red")) %>%
      add_lines(x = x, y = y) %>%
      add_markers(x = selected_point$x, y = selected_point$y) %>%
      layout(
        shapes = list(
          type = "line", 
          line = list(color = "gray", dash = "dot"),
          x0 = selected_point$x, 
          x1 = selected_point$x,
          y0 = 0,
          y1 = 1,
          yref = "paper"
        )
      ) %>%
      config(editable = TRUE)
  })
  
}

shinyApp(ui, server)
```


```{r shiny-drag-line, echo=FALSE, fig.cap = "Dragging a vertical line shape and 'snapping' the line to match the closest provided `x` value. "}
knitr::include_graphics("https://i.imgur.com/FUxQXbY.gif")
```

In summary, it's possible to access information about and react to direct manipulation events with a **plotly** graph through referencing `event_data()` in a **shiny** reactive expression. Section \@ref(updating-views) covers how to route this sort of information from these events to other views in a **shiny** application. Section \@ref(targetting-views) discusses how to scope these events to specific views and section \@ref(performance) and discusses helpful techniques for ensuring your **shiny** application is responsive as possible. For sake of comparison and to enhance the discussion, the next section discusses accessing similar events using `shiny::plotOutput()`.

<!--
### Accessing static plot events {#static-inputs}

The **shiny** package provides access to direct manipulation events made with plots generated with the R graphics device as well any raster-based image. The model for providing access is substaintially different from **plotly** 
-->


## Updating views {#updating-views}

TODO: 

(1) rewrite and perhaps incorporate https://github.com/cpsievert/apps/blob/master/shiny/apps/plotlyAg/app.R


Obtaining data from a plotly event is easy, but updating view(s) based on the result of an event can be difficult. To start with something fairly easy, consider two scatterplots showing the same observations, but on different axes (i.e., a subset of a scatterplot matrix). Figure \@ref(fig:plotlyLinkedBrushEasy) shows a linked lasso brush between two scatterplots. The main idea is that we first plot all the observations in black, then highlight the selection by adding an additional layer of selected points in red using the data returned by `event_data()`. In order to guarantee that we can uniquely identify observations in the event data, it is also crucial that we attach a `key` attribute to each observation (here the rownames of the data), which we can then use to filter the original data down to the selected observations. 

Figure \@ref(fig:plotlyLinkedBrushEasy) consciously updates the source of the selection (the top plot) to match the visual characteristics of the target (the bottom plot). In general, whenever linking views to display graphical selection(s), matching the visual characteristics of the selection both the source and target(s) can aide interpretation, especially when using interactive graphics to present results to others. Although the update rule in Figure \@ref(fig:plotlyLinkedBrushEasy) is to simply layer on additional points, a full redraw is performed during the update, which can impact performance when dealing with a large amount of graphical elements.

Figure \@ref(fig:plotlyLinkedBrushEasy) could be made slightly more efficient by just changing the color of selected points, or dimming the non-selected points, rather than plotting an extra layer of points. However, this technique does not work for chart types that display aggregate values (e.g., how do you dim non-selected values in a box plot?). For this reason, in [Linking views without shiny](#linking-views-without-shiny), selections are implemented as an additional layer, but avoid the full redraw required when updating plot via **shiny** reactive framework.^[To my knowledge, the **leaflet** package is the only R package which provides a way to update a plot in a shiny app without a full redraw.]

```{r plotlyLinkedBrushEasy, echo=FALSE, fig.cap = "A video demonstration of linked brushing in a shiny app. The video can be accessed [here](http://i.imgur.com/rUroUHT.gif) and the code to run the example is [here](https://gist.github.com/cpsievert/5934f173cafffb8dfb4f23d5488cd185)"}
knitr::include_graphics("images/plotlyLinkedBrushEasy.gif")
```

Since the update rule is the same for each view in Figure \@ref(fig:plotlyLinkedBrushEasy), we end up with a lot of redundant code that can be made more modular, as shown [here](https://gist.github.com/cpsievert/6fc17f4dc6d43c88dd214c12bb1a0324). Making code more modular not only makes for less reading, but it leaves you less prone to making mistakes. Since the only difference between the two plots is the x/y variables, we can write a function that accepts x/y variables as input, and output a plotly object. Since this function outputs a plotly object, and is dependent upon `event_data()`, which can only be called within a reactive expression, this function can only be called within the `renderPlotly()` function in the **plotly** package. 

```{r plotlyLinkedBrush, eval=FALSE, echo=FALSE, fig.cap = "Linked brushing between a scatterplot and marginal histograms."}
knitr::include_graphics("images/plotlyLinkedBrush.gif")
```


## Targeting views {#targeting-views}

The linked brushing example in Figure \@ref(fig:plotlyLinkedBrushEasy) has bi-directional communication -- a `"plotly_selected"` event deriving from either view impacts the other view. In other words, each view can be either the source or target of the selection. Often times, we want _one_ view to be the source of a selection, and related view(s) to be the target. Figure \@ref(fig:plotlyLinkedClick) shows a heatmap of a correlation matrix (the source of a selection) linked to a scatterplot (the target of a selection). By clicking on a cell in the correlation matrix, a scatterplot of the two variables is displayed below the matrix. 

To update the scatterplot view, Figure \@ref(fig:plotlyLinkedClick) accesses `"plotly_click"` events via the `event_data()` function, but it also careful to not access click events triggered from the scatterplot. By strategically matching the value of the `source` argument in the `plot_ly()` and `event_data()` functions, Figure \@ref(fig:plotlyLinkedClick) effectively restricts the scope of events to a specific plot (the heatmap).

```{r plotlyLinkedClick, echo=FALSE, fig.cap = "A video demonstration of clicking on a cell in a correlation matrix to view the corresponding scatterplot. The video can be accessed [here](http://i.imgur.com/2pNZejk.gif) and the code to run the example is [here](https://gist.github.com/cpsievert/ece4741967baf1840843ecc44c1bb677)"}
knitr::include_graphics("images/plotlyLinkedClick.gif")
```

Another aspect of Figure \@ref(fig:plotlyLinkedClick) that makes it an interesting example is that the `key` attribute is a matrix, matching the same dimensions of `z` (i.e, the values displayed in each cell). For good reason, most linked views paradigms (including the paradigm discussed in [Linking views without shiny](#linking-views-without-shiny)) restrict linkage definitions to relational database schema. In this case, it is more efficient to implement the relation with a key matrix, rather than a column.


## Improving performance {#shiny-performance}

Multiple linked views are known to help facilitate data exploration, but latency in the user interface is also known to reduce exploratory findings [@2014-latency]. In addition to the advice and techniques offered in section \@ref(performance) for improving **plotly**'s performance in general, there are also techniques specifically for **shiny** apps that you can leverage to help improve the user experience. 

When trying to speed-up any slow code, the first step is always to identify the main contributor(s) to the poor performance. In some cases, your intuition may serve as a helpful guide, but in order to *really* see what's going on, consider using a code profiling tool like **profvis** [@profvis]. The **profvis** package provides a really nice way to visualize and isolate slow running R code in general, but it also works well for profiling **shiny** apps [@profvis-shiny]. 

A lot of different factors can contribute to poor performance in a **shiny** app, but thankfully, the **shiny** ecosystem provides an extensive toolbox for diagnosing and improving performance. The **profvis** package is great for identifying "universal" performance issues, but when deploying shiny apps into production, there may be other potential bottlenecks that surface. This is largely due to R's single-threaded nature -- a single R server has difficulty scaling to many users because, by default, it can only handle one job at a time. The  **shinyloadtest** package helps to identify those bottlenecks and **shiny**'s support for asynchronous programming with **promises** is one way to address them without increasing computational infrastructure (e.g. multiple servers) [@shinyloadtest, @promises].

To reiterate the section on "Improving performance and scalability" in **shiny** from @async, you have a number of tools available to address performance:

1. The **profvis** package for profiling code.
2. Cache computations ahead-of-time.
3. Cache computations at run time.
4. Cache computations through chaining reactive expressions.
5. Leverage multiple R processes and/or servers.
6. Async programming with **promises**

We won't directly cover these topics, but it's worth noting that all these tools are primarily designed for improving _server-side_ performance of a **shiny** app. It could be that sluggish plots in your **shiny** app are due to sluggish server-side code, but it could also be that some of the sluggishness is due to redundant work being done client-side by **plotly**. Avoiding this redundancy, as covered in section \@ref(proxies), can be difficult, and it doesn't always lead to noticable improvements. However, when you need to put lots of graphical elements on a plot, then update just a portion of the plot in response to user event(s), the added complexity can be worth the effort.

### Partial plotly updates {#proxies}

By default, when `renderPlotly()` renders a new **plotly** graph it's essentially equivalent to executing a block of R code from your R prompt and generating a new **plotly** graph from scratch. That means, not only does the R code need to re-execute to generate a new R object, but it also has to re-serialize that object as JSON, and your browser has to re-render the graph from the new JSON object (more on this in section \@ref(performance)). In cases where your **plotly** graph does not need to serialize a lot data and/or render lots of graphical elements, as in Figure \@ref(fig:shiny-intro), you can likely perform a full redraw without noticable glitches, especially if you use canvas-based rendering rather than SVG (i.e., `toWebGL()`). Generally speaking, you should try very hard to make your app responsive before adopting partial **plotly** updates in **shiny**. It makes your app logic easy to reason about because you don't have to worry about maintaining the state of the graph, but sometimes you have no other choice.

On initial page load, **plotly** graphs must be drawn from stratch, but when responding to certain user events, often times a partial update to an existing plot is sufficient and more responsive. Take, for instance, the difference between Figure \@ref(fig:shiny-scatterplot), which does a full redraw on every update, and Figure \@ref(fig:shiny-scatterplot-performant), which does a partial update after initial load. Both of these **shiny** apps display a scatterplot with 100,000 points and allow a user to overlay a fitted line through a checkbox. The key difference is that in Figure \@ref(fig:shiny-scatterplot), the **plotly** graph is regenerated from scratch everytime the value of `input$smooth` changes, whereas in Figure \@ref(fig:shiny-scatterplot-performant) only the fitted line is added/removed from the **plotly**. Since the main bottleneck lies in redrawing the points, Figure \@ref(fig:shiny-scatterplot-performant) can add/remove the fitted line is a much more responsive fashion.


```r
library(shiny)
library(plotly)

# Generate 100,000 observations from 2 correlated random variables
d <- MASS::mvrnorm(1e6, mu = c(0, 0), Sigma = matrix(c(1, 0.5, 0.5, 1), 2, 2))
d <- setNames(as.data.frame(d), c("x", "y"))

# fit a simple linear model
m <- lm(y ~ x, data = d)

# generate y predictions over a grid of 10 x values
dpred <- data.frame(
  x = seq(min(d$x), max(d$x), length.out = 10)
)
dpred$yhat <- predict(m, newdata = dpred)

ui <- fluidPage(
  plotlyOutput("scatterplot"),
  checkboxInput("smooth", label = "Overlay fitted line?", value = FALSE)
)

server <- function(input, output, session) {
  
  output$scatterplot <- renderPlotly({
    
    p <- plot_ly(d, x   = ~x, y = ~y) %>%
      add_markers(color = I("black"), alpha = 0.05) %>%
      toWebGL() %>%
      layout(showlegend = FALSE)
    
    if (!input$smooth) return(p)
      
    add_lines(p, data = dpred, x = ~x, y = ~yhat, color = I("red"))
  })
  
}

shinyApp(ui, server)
```

```{r shiny-scatterplot, echo=FALSE, fig.cap="Naive implementation of a shiny app that optionally overlays a fitted line to a scatterplot."}
knitr::include_graphics("https://i.imgur.com/Sw7FJo9.gif")
```


In terms of the implementation behind Figure \@ref(fig:shiny-scatterplot) and \@ref(fig:shiny-scatterplot-performant), the only difference resides in the `server` definition. In Figure \@ref(shiny-scatterplot-performant), the `renderPlotly()` statement no longer has a dependency on input values, so that code is only executed once (on page load) to generate the initial view of the scatterplot. The logic behind adding and removing the fitted line is handled through an `observe()` block -- this reactive expression watches the `input$smooth` input value and modifies the `output$scatterplot` widget whenever it changes. To trigger a modification of a **plotly** output widget, you must create a proxy object with `plotlyProxy()` that references the relevant output ID. Once a proxy object is created, you can invoke any sequence of [plotly.js function(s)](https://plot.ly/javascript/plotlyjs-function-reference/#plotlymaketemplate) on it with `plotlyProxyInvoke()`. Invoking a method with the correct arguments can be tricky and requires knowledge of plotly.js because `plotlyProxyInvoke()` will send these arguments directly to the plotly.js method and therefore doesn't support the same 'high-level' semantics that `plot_ly()` does.


```r
server <- function(input, output, session) {
  
  output$scatterplot <- renderPlotly({
    plot_ly(d, x = ~x, y = ~y) %>%
      add_markers(color = I("black"), alpha = 0.05) %>%
      toWebGL()
  })
  
  observe({
    
    if (input$smooth) {
      
      # this is essentially the plotly.js way of doing
      # `p %>% add_lines(x = ~x, y = ~yhat) %>% toWebGL()`
      # without having to redraw the entire plot
      plotlyProxy("scatterplot", session) %>%
        plotlyProxyInvoke(
          "addTraces", 
          list(
            x = dpred$x,
            y = dpred$yhat,
            type = "scattergl",
            mode = "lines",
            line = list(color = "red")
          )
        )
    } else {
    
      # JavaScript index starts at 0, so the '1' here really means
      # "delete the second traces (i.e., the fitted line)"
      plotlyProxy("scatterplot", session) %>%
        plotlyProxyInvoke("deleteTraces", 1)
    }
    
  })
  
}
```

```{r shiny-scatterplot-performant, echo=FALSE, fig.cap="A more responsive version of Figure \\@ref(fig:shiny-scatterplot)."}
knitr::include_graphics("https://i.imgur.com/vQ7183k.gif")
```

Figure \@ref(fig:shiny-scatterplot) demonstrates a common use case where partial updates can be helpful, but there are other not-so-obvious cases. The next section covers a range of examples where you'll see how to leverage partial updates to implement smooth 'streaming' visuals, avoid resetting axis ranges, avoid flickering basemap layers, and more.

### Partial update examples

The last section explains why you may want to leverage partial **plotly** updates in **shiny** to get more responsive updates through an example. That example leveraged the [plotly.js functions](https://plot.ly/javascript/plotlyjs-function-reference/) `Plotly.addTraces()` and `Plotly.deleteTraces()` to add/remove a layer to a plot after it's initial draw. There are numerous other plotly.js functions that can be handy for a variety of use cases, some of the most widely used ones are: `Plotly.restyle()` for updating data visuals (section \@ref(restyle)), `Plotly.relayout()` for updating the layout (section \@ref(relayout)), and `Plotly.extendTraces()` for streaming data (section \@ref(streaming)).

#### Updating data visuals {#restyle}

All **plotly** figures have two main components: traces (i.e., mapping from data to visuals) and layout. The plotly.js function `Plotly.restyle()` is for modifying any existing traces. In addition to being a performant way to modify existing data and/or visual properties, it also has the added benefit of not affecting the current layout of the graph. Notice how, in Figure \@ref(fig:shiny-partial-restyle) for example, when the size of the marker/path changes, it doesn't change the camera's view of the 3D plot that the user altered after initial draw. If these input widgets triggered a full redraw of the plot, the camera would be reset to it's initial state.

```r
library(shiny)
library(plotly)

ui <- fluidPage(
  sliderInput("marker", "Marker size", min = 0, max = 20, value = 8),
  sliderInput("path", "Path size", min = 0, max = 30, value = 2),
  plotlyOutput("p")
)

server <- function(input, output, session) {
  
  output$p <- renderPlotly({
    plot_ly(
      economics, x = ~pce, y = ~psavert, z = ~unemploy, 
      color = ~as.numeric(date), mode = "markers+lines"
    )
  })
  
  observeEvent(input$marker, {
    plotlyProxy("p", session) %>%
      plotlyProxyInvoke(
        "restyle", 
        # could also do list(marker = list(size = input$marker))
        # but that overwrites the existing marker definition
        # https://github.com/plotly/plotly.js/issues/1866#issuecomment-314115744
        list(marker.size = input$marker)
      )
  })
  
  observeEvent(input$path, {
    plotlyProxy("p", session) %>%
      plotlyProxyInvoke(
        "restyle", list(line.width = input$path)
      )
  })
  
}

shinyApp(ui, server)
```

```{r shiny-partial-restyle, echo = FALSE, fig.cap="Using `Plotly.restyle()` to change just the width of a path and markers along that path in response to changes to **shiny** input sliders."}
knitr::include_graphics("https://i.imgur.com/DeL0eHC.gif")
```

One un-intuitive thing about `Plotly.restyle()` is that it fully replaces object (i.e., attributes that contain attributes) definitions like `marker` by default. To modify just a particular attribute of an object, like the size of a marker, you must replace that attribute directly (hence `marker.size`). As mentioned in the [official documentation](https://plot.ly/javascript/plotlyjs-function-reference/#plotlyrestyle), by default, modifications are applied to all traces, but specific traces can be targeted through their trace index (which starts at 0, because JavaScript!)


#### Updating the layout {#relayout}

All **plotly** figures have two main components: traces (i.e., mapping from data to visuals) and layout. The plotly.js function `Plotly.relayout()` is for modifying the layout.

```r
library(shiny)
library(plotly)

ui <- fluidPage(
  plotlyOutput("plot")
)

server <- function(input, output, session) {
  
  p <- ggplot(txhousing) +
    geom_line(aes(date, median, group = city))
  
  output$plot <- renderPlotly({
    ggplotly(p, dynamicTicks = TRUE) %>% 
      rangeslider() 
  })
  
  observeEvent(event_data("plotly_relayout"), {
    d <- event_data("plotly_relayout")
    xmin <- if (length(d[["xaxis.range[0]"]])) d[["xaxis.range[0]"]] else d[["xaxis.range"]][1]
    xmax <- if (length(d[["xaxis.range[1]"]])) d[["xaxis.range[1]"]] else d[["xaxis.range"]][2]
    if (is.null(xmin) || is.null(xmax)) return(NULL)
    
    # compute the y-range based on the new x-range
    idx <- with(txhousing, xmin <= date & date <= xmax)
    yrng <- extendrange(txhousing$median[idx])
    
    plotlyProxy("plot", session) %>%
      plotlyProxyInvoke("relayout", list(yaxis = list(range = yrng)))
  })
  
  yRange <- range(txhousing$median, na.rm = TRUE)
  observeEvent(event_data("plotly_doubleclick"), {
    
    plotlyProxy("plot", session) %>%
      plotlyProxyInvoke("relayout", list(yaxis = list(range = yRange)))
    
  })
  
  
}

shinyApp(ui, server)
```

#### Streaming {#streaming}


```r
library(shiny)
library(plotly)

ui <- fluidPage(
  actionButton("stream", "Turn stream on/off"),
  plotlyOutput("plot")
)

server <- function(input, output, session) {
  
  # initial values
  yint <- c(0, 1)
  
  # initiate graph with initial values
  output$plot <- renderPlotly({
    plot_ly(y = yint, x = seq_along(yint)) %>%
      add_lines()
  })
  
  # reactiveValues() act very much like input values, but may be used to 
  # maintain state (e.g., are we currently streaming?)
  rv <- reactiveValues(
    stream = FALSE,
    yend = sum(yint), 
    n = length(yint)
  )
  
  # turn streaming on/off when the button is pressed
  observeEvent(input$stream, {
    rv$stream <- if (rv$stream) FALSE else TRUE
  })
  
  observe({
    # if we're not streaming, don't do anything
    if (!rv$stream) return()
    
    # re-execute this code block to every 100 milliseconds
    invalidateLater(100, session)
    # changing a reactive value "invalidates" it, so isolate() is needed 
    # to avoid recursion
    isolate({
      rv$n <- rv$n + 1
      rv$yend <- rv$yend + sample(c(-1, 1), 1)
    })
    
    # add the new value to the plot
    plotlyProxy("plot", session) %>%
      plotlyProxyInvoke(
        "extendTraces", 
        list(
          y = list(list(rv$yend)), 
          x = list(list(rv$n))
        ), 
        list(0)
      )
  })
  
}

shinyApp(ui, server)
```

### Other considerations

Typically the 


* Careful what you send over the wire!
* Tradeoffs between shiny caching and partial updates?

