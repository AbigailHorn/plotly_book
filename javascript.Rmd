# Extending plotly with JavaScript {#javascript}

The same plotly.js events that we accessed in **shiny** through `event_data()` in section \@ref(shiny-plotly-inputs) can also be leveraged purely client-side with some custom JavaScript (JS). That means, by knowing a little bit about JS and the plotly.js library, we can extend graphs created with the R package to have custom behavior without requiring a client-server application. This portion of the book focuses on writing custom responses to commonly used plotly.js events, but a lot of the same tools and techniques could be used to extend these graphs in other ways as well.

To add a custom JS event handler to a **plotly** graph, you can leverage the `onRender()` function from the **htmlwidgets** package. This R function accepts a JS function as a string and calls that function when the widget is done rendering in the browser. The JS function needs (at least) one argument, `el`, which is the Document Object Model (DOM) element containing the **plotly** graph. Figure \@ref(fig:console-log) shows how you could use `onRender()` to log (and inspect) the DOM element to your browser's JS console. You can open the console of any browser (including RStudio!) with right-click -> "Inspect Element" -> "Console" tab (or similar). To demonstrate some useful DOM element's properties, Figure \@ref(fig:console-log) uses Firefox to inspect the element as a global variable, but as Figure \@ref(fig:console-log-event) shows, Chrome currently offers better tools for code debugging the JS function provided to `onRender()`  (e.g., setting breakpoints in virtual memory).

```r
library(htmlwidgets)
plot_ly(z = ~volcano) %>%
  onRender("function(el) { console.log(el); }")
```

```{r console-log, echo = FALSE, fig.cap="Using `htmlwidgets::onRender()` to inspect the relevant DOM instance containing the **plotly** graph and information related to it's current display. The `_fullData` and `_fullLayout` attributes bound to the element are 'internal' (meaning relying on this information in production code is discouraged), but do provide a useful description of the chart's current state, especially if you need access to computations done by plotly.js (e.g., axis tick placement)."}
include_vimeo("307598574", height = "700")
```

If you're completely new to JavaScript and JSON, section \@ref(json) provides a foundation for understanding the subsequent sections, but those already familiar can skip ahead to section \@ref(js-event-handlers).


## Working with JSON {#json}

JavaScript and other web technologies are intimidating and time-consuming to learn, but by borrowing some knowledge of R's data structures^[If you'd like a nice succinct overview on the topic, see http://adv-r.had.co.nz/Data-structures.html], we can get up and running with useful examples fairly quickly. JavaScript Object Notation (JSON) is a popular data-interchange format that JavaScript uses to work with data. As turns out, working with JSON in JS is somewhat similar to working with `list()`s in R -- both are recursive and heterogenous data structures that have similar semantics for accessing values. In JSON, there are three basic building blocks: objects, arrays, and primitive data types (e.g., number, string, boolean, `null`, `undefined`). 

Loosely speaking, a JSON array is similar to a un-named `list()` in R and a JSON object is similar to an un-named `list()`. In fact, if you're already comfortable creating and subsetting named and un-named `list()`s in R, you can transfer some of that knowledge to JSON arrays and objects. 

### Assignment, subsetting, and iteration

In R, the `<-` operator assigns a value to a name, and the `[[` operator extracts a list element by index:

```r
arr <- list("hello", "world", 10)
arr[[1]]
#> "hello"
```

In JS, the `=` assigns a value to a name. When assigning a new name, you should include the `var` keyword (or similar) to avoid creation of a global variable. The `[` operator extracts list elements by index, but **be careful, indexing in JS starts at 0 (not 1)!**

```js
var arr = ["hello", "world", 10];
arr[0]
// "hello"
```

In R, the `$` and `[[` operator can be used to extract list elements by name. The difference is that `$` does partial matching of names, while `[[` requires the exact name.

```r
obj <- list(x = c("hello", "world"), zoo = 10)
obj$z
#> 10
obj[["zoo"]]
#> 10
```

In JS, the `.` and `[` operator can be used to extract list elements by name. In either case, the naming must be exact.

```js
var obj = {
  x: ["hello", "world"],
  zoo: 10
}
obj.zoo
// 10
obj['zoo']
// 10
```

Unlike R `list()`s, arrays and objects in JS come with properties and methods that can be accessed via the `.` operator. Arrays, in particular, have a `length` property and a `map()` method for applying a function to each array element:

```js
arr.length
// 3
arr.map(function(item) { return item + 1; });
// ["hello1", "world1", 11]
```

In R, both the `lapply()` and `purrr::map()` family of functions provide a similar functional interface. Also, note that operators like `+` in JS do even more type coercion than R, so although `item + 1` works for strings in JS, it would throw an error in R (an that's ok, most times you probably don't want to add a string to a number)! If instead, you wanted to only add 1 to numeric values, you could use `is.numeric()` in R within an if else statement.

```r
purrr::map(arr, function(item) if (is.numeric(item)) item + 1 else item)
#> [[1]]
#> [1] "hello"
#> 
#> [[2]]
#> [1] "world"
#> 
#> [[3]]
#> [1] 11
```

In JS, you can use the `typeof` keyword to get the data type as well as the conditional ternary operator (`condition ? exprT : exprF`) to acheive the same task.

```js
arr.map(function(item) { return typeof item == "number" ? item + 1 : item; });
// ["hello", "world", 11]
```

There are a handful of other useful [array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array) and [object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) methods, but to keep things focused, we'll only cover what's required to comprehend section \@ref(js-event-handlers). A couple examples in that section use the `filter()` method, which like `map()` applies a function to each array element, but expects a logical expression and returns only the elements that meet the condition.

```js
arr.filter(function(item) { return typeof item == "string"; });
// ["hello", "world"]
```


### Mapping R to JSON

In R, unlike JSON, there is no distinction between scalars and vectors of length 1. That means there is ambiguity as to what a vector of length 1 in R should map to in JSON. The **jsonlite** package defaults to an array of length 1, but this can be avoided by setting `auto_unbox = TRUE`. 

```r
jsonlite::toJSON("A string in R")
#> ["A string in R"]
jsonlite::toJSON("A string in R", auto_unbox = TRUE)
#> "A string in R"
```

It's worth noting that plotly.js, which consumes JSON objects, has specific expectations and rules about scalars versus arrays of length 1. If you're calling the plotly.js library directly in JS, as we'll see later in section \@ref(js-event-handlers), you'll need to be mindful of the difference between scalars and arrays of length 1. Some attributes, like `text` and `marker.size`, accept both scalars and arrays and apply different rules based on the difference. Some other attributes, like `x`, `y`, and `z` only accept arrays and will error out if given a scalar. To learn about these rules and expectations, you can use the `schema()` function from R to inspect plotly.js' specification as shown in Figure \@ref(fig:json-schema). Note that attributes with a `val_type` of `'data_array'` require an array while attributes with an `arrayOk: true` field accept either scalars or arrays.

```r
schema()
```

```{r json-schema, echo = FALSE, fig.cap = "Using the plotly `schema()` to obtain more information about expected attribute types."}
include_vimeo("307597826")
```

In JSON, unlike R, there is no distinction between a heterogeneous and homogeneous collection of data types. In other words, in R, there is an important difference between `list(1, 2, 3)` and `c(1, 2, 3)` (the latter is an atomic vector and has a different set of rules). In JSON, there is no strict notion of a homogenous collection, so working with JSON arrays is essentially like being forced to use `list()` in R. This subtle fact can lead to some suprising results when trying to serialize R vectors as JSON arrays. For instance, if you wanted to create a JSON array, say `[1,"a",true]` using R objects, you may be tempted to do the following:

```r
jsonlite::toJSON(c(1, "a", TRUE))
#> ["1","a","TRUE"] 
```

But this actually creates an array of strings instead of the array with a number, string, and boolean that we desire. The problems actually lies in the fact that `c()` coerces the collection of values into an atomic vector. Instead, you should use `list()` over `c()`:

```r
jsonlite::toJSON(list(1, "a", TRUE), auto_unbox = TRUE)
#> [1,"a",true]
```



## Adding custom event handlers {#js-event-handlers}

When using `onRender()` to provide a JS function to be called upon static render of a **plotly** object, the relevant DOM element (`el`) has an `on()` method that accepts a function to be called whenever a plotly.js (or DOM) event occurs on that DOM element. Currently all plotly.js event handlers accept a function with a single argument, and that argument either contains nothing (e.g. `"plotly_afterplot"`, etc) or a single object with all the relevant information about the event (e.g. `"plotly_hover"`, `"plotly_selected"`, etc). Figure \@ref(fig:console-log-event) logs and inspects data (`d`) emitted during the `"plotly_hover"`, `"plotly_click"`, and `"plotly_selected"` events. The object emitted for these events includes a key, named `points`, with information tying the selection back to the input data. The `points` key is always an array of object(s) where each object represents a different data point. This object contains any supplied `customdata`, the relevant `x`/`y` location, and a reference back to the input `data`.

```r
library(htmlwidgets)
plot_ly(mtcars, x = ~wt, y = ~mpg) %>%
  onRender("
    function(el) { 
      el.on('plotly_hover', function(d) { console.log('Hover: ', d) });
      el.on('plotly_click', function(d) { console.log('Click: ', d) });
      el.on('plotly_selected', function(d) { console.log('Select: ', d) });
    }
  ")
```

```{r console-log-event, echo = FALSE, fig.cap="Inspecting event data for hover, click, and selected events. If a click or hover event does not derive from a statistical aggregation (e.g., boxplot, histogram, etc), the `points` array is of length 1; otherwise, the length corresponds to how many input values are represented in the selection. In Chrome, when you log an object to the console, you can click on a link to the JS source function where you can then set breakpoints."}
include_vimeo("307597974", height = "700")
```

## Supplying custom data

As covered in section \@ref(shiny-plotly-inputs), it's often useful to supply meta-information (i.e. custom data) to graphical marker(s) and use that information when responding to a event. For example, suppose we'd like each point in a scatterplot to act like a hyperlink to a different webpage. In order to do so, we can supply a url to each point (as metadata) and instruct the browser to open the relevant hyperlink on a click event. Figure \@ref(fig:click-open) does exactly this by supplying urls to each point in R through the `customdata` attribute and defining a custom JS event to `window.open()` the relevant `url` upon a click event. In this case, since each point represents one row of data, the `d.point` is an array of length 1, so we may obtain the `url` of the clicked point with `d.points[0].customdata`.

```r
library(htmlwidgets)

p <- plot_ly(mtcars, x = ~wt, y = ~mpg) %>%
  add_markers(
    text = rownames(mtcars),
    customdata = paste0("http://google.com/#q=", rownames(mtcars))
  )
  
onRender(
  p, "
  function(el) {
    el.on('plotly_click', function(d) {
      var url = d.points[0].customdata;
      window.open(url);
    });
  }
")
```

```{r click-open, echo = FALSE, fig.cap="Attaching hyperlinks to each point in a scatterplot and using a custom JS event to open that Google search query upon clicking a point."}
include_vimeo("307598425")
```

In addition to using `window.open()` to open the `url`, we could also add it to the plot as an annotation using the plotly.js function `Plotly.relayout()`, as done in Figure \@ref(fig:click-annotate). Moreover, since plotly annotations support HTML markup, we can also treat that url as a true HTML hyperlink by wrapping it in an HTML `<a>` tag. In cases where your JS function starts to get complex, it can help to put that JS function in its own file, then use the R function `readLines()` to read it in as a string and pass along `onRender()` as done below:

```r
onRender(p, readLines("js/hover-hyperlink.js"))
```

```{js, eval = FALSE, summary = "Click to show the 'js/hover-hyperlink.js' file"}
function(el) {
  el.on('plotly_hover', function(d) {
    var url = d.points[0].customdata;
    var ann = {
      text: "<a href='" + url + "'>" + url + "</a>",
      x: 0,
      y: 0,
      xref: "paper",
      yref: "paper",
      yshift: -40,
      showarrow: false
    };
    Plotly.relayout(el.id, {annotations: [ann]});
 });
}
```


```{r click-annotate, echo = FALSE, fig.cap="Using `Plotly.relayout()` to add and change hyperlink in response to hover events."}
include_vimeo("307598266")
```

```{block, type='rmdtip'}
When using `Plotly.relayout()`, or any other plotly.js function to modify a plot, you'll need to know the id attribute of the relevant DOM instance that you want to manipulate. When working with a single object, you can simply use `el.id` to access the id attribute of that DOM instance. However, when trying to target another object, it gets trickier because id attributes are randomly generated by **htmlwidgets**.  In that case, you likely want to pre-specify the id attribute so you can reference it client-side. You can pre-specify the id for any **htmlwidgets** object, say `widget`, by doing `widget$elementId <- "myID"`.
```

On the JS side, the `customdata` attribute is designed to support _any_ JS array of appropriate length, so if you need to supply numerous custom values to particular marker(s), list-columns in R provides a nice way to do so. Figure \@ref(fig:tx-annotate) leverages this idea to  bind both the `city` and `sales` values to each point along a time series and display those values on hover. It also demonstrates how one can use the graphical querying framework from section \@ref(graphical-queries) in tandem with a custom JS event. That is, `highlight_key()` and `highlight()` control the highlighting of the time series, while the custom JS event adds the plot annotation (all based on the same `"plotly_hover"` event). In this case, the highlighting, annotations, and circle shapes are triggered by a `"plotly_hover"` event and they all work in tandem because event handlers are cumulative. That means, if you wanted, you could register multiple custom handlers for a particular event.

```r
library(purrr)

sales_hover <- txhousing %>%
  group_by(city) %>%
  highlight_key(~city) %>%
  plot_ly(x = ~date, y = ~median, hoverinfo = "name") %>%
  add_lines(customdata = ~map2(city, sales, ~list(.x, .y))) %>%
  highlight("plotly_hover")

onRender(sales_hover, readLines("js/tx-annotate.js"))
```

```{js, eval = FALSE, summary = "Click to show the 'js/tx-annotate.js' file"}
function(el) {
  el.on("plotly_hover", function(d) {
    var pt = d.points[0];
    var cd = pt.customdata;
    var num = cd[1] ? cd[1] : "No";
    var ann = {
      text: num + " homes were sold in " + cd[0] + ", TX in this month",
      x: 0.5,
      y: 1,
      xref: "paper",
      yref: "paper",
      xanchor: "middle",
      showarrow: false
    };
    var circle = {
      type: "circle",
      xanchor: pt.x,
      yanchor: pt.y,
      x0: -6,
      x1: 6,
      y0: -6,
      y1: 6,
      xsizemode: "pixel",
      ysizemode: "pixel"
    };
    Plotly.relayout(el.id, {annotations: [ann], shapes: [circle]});
  });
}
```

```{r tx-annotate, echo = FALSE, fig.cap ="Combining the graphical querying framework from \\@ref(graphical-queries) with the ability to define custom JS event handlers. This example also leverages the fact that `customdata` supports list-columns to effectively bind both the city name and number of houses sold on a particular day."}
include_vimeo("307597956")
```

Sometimes supplying and accessing `customdata` alone is not quite enough for the task at hand. For instance, what if we wish to add the average monthly sales to the annotation for the city of interest in Figure \@ref(fig:tx-annotate)? In cases like this, we may need to use `customdata` to query a portion of the plot's input data, like Figure \@ref(fig:tx-annotate) does to compute and display average sales for a given city. This implementation leverages the fact that each selected point (`pt`) contains a reference to the entire trace it derives from (`pt.data`). As discussion behind Figure \@ref(fig:houston) noted, this particular plot has a *single trace* and uses missing values to create separate lines for each city. As a result, `pt.data.customdata` contains all the `customdata` we supplied from the R side, so to get all the `sales` for a given city, we first need to filter that array down to only the elements that are belong to that city (while being careful of missing values!).

```r
onRender(sales_hover, readLines("js/tx-mean-sales.js"))
```

```{js, eval = FALSE, summary = "Click to show the 'js/tx-mean-sales.js' file"}
function(el) {
  el.on("plotly_hover", function(d) {
    var pt = d.points[0];
    var city = pt.customdata[0];

    // filter the full custom data array down to just the elements
    // from the city of interest
    var cityInfo = pt.data.customdata.filter(function(cd) {
      return cd ? cd[0] == city : false;
    });
    
    // from the filtered data, get just the sales
    var sales = cityInfo.map(function(cd) { return cd[1] });

    // plotly.js bundles d3 which you can access via Plotly.d3
    var avgsales = Math.round(Plotly.d3.mean(sales));

    // Display the mean sales for the clicked city
    var ann = {
      text: "Mean monthly sales for " + city + " is " + avgsales,
      x: 0.5,
      y: 1,
      xref: "paper",
      yref: "paper",
      xanchor: "middle",
      showarrow: false
    };
    Plotly.relayout(el.id, {annotations: [ann]});
  });
}
```


```{r tx-mean-sales, echo = FALSE, fig.cap ="Displaying the average monthly sales for a city of interest on hover. This implementation supplies all the raw sales figures, then uses the hovered `customdata` value to query sales for the given city and display the average."}
include_vimeo("307598016")
```

Figure \@ref(fig:tx-inset-plot) uses the same `customdata` supplied to Figure \@ref(fig:tx-mean-sales) in order to display a histogram of monthly sales for the relevant city on hover. In addition, it displays a vertical line on the histogram to reflect the monthly sales for the point closest to the mouse cursor. To do all this efficiently, it's best to add the histogram trace on the first hover event using `Plotly.addTraces()`, then supply different `sales` data via `Plotly.restyle()` (generally speaking, `restyle()` is way less expensive than `addTraces()`). That's why the implementation leverages the fact that the DOM element (`el`) contains a reference to the current graph data (`el.data`). If the current graph has a trace with type of histogram, then it adds a histogram trace; otherwise, it supplies new `x` values to the histogram.

```r
sales_hover %>%
  onRender(readLines("js/tx-annotate.js")) %>%
  onRender(readLines("js/tx-inset-plot.js"))
```

```{js, eval = FALSE, summary = "Click to show the 'js/tx-inset-plot.js' file"}
function(el) {
  el.on("plotly_hover", function(d) {
    var pt = d.points[0];
    var city = pt.customdata[0];

    // get the sales for the clicked city
    var cityInfo = pt.data.customdata.filter(function(cd) {
      return cd ? cd[0] == city : false;
    });
    var sales = cityInfo.map(function(cd) { return cd[1] });

    // Collect all the trace types in this plot
    var types = el.data.map(function(trace) { return trace.type; });
    // Find the array index of the histogram trace
    var hasHistogram = types.includes("histogram");

    // If the histogram trace already exists, just supply new x values
    if (hasHistogram) {

      Plotly.restyle(el.id, "x", [sales], types.indexOf("histogram"));

    } else {

      // create the histogram
      var trace = {
        x: sales,
        type: "histogram",
        marker: {color: "#1f77b4"},
        xaxis: "x2",
        yaxis: "y2"
      };
      Plotly.addTraces(el.id, trace);

      // place it on "inset" axes
      var x = {
        domain: [0.05, 0.4],
        anchor: "y2"
      };
      var y = {
        domain: [0.6, 0.9],
        anchor: "x2"
      };
      Plotly.relayout(el.id, {xaxis2: x, yaxis2: y});

    }

    // Add a title for the histogram
    var ann = {
      text: "Monthly house sales in " + city + ", TX",
      x: 2003,
      y: 300000,
      xanchor: "middle",
      showarrow: false
    };
    Plotly.relayout(el.id, {annotations: [ann]});

    // Add a vertical line reflecting sales for the hovered point
    var line = {
      type: "line",
      x0: pt.customdata[1],
      x1: pt.customdata[1],
      y0: 0.6,
      y1: 0.9,
      xref: "x2",
      yref: "paper",
      line: {color: "black"}
    };
    Plotly.relayout(el.id, {'shapes[1]': line});
  });
}
```


```{r tx-inset-plot, echo = FALSE, fig.cap ="Adding another event handler to Figure \\@ref(fig:tx-annotate) to draw an inset plot showing the distribution of monthly house sales."}
include_vimeo("307598624")
```

## Incorporating other client-side tools

Sometimes supplying `customdata` isn't the best way to acheive a particular interactive feature. In those cases, you likely want to leverage other R interfaces to client-side technologies. Recall from section \@ref(arranging-htmlwidgets) that **htmlwidgets** objects are a special case of **htmltools** tags. That means, you can always complement your widget(s) with arbitrary HTML content by adding additional tags. Figure \@ref(fig:correlation-client-side) leverages this idea to place an empty HTML `<div>` container below the correlation heatmap which is then populated with a **plotly** scatterplot upon clicking a cell. As it turns out, you *could* implement Figure \@ref(fig:correlation-client-side) by binding x/y data to each heatmap cell via `customdata`, but that would require the browser to store twice the amount of data as what's required here. Instead, this approach seralizes the input data (`mtcars`) into a JSON file via **jsonlite** so the webpage can read and parse the full dataset once and select just the two required columns when required (on click). There are a lot of ways to read JSON in JavaScript, but here we use the d3.js library's `d3.json()` since **plotly** already comes bundled with the library [@d3js]. Also, since the HTML file is reading the JSON from disk, most browsers won't render the HTML file directly (at least, by default, for security reasons). To get around that, we can start up a simple web server from R using **servr** to serve both the HTML and JSON in way that your browser will deem safe to run [@servr].

```r
library(plotly)
library(htmltools)

nms <- names(mtcars)

p <- plot_ly(d, colors = "RdBu") %>%
  add_heatmap(
    x = nms, 
    y = nms, 
    z = ~round(cor(mtcars), 3)
  ) %>%
  onRender("
    function(el) {
      Plotly.d3.json('mtcars.json', function(mtcars) {
        el.on('plotly_click', function(d) {
          var x = d.points[0].x;
          var y = d.points[0].y;
          var trace = {
            x: mtcars[x],
            y: mtcars[y],
            mode: 'markers'
          };
          Plotly.newPlot('filtered-plot', [trace]);
        });
      });
    }
")


# In a temporary directory, save the mtcars dataset as json and
# the html to an index.html file, then open via a web server
withr::with_path(tempdir(), {
  jsonlite::write_json(as.list(mtcars), "mtcars.json")
  html <- tagList(p, tags$div(id = 'filtered-plot'))
  save_html(html, "index.html")
  if (interactive()) servr::httd()
})
```

```{r correlation-client-side, echo = FALSE, fig.cap ="Clicking on a correlation matrix to populate a scatterplot."}
include_vimeo("307598118", height = "700")
```


<!--
TODO: perhaps find an example with V8 and/or sass?
-->
