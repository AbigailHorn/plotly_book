[
["index.html", "A plotly tutoRial Overview", " A plotly tutoRial Carson Sievert Overview This website explains and partially documents the R package plotly, a high-level interface to the open source JavaScript graphing library plotly.js (which powers plot.ly). The R package already has numerous examples and documentation on https://plot.ly/r and https://plot.ly/ggplot2, but this website provides more of a cohesive narrative to help explain fundamental concepts and recent developments. By reading from start to finish, readers new to R and plotly should be able to get up and running fairly quickly. That being said, advanced R and plotly users should still find the majority of this material useful and informative. I highly recommend copying/pasting examples into your R console, and modifying them as you read along, to aid the learning process. This work is licensed under the Creative Commons Attribution-NonCommercial-NoDerivs 3.0 United States License. "],
["installation.html", "Installation", " Installation If you have R installed, you can install the stable release of plotly by typing this in your R console: install.packages(&quot;plotly&quot;) Or you can install the development release via the devtools package: if (!require(&quot;devtools&quot;)) install.packages(&quot;devtools&quot;) devtools::install_github(&quot;ropensci/plotly&quot;) "],
["get-started.html", "Get started", " Get started To ensure plotly is installed correctly, try loading the package and creating this example by pasting the code inside your R console. library(plotly) plot_ly(z = ~volcano) plotly uses the htmlwidget framework, which allows plots to work seamlessly and consistently in various contexts (e.g., R Markdown documents, shiny apps, inside RStudio, or any other R command prompt) without an internet connection. IPython/Jupyter notebook users should wrap plots with the embed_notebook() function to embed them inline inside a notebook. "],
["plot-ly-for-collaboration.html", "plot.ly for collaboration", " plot.ly for collaboration plot.ly subscribers can use plotly_POST() function to publish plots onto plotly’s web platform. This platform makes it very easy to host/share your graphs, collaborate with others, and is free to use for public graphs (have a look at our pricing options if you need privacy or customer support). Once a plot is hosted on your account, others may copy/fork your graph to their account (given the right permissions) using a friendly user-interface. As long as you can view a plot hosted on http://plot.ly, you can obtain the data behind with plot via the get_figure() function. This makes it easy to access and modify plots created with any plotly.js interface (e.g., Python, MATLAB, Julia, Scala, etc) from your R console. Not only is this web-based user-interface to plotly.js useful for collaborating with others, but it is also useful for completing tasks that are cumbersome to do at the command-line. For instance, annotations can be added to any plot via a point-and-click interface: -->"],
["two-interfaces-one-central-object.html", "1 Two interfaces, one central object", " 1 Two interfaces, one central object There are two main ways to create a plotly object (i.e., visualization) in R. The plot_ly() function transforms data into a plotly object, while the ggplotly() function transforms a ggplot object into a plotly object (Wickham 2009); (Sievert et al. 2016). No matter which interface you use, printing a plotly object results in an interactive web-based visualization with tooltips, zooming, and panning. Furthermore, once you have a plotly object, any plotly function can be used to modify that plotly object. As a result, we can effectively modify or post-process ggplot2 plots to leverage features exclusive to plotly (see section XXX for some compelling examples showing the power of this idea). A good question to ask now would be: “Why the need for two interfaces”? The quick and easy answer is that ggplot2 can be quite slow; but has an elegant interface with many useful abstractions (e.g., a consistent interface for altering scales), smart defaults, very extensive set of features, and a huge community of users and developers. On the other hand, plot_ly() can be much faster, mostly because it does less magic. Furthermore, ggplot2 is focused on 2D graphics, whereas plotly.js has awesome 3D scientific visualization capabilities – the inspiration having plot_ly() in the first place. Even though ggplot2 does a lot of things right (which plot_ly() strives to adopt), one could argue it has a number of design flaws which will probably never be fixed (which plot_ly() strives to avoid). As shown explicitly in the next section, the design of the plot_ly() interface is heavily inspired by ggplot2, and it’s implementation of the Grammar of Graphics (Wilkinson 2005). In its layered approach to the grammar of graphics (Wickham 2010), it defines a layer as the combination of five elements: (1) data (2) aesthetic mapping (3) geometry (4) statistical summary (5) positional adjustment. The fact that these elements are easily understood in isolation, but can be combined in many ways to produce complex visualizations, is a huge reason for ggplot2’s success (not to mention its support for a bunch of different useful geometries and statistics). One could argue, however, that embedding data transformations (e.g., statistical summaries and positional adjustments) inside the plot building step was a mistake since other packages can’t leverage that functionality. We’re already seeing glimpses of Hadley’s vision for the future where statistical computations and data transformations are decoupled from the actual rendering stage (Chang and Wickham 2016); (Wickham 2016). One could also argue that ggplot2’s overriding of the + operator to combine components is another design flaw – layers should instead be described as a sequence of pure functions which perform data transformation(s) and mapping(s) to visuals. As always, the devil is in the detail, so I’ve provided a list at the end of this chapter that provides more details about the limitations behind each interface which may be helpful for Choosing an interface. For now, we’ll point out some obvious similarities and differences with a few examples. References "],
["a-case-study-of-housing-sales-in-texas.html", "1.1 A case study of housing sales in Texas", " 1.1 A case study of housing sales in Texas The plotly package depends on ggplot2 which bundles a data set on monthly housing sales in Texan cities acquired from the TAMU real estate center. library(plotly) txhousing ## # A tibble: 8,602 × 9 ## city year month sales volume median listings inventory date ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Abilene 2000 1 72 5380000 71400 701 6.3 2000.000 ## 2 Abilene 2000 2 98 6505000 58700 746 6.6 2000.083 ## 3 Abilene 2000 3 130 9285000 58100 784 6.8 2000.167 ## 4 Abilene 2000 4 98 9730000 68600 785 6.9 2000.250 ## 5 Abilene 2000 5 141 10590000 67300 794 6.8 2000.333 ## 6 Abilene 2000 6 156 13910000 66900 780 6.6 2000.417 ## 7 Abilene 2000 7 152 12635000 73500 742 6.2 2000.500 ## 8 Abilene 2000 8 131 10710000 75000 765 6.4 2000.583 ## 9 Abilene 2000 9 104 7615000 64500 771 6.5 2000.667 ## 10 Abilene 2000 10 101 7040000 59300 764 6.6 2000.750 ## # ... with 8,592 more rows In attempt to understand house price behavior over time, we could plot date on x, median on y, and group the lines connecting these x/y pairs by city. Using ggplot2, we can initiate a ggplot object with the ggplot() function which accepts a data frame and a mapping from data variables to visual aesthetics. By just initiating the object, ggplot2 won’t know how to geometrically represent the data until we add an appropriate geom_*() function (in this case, we want geom_line()). In this case, it is also a good idea to specify alpha transparency so that 5 lines plotted on top of each other appear as solid black, to help avoid overplotting. library(plotly) p &lt;- ggplot(txhousing, aes(date, median, group = city)) + geom_line(alpha = 0.2) Now that we have a valid ggplot2 object, p, the plotly package provides the ggplotly() function which converts a ggplot object to a plotly object. By default, it supplies the entire aesthetic mapping to the tooltip, but the tooltip argument provides a way to restrict tooltip info to a subset of that mapping. Furthermore, in cases where the statistic of a layer is something than the identity function (e.g., geom_bin2d() and geom_hex()), relevant “intermediate” variables generated in the process are also supplied to the tooltip. This provides a nice mechanism for decoding visual aesthetics (e.g., color) used to represent a measure of interest (e.g, count/value). In Figure ??, I use the subplot() function from the plotly package (discussed in more detail in subplots) which accepts a collection of either ggplot or plotly objects. subplot( p, ggplotly(p, tooltip = &quot;city&quot;), ggplot(txhousing, aes(date, median)) + geom_bin2d(), ggplot(txhousing, aes(date, median)) + geom_hex(), nrows = 2, shareX = TRUE, shareY = TRUE, titleY = FALSE, titleX = FALSE ) Although ggplot2 does not have a text aesthetic, the ggplotly() function recognizes this aesthetic and supplies it to the tooltip. In addition to providing a way to supply “meta” information, it also provides a way to supply custom tooltips (do this by restricting the tooltip to the text aesthetic – ggplotly(p, tooltip = “text”)) txhousing %&gt;% group_by(city) %&gt;% plot_ly(x = ~date, y = ~median) %&gt;% add_lines(alpha = 0.3) This plot doesn’t tell us much (other than prices seems to be increasing overall) since it’s hard to see what’s happening in individual cities. We could highlight a particular series by subsetting the data To compare the monthly median house price across cities If you use ggplot2, ggplotly() adds interactivity (specifically, tooltips, zoom, and pan) to your plots with minimal effort. 1.1.1 The plot_ly() interface The plot_ly() function draws inspiration from ggplot2’s implementation of the grammar of graphics, but provides a more flexible and direct interface to plotly.js. The interface is also functional, and designed to work with dplyr’s generic data manipulation functions, so visualizations can be described as a sequence of data manipulations and visual components via the pipe operator (%&gt;%) from the magrittr package. txhousing %&gt;% group_by(city) %&gt;% plot_ly(x = ~date, y = ~median) %&gt;% add_lines(color = I(&quot;black&quot;), alpha = 0.3) txhousing %&gt;% group_by(city) %&gt;% plot_ly(x = ~date, y = ~median) %&gt;% add_lines(alpha = 0.3, color = I(&quot;black&quot;), name = &quot;Texan Cities&quot;) %&gt;% filter(city == &quot;Houston&quot;) %&gt;% add_lines(color = I(&quot;red&quot;), name = &quot;Houston&quot;) 1.1.2 Adding layers The ggplotly() function translates ggplot2 graphics to a plotly equivalent, for example: library(plotly) p &lt;- qplot(data = txhousing, x = date, y = median, group = city, alpha = I(0.3), geom = &quot;line&quot;) p &lt;- p + geom_line(data = subset(txhousing, city == &quot;Houston&quot;), color = &quot;red&quot;) ggplotly(p) %&gt;% filter(city == &quot;Houston&quot;) %&gt;% add_lines(color = I(&quot;red&quot;), name = &quot;Houston&quot;) "],
["combining-the-two.html", "1.2 Combining the two", " 1.2 Combining the two p &lt;- ggplot(txhousing, aes(x = date, y = median)) + geom_line(aes(group = city), alpha = 0.3) + geom_smooth() ggplotly(p) %&gt;% filter(city == &quot;Houston&quot;) %&gt;% add_lines(color = I(&quot;red&quot;), name = &quot;Houston&quot;) Expose the pre-statistics data. "],
["choosing-an-interface-sec-choosing.html", "1.3 Choosing an interface {sec: choosing}", " 1.3 Choosing an interface {sec: choosing} library(plotly) d &lt;- subset(diamonds, carat &lt;= 2) p &lt;- ggplot(d, aes(log(carat), log(price))) + geom_hex() + geom_smooth(method = &quot;lm&quot;, colour = &quot;red&quot;, se = FALSE) ggplotly(p) That’s great, but there are a few reasons why this approach is limited: ggplot2’s interface wasn’t designed for interactive graphics. Directly extending the grammar to support more advanced types of interaction (e.g., linked brushing) is a risky endeavor. ggplot2 requires data frame(s) and can be inefficient (especially for time series). ggplot2 does not have a functional interface (making it awkward to combine with modern functional interfaces such as dplyr), and does not satisfy referential transparency (making it easier to program with – for more details, see ) ggplotly() tries to replicate exactly what you see in the corresponding static ggplot2 graph. To do so, it sends axis tick information to plotly as tickvals/ticktext properties, and consequently, axis ticks do not update on zoom events. -->"],
["an-intro-to-plot-ly.html", "2 An intro to plot_ly()", " 2 An intro to plot_ly() This vignette outlines the philosophy behind plot_ly() through a series of examples (click on the static images to see the interactive version). In a nutshell, plot_ly() aims to: Provide sensible defaults/messages/warnings based on the information supplied, but still allows for full customization through plotly.js’ (the open source JavaScript graphing library which powers plotly) figure reference. Leverage useful concepts from the grammar of graphics (without requiring it to be used). "],
["smart-defaults-messages-warnings-errors.html", "2.1 Smart defaults, messages, warnings, errors", " 2.1 Smart defaults, messages, warnings, errors If no visualization type is specified, plot_ly() infers a sensible type based on the information provided. In this case, a numeric matrix (named volcano) is mapped to the z attribute, so a heatmap is a sensible default. library(plotly) str(volcano) ## num [1:87, 1:61] 100 101 102 103 104 105 105 106 107 108 ... plot_ly(z = ~volcano) ## No trace type specified: ## Based on info supplied, a &#39;heatmap&#39; trace seems appropriate. ## Read more about this trace type -&gt; https://plot.ly/r/reference/#heatmap A heatmap is not the only way to visualize a numeric matrix. Since plot_ly() only initializes a plotly object, we can change the default visualization type using any of the add_*() functions: add_surface(plot_ly(z = ~volcano)) There are a number of add_*() functions, for a number "],
["functional-interface.html", "2.2 Functional interface", " 2.2 Functional interface Plotly’s R package has a functional interface: every function takes a plotly object as it’s first input argument and returns a modified plotly object. To make code more readable, plotly re-exports the pipe operator (%&gt;%) from the magrittr package. The pipe operator takes the object on the left-hand side and injects it into the first argument (by default) of the function on the right-hand side. This allows us to read code from left to right instead of inside out. # these two lines of code are equivalent, but the second is easier to read plotly_POST(add_surface(plot_ly(z = ~volcano))) plot_ly(z = ~volcano) %&gt;% add_surface() %&gt;% plotly_POST() plot_ly(diamonds, x = ~cut) plot_ly(diamonds, y = ~cut) To create a plotly visualization, start with plot_ly(). library(plotly) plot_ly(economics, x = ~date, y = ~unemploy / pop) A plotly visualization is composed of one (or more) trace(s), and every trace has a type (the default type is ‘scatter’). The arguments/properties that a trace will respect (documented here) depend on it’s type. A scatter trace respects mode, which can be any combination of “lines”, “markers”, “text” joined with a “+”: library(plotly) plot_ly(economics, x = ~date, y = ~unemploy / pop, type = &quot;scatter&quot;, mode = &quot;markers+lines&quot;) You can manually add a trace to an existing plot with add_trace(). In that case, you’ll want to either name your traces, or hide the legend by setting showlegend = FALSE m &lt;- loess(unemploy / pop ~ as.numeric(date), data = economics) p &lt;- plot_ly(economics, x = ~date, y = ~unemploy / pop, name = &quot;raw&quot;) add_lines(p, y = ~fitted(m), name = &quot;loess&quot;) plotly was designed with a pure, predictable, and pipeable interface in mind, so you can also use the %&gt;% operator to create a visualization pipeline: economics %&gt;% plot_ly(x = ~date, y = ~unemploy / pop) %&gt;% add_lines(y = ~fitted(m)) %&gt;% layout(showlegend = F) TODO: talk about dplyr verbs! library(dplyr) economics %&gt;% mutate(rate = unemploy / pop) %&gt;% plot_ly(x = ~date, y = ~rate) %&gt;% filter(rate == max(rate)) %&gt;% layout( showlegend = F, annotations = list(x = ~date, y = ~rate, text = &quot;Peak&quot;, showarrow = T) ) Although these functions output special “plotly data frames”, plot_ly() doesn’t require a data frame for input. This makes chart types that accept a z argument especially easy to use if you have a numeric matrix: s &lt;- plot_ly(z = volcano, type = &quot;surface&quot;) If you have a free plotly account, plotly_POST() makes it easy to host/share any plotly figure (click on the image below to see the interactive version). plotly_POST(s) https://plot.ly/~agvd/1794 "],
["special-arguments.html", "2.3 Special arguments", " 2.3 Special arguments The plotly function arguments used thus far are documented in the figure reference, but there are a handful of additional arguments not described in the reference that make common visualizations a bit easier. These arguments are very much inspired by the semantics of ggplot2’s qplot() in the sense that a scales are automatically applied these variables. 2.3.1 The color argument 2.3.1.1 Qualitative color mappings If a ordinal variable (aka a non-ordered factor variable) is assigned to color, then a qualitative color palette is used by default. plot_ly(iris, x = ~Petal.Length, y = ~Petal.Width, color = ~Species, mode = &quot;markers&quot;) If you want to change the default palette, it’s recommended that you provide a http://colorbrewer2.org qualitative pallette name (e.g., “Set1” or “Accent”) to the colors argument. plot_ly(iris, x = ~Petal.Length, y = ~Petal.Width, color = ~Species, colors = &quot;Set1&quot;, mode = &quot;markers&quot;) In this case, the palette consists of 9 colors and the default behavior is to pick colors that are furthest apart (“#E41A1C”, “#FF7F00”, and “#999999”). cols &lt;- RColorBrewer::brewer.pal(9, &quot;Set1&quot;) scales::show_col(cols) If you’d like more control over the mapping, you can provide a vector of colors (of appropriate length). cols &lt;- RColorBrewer::brewer.pal(nlevels(iris$Species), &quot;Set1&quot;) plot_ly(iris, x = ~Petal.Length, y = ~Petal.Width, color = ~Species, colors = cols, mode = &quot;markers&quot;) 2.3.1.2 Sequential color mappings If either a numeric or an ordered factor is mapped to color, plot_ly() applies a sequential color scale by default. plot_ly(iris, x = ~Petal.Length, y = ~Petal.Width, color = ~as.ordered(Species), mode = &quot;markers&quot;) In the case of continuous numeric variables, plot_ly() performs a linear mapping between the data and an interpolated color pallette. plot_ly(iris, x = ~Petal.Length, y = ~Petal.Width, color = ~Sepal.Length, mode = &quot;markers&quot;) The colors argument takes arbitrary color codes of arbitrary length. Here is how we could use it to replicate the default mapping in ggplot2. plot_ly(iris, x = ~Petal.Length, y = ~Petal.Width, color = ~Sepal.Length, colors = c(&quot;#132B43&quot;, &quot;#56B1F7&quot;), mode = &quot;markers&quot;) 2.3.1.3 Diverging color mappings To obtain a diverging color mapping, just provide a diverging palette to the colors argument. plot_ly(iris, x = ~Petal.Length, y = ~Petal.Width, color = ~Sepal.Length, colors = &quot;PuOr&quot;, mode = &quot;markers&quot;) 2.3.2 The symbol argument To encode values using symbols, use the symbol argument. plot_ly(iris, x = ~Petal.Length, y = ~Petal.Width, symbol = ~Species, mode = &quot;markers&quot;) To change the default symbols used, use the symbols argument. All the valid symbol types are listed here. plot_ly(iris, x = ~Petal.Length, y = ~Petal.Width, mode = &quot;markers&quot;, symbol = ~Species, symbols = c(&quot;cross&quot;, &quot;square&quot;, &quot;triangle-down&quot;)) -->"],
["subplot.html", "3 The subplot() function", " 3 The subplot() function The subplot() function provides a flexible interface for arranging multiple plotly plots in a single view. The simplest way to use it is to pass plotly visualizations directly to subplot(). library(plotly) p1 &lt;- plot_ly(economics, x = ~date, y = ~unemploy, name = &quot;unemploy&quot;) p2 &lt;- plot_ly(economics, x = ~date, y = ~uempmed, name = &quot;uempmed&quot;) subplot(p1, p2) Although subplot() accepts an arbitrary number of plot objects, passing a list of plots can save typing and redundant code when dealing with a large number of plots. To demonstrate, let’s create one time series for each variable in the economics dataset and share the x-axis so that zoom/pan events are synchronized across each series: vars &lt;- setdiff(names(economics), &quot;date&quot;) plots &lt;- lapply(vars, function(var) { plot_ly(x = economics$date, y = economics[[var]], name = var) }) subplot(plots, nrows = length(plots), shareX = TRUE, titleX = FALSE) Conceptually, subplot() provides a way to place a collection of plots into a table with a given number of rows and columns. The number of rows (and, by consequence, the number of columns) is specified via the nrows argument. By default each row/column shares an equal proportion of the overall height/width, but as shown in the diagram below, that default can be changed via the heights and widths arguments. This flexibility is quite useful for a number of visualizations, for example, a joint density plot (the new heatmaply package is another good example). x &lt;- rnorm(100) y &lt;- rnorm(100) m &lt;- list(color = &quot;black&quot;) s &lt;- subplot( plot_ly(x = x, type = &quot;histogram&quot;, marker = m), plotly_empty(), plot_ly(x = x, y = y, mode = &quot;markers&quot;, marker = m), plot_ly(y = y, type = &quot;histogram&quot;, marker = m), nrows = 2, heights = c(0.2, 0.8), widths = c(0.8, 0.2), shareX = TRUE, shareY = TRUE, titleX = FALSE, titleY = FALSE ) layout(s, showlegend = FALSE) Note that, since subplot() returns a plotly object, any layout attribute can be modified downstream via layout(). "],
["recursive-subplots.html", "3.1 Recursive subplots", " 3.1 Recursive subplots The subplot() function is designed to work recursively so that you can have subplots of subplots. This idea is useful when your desired layout doesn’t conform to the table structure described in the previous section. In fact, you can think of a subplot of subplots like a spreadsheet with merged cells. plotList &lt;- function(nplots) { # TODO: use new images infrastructure to overlay an R image on each plot lapply(seq_len(nplots), function(x) plot_ly()) } s1 &lt;- subplot(plotList(6), nrows = 2, shareX = TRUE, shareY = TRUE) s2 &lt;- subplot(plotList(2), shareY = TRUE) subplot(s1, s2, plot_ly(), nrows = 3, margin = 0.04, heights = c(0.6, 0.3, 0.1)) The concept is particularly useful when you want plot(s) in a given row to have different widths from plot(s) in another row. # specify some map projection/options g &lt;- list( scope = &#39;usa&#39;, projection = list(type = &#39;albers usa&#39;), lakecolor = toRGB(&#39;white&#39;) ) # create a map of population density density &lt;- state.x77[, &quot;Population&quot;] / state.x77[, &quot;Area&quot;] map &lt;- plot_ly( z = ~density, text = state.name, locations = state.abb, type = &#39;choropleth&#39;, locationmode = &#39;USA-states&#39;, geo = &quot;geo&quot; ) %&gt;% layout(geo = g) # create a bunch of horizontal bar charts vars &lt;- colnames(state.x77) barcharts &lt;- lapply(vars, function(var) { plot_ly(x = state.x77[, var], y = state.name, type = &quot;bar&quot;, orientation = &quot;h&quot;, name = var) %&gt;% layout(showlegend = FALSE, hovermode = &quot;y&quot;, yaxis = list(showticklabels = FALSE)) }) subplot( subplot(barcharts, margin = 0.01), map, nrows = 2, heights = c(0.3, 0.7) ) "],
["ggplot2-subplots.html", "3.2 ggplot2 subplots", " 3.2 ggplot2 subplots The subplot() function also understands ggplot2 objects, and converts them to an interactive web-based version via ggplotly() before arranging them in the final layout. e &lt;- tidyr::gather(economics, variable, value, -date) gg1 &lt;- ggplot(e, aes(date, value)) + geom_line() + facet_wrap(~variable, scales = &quot;free_y&quot;, ncol = 1) gg2 &lt;- ggplot(e, aes(factor(1), value)) + geom_violin() + facet_wrap(~variable, scales = &quot;free_y&quot;, ncol = 1) + theme(axis.text = element_blank(), axis.ticks = element_blank()) subplot(gg1, gg2) %&gt;% layout(margin = list(l = 50)) This infrastructure allows ggplotly() to understand ggmatrix objects – the class of object returned by the ggpairs() function in the GGally package. pm &lt;- GGally::ggpairs(iris) ggplotly(pm) "]
]
