[
["index.html", "plotly for R Overview", " plotly for R Carson Sievert Overview This website explains and partially documents the R package plotly, a high-level interface to the open source JavaScript graphing library plotly.js (which powers plot.ly). The R package already has numerous examples and documentation on https://plot.ly/r and https://plot.ly/ggplot2, but this website provides more of a cohesive narrative to help explain fundamental concepts and recent developments. By reading from start to finish, readers new to R and plotly should be able to get up and running fairly quickly. That being said, advanced R and plotly users should still find the majority of this material useful and informative. I highly recommend copying/pasting examples into your R console, and modifying them as you read along, to aid the learning process. This work is licensed under the Creative Commons Attribution-NonCommercial-NoDerivs 3.0 United States License. "],
["installation.html", "Installation", " Installation If you have R installed, you can install the stable release of plotly by typing this in your R console: install.packages(&quot;plotly&quot;) Or you can install the development release via the devtools package: if (!require(&quot;devtools&quot;)) install.packages(&quot;devtools&quot;) devtools::install_github(&quot;ropensci/plotly&quot;) The version of the R package used to build this site is: packageVersion(&quot;plotly&quot;) #&gt; [1] &#39;4.5.5.9000&#39; "],
["get-started.html", "Get started", " Get started To ensure plotly is installed correctly, try loading the package and creating this example by pasting the code inside your R console. library(plotly) plot_ly(z = ~volcano) plotly uses the htmlwidget framework, which allows plots to work seamlessly and consistently in various contexts (e.g., R Markdown documents, shiny apps, inside RStudio, or any other R command prompt) without an internet connection. IPython/Jupyter notebook users should wrap plots with the embed_notebook() function to embed them inline inside a notebook. "],
["plot-ly-for-collaboration.html", "plot.ly for collaboration", " plot.ly for collaboration plot.ly subscribers can use the plotly_POST() function to publish plots from R onto plotly’s web platform. This platform makes it very easy to host/share your graphs, collaborate with others, and is free to use for public graphs.1 Once a plot is hosted on your account, others may copy/fork your graph to their account (with the right permissions) using a friendly user-interface. Here is a quick demonstration of that workflow from inside RStudio: As long as you can view a plot hosted on http://plot.ly, you can bring the data behind with plot into R via the get_figure() function. This makes it easy to access and modify plots created with any plotly.js interface (e.g., Python, MATLAB, Julia, Scala, etc) from your R console. Not only is this web-based user-interface to plotly.js useful for collaborating with others, but it is also useful for completing tasks that are cumbersome to do at the command-line. For instance, annotations can be added to any plot via a point-and-click interface: --> If you need privacy or customer support, pricing options↩ "],
["two-approaches-one-object.html", "1 Two approaches, one object", " 1 Two approaches, one object There are two main ways to initiate a plotly object in R. The plot_ly() function transforms data into a plotly object, while the ggplotly() function transforms a ggplot object into a plotly object (Wickham 2009); (Sievert et al. 2016). Regardless how plotly object is created, printing it results in an interactive web-based visualization with tooltips, zooming, and panning enabled by default. It is also possible to enable more advanced interactive techniques, such as animation and linked highlighting. This chapter discusses some of the philosophy behind each approach, explores some of their similarities, and explains why understanding both approaches is extremely powerful. The initial inspiration for the plot_ly() function was to support plotly.js chart types that ggplot2 doesn’t support, such as 3D surface and mesh plots. Over time, this effort snowballed into an interface to the entire plotly.js graphing library with additional abstractions inspired by the grammar of graphics (Wilkinson 2005). This newer “non-ggplot2” interface to plotly.js is currently not, and may never be, as fully featured as ggplot2. Since we can already translate a fairly large amount of ggplot objects to plotly objects, I’d rather not reinvent those same abstractions, and focus providing useful tools for advanced interactive graphics. The next section uses a case study to introduce some of the similarities between ggplotly() and plot_ly(), dives into the cognitive framework behind plot_ly(), and also demonstrates how to extend ggplotly() with functions that can modify plotly objects. "],
["a-case-study-of-housing-sales-in-texas.html", "1.1 A case study of housing sales in Texas", " 1.1 A case study of housing sales in Texas The plotly package depends on ggplot2 which bundles a data set on monthly housing sales in Texan cities acquired from the TAMU real estate center. After the loading the package, the data is “lazily loaded” into your session, so you may reference it by name: library(plotly) txhousing #&gt; # A tibble: 8,602 × 9 #&gt; city year month sales volume median listings inventory date #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Abilene 2000 1 72 5380000 71400 701 6.3 2000 #&gt; 2 Abilene 2000 2 98 6505000 58700 746 6.6 2000 #&gt; 3 Abilene 2000 3 130 9285000 58100 784 6.8 2000 #&gt; 4 Abilene 2000 4 98 9730000 68600 785 6.9 2000 #&gt; 5 Abilene 2000 5 141 10590000 67300 794 6.8 2000 #&gt; 6 Abilene 2000 6 156 13910000 66900 780 6.6 2000 #&gt; # ... with 8,596 more rows In attempt to understand house price behavior over time, we could plot date on x, median on y, and group the lines connecting these x/y pairs by city. Using ggplot2, we can initiate a ggplot object with the ggplot() function which accepts a data frame and a mapping from data variables to visual aesthetics. By just initiating the object, ggplot2 won’t know how to geometrically represent the mapping until we add a layer to the plot via one of geom_*() (or stat_*()) functions (in this case, we want geom_line()). In this case, it is also a good idea to specify alpha transparency so that 5 lines plotted on top of each other appear as solid black, to help avoid overplotting. If you’re new to ggplot2, the ggplot2 cheatsheet provides a nice quick overview. The online docs or R graphics cookbook are helpful for learning by example, and the ggplot2 book provides a nice overview of the conceptual underpinnings. p &lt;- ggplot(txhousing, aes(date, median)) + geom_line(aes(group = city), alpha = 0.2) 1.1.1 The ggplotly() function Now that we have a valid ggplot2 object, p, the plotly package provides the ggplotly() function which converts a ggplot object to a plotly object. By default, it supplies the entire aesthetic mapping to the tooltip, but the tooltip argument provides a way to restrict tooltip info to a subset of that mapping. Furthermore, in cases where the statistic of a layer is something other than the identity function (e.g., geom_bin2d() and geom_hex()), relevant “intermediate” variables generated in the process are also supplied to the tooltip. This provides a nice mechanism for decoding visual aesthetics (e.g., color) used to represent a measure of interest (e.g, count/value). In Figure 1.1, the subplot() function from the plotly package (discussed in more detail in subplots), which accepts a collection of ggplot and/or plotly objects, helps to concisely display tooltips for a number of scenarios, and how to suppress them. subplot( p, ggplotly(p, tooltip = &quot;city&quot;), ggplot(txhousing, aes(date, median)) + geom_bin2d(), ggplot(txhousing, aes(date, median)) + geom_hex(), nrows = 2, shareX = TRUE, shareY = TRUE, titleY = FALSE, titleX = FALSE ) Figure 1.1: Monthly median house price in the state of Texas. The top row displays the raw data (by city) and the bottom row shows 2D binning on the raw data. The binning is helpful for showing the overall trend, but hovering on the lines in the top row helps reveal more detailed information about each city. Although ggplot2 does not have a text aesthetic, the ggplotly() function recognizes this aesthetic and displays it in the tooltip by default. In addition to providing a way to supply “meta” information, it also provides a way to customize your tooltips (do this by restricting the tooltip to the text aesthetic – ggplotly(p, tooltip = “text”)) The ggplotly() function translates most things that you can do in ggplot2, but not quite everything. To help demonstrate the coverage, I’ve built a plotly version of the ggplot2 docs. This version of the docs displays the ggplotly() version of each plot in a static form (to reduce page loading time), but you can click any plot to view its interactive version. The next section deomnstrates how to create plotly.js visualizations via the R package, without ggplot2, via the plot_ly() interface. We’ll then leverage those concepts to extend ggplotly(). 1.1.2 The plot_ly() interface 1.1.2.1 The Layered Grammar of Graphics The cognitive framework underlying the plot_ly() interface draw inspiration from the layered grammar of graphics (Wickham 2010), but in contrast to ggplotly(), it provides a more flexible and direct interface to plotly.js. It is more direct in the sense that it doesn’t call ggplot2’s sometimes expensive plot building routines, and it is more flexible in the sense that data frames are not required, which is useful for visualizing matrices, as shown in Get Started. Although data frames are not required, it is recommended to use them whenever possible, especially when constructing a plot with multiple layers or groups. When a data frame is associated with a plotly object, it allows us to manipulate the data underlying that object in the same way we would directly manipulate the data. Currently, plot_ly() borrows semantics from and provides special plotly methods for generic functions in the dplyr and tidyr packages (Wickham and Francois 2016); (Wickham 2016). Most importantly, plot_ly() recognizes and preserves groupings created with dplyr’s group_by() function. library(dplyr) tx &lt;- group_by(txhousing, city) # initiate a plotly object with date on x and median on y p &lt;- plot_ly(tx, x = ~date, y = ~median) # plotly_data() returns data associated with a plotly object, note the group attribute! plotly_data(p) #&gt; Source: local data frame [8,602 x 9] #&gt; Groups: city [46] #&gt; #&gt; city year month sales volume median listings inventory date #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Abilene 2000 1 72 5380000 71400 701 6.3 2000 #&gt; 2 Abilene 2000 2 98 6505000 58700 746 6.6 2000 #&gt; 3 Abilene 2000 3 130 9285000 58100 784 6.8 2000 #&gt; 4 Abilene 2000 4 98 9730000 68600 785 6.9 2000 #&gt; 5 Abilene 2000 5 141 10590000 67300 794 6.8 2000 #&gt; 6 Abilene 2000 6 156 13910000 66900 780 6.6 2000 #&gt; # ... with 8,596 more rows Defining groups in this fashion ensures plot_ly() will produce at least one graphical mark per group.2 So far we’ve specified x/y attributes in the plotly object p, but we have not yet specified the geometric relation between these x/y pairs. Similar to geom_line() in ggplot2, the add_lines() function connects (a group of) x/y pairs with lines in the order of their x values, which is useful when plotting time series as shown in Figure 1.2. # add a line highlighting houston add_lines( # plots one line per city since p knows city is a grouping variable add_lines(p, alpha = 0.2, name = &quot;Texan Cities&quot;, hoverinfo = &quot;none&quot;), name = &quot;Houston&quot;, data = filter(txhousing, city == &quot;Houston&quot;) ) Figure 1.2: Monthly median house price in Houston in comparison to other Texan cities. The plotly package has a collection of add_*() functions, all of which inherit attributes defined in plot_ly(). These functions also inherit the data associated with the plotly object provided as input, unless otherwise specified with the data argument. I prefer to think about add_*() functions like a layer in ggplot2, which is slightly different, but related to a plotly.js trace. In Figure 1.2, there is a 1-to-1 correspondence between layers and traces, but add_*() functions do generate numerous traces whenever mapping a discrete variable to a visual aesthetic (e.g., color). In this case, since each call to add_lines() generates a single trace, it makes sense to name the trace, so a sensible legend entry is created. In the first layer of Figure 1.2, there is one line per city, but all these lines belong a single trace. We could have produced one trace for each line, but this is way more computationally expensive because, among other things, each trace produces a legend entry and tries to display meaningful hover information. It is much more efficient to render this layer as a single trace with missing values to differentiate groups. In fact, this is exactly how the group aesthetic is translated in ggplotly(); otherwise, layers with many groups (e.g., geom_map()) would be slow to render. 1.1.2.2 The data-plot-pipeline Since every plotly function modifies a plotly object (or the data underlying that object), we can express complex multi-layer plots as a sequence (or, more specifically, a directed acyclic graph) of data manipulations and mappings to the visual space. Moreover, plotly functions are designed to take a plotly object as input, and return a modified plotly object, making it easy to chain together operations via the pipe operator (%&gt;%) from the magrittr package (Bache and Wickham 2014). Consequently, we can re-express Figure 1.2 in a much more readable and understandable fashion. allCities &lt;- txhousing %&gt;% group_by(city) %&gt;% plot_ly(x = ~date, y = ~median) %&gt;% add_lines(alpha = 0.2, name = &quot;Texan Cities&quot;, hoverinfo = &quot;none&quot;) allCities %&gt;% filter(city == &quot;Houston&quot;) %&gt;% add_lines(name = &quot;Houston&quot;) Sometimes the directed acyclic graph property of a pipeline can be too restrictive for certain types of plots. In this example, after filtering the data down to Houston, there is no way to recover the original data inside the pipeline. The add_fun() function helps to work-around this restriction3 – it works by applying a function to the plotly object, but does not affect the data associated with the plotly object. This effectively provides a way to isolate data transformations within the pipeline4. Figure 1.3 uses this idea to highlight both Houston and San Antonio. allCities %&gt;% add_fun(function(plot) { plot %&gt;% filter(city == &quot;Houston&quot;) %&gt;% add_lines(name = &quot;Houston&quot;) }) %&gt;% add_fun(function(plot) { plot %&gt;% filter(city == &quot;San Antonio&quot;) %&gt;% add_lines(name = &quot;San Antonio&quot;) }) Figure 1.3: Monthly median house price in Houston and San Antonio in comparison to other Texan cities. It is useful to think of the function supplied to add_fun() as a “layer” function – a function that accepts a plot object as input, possibly applies a transformation to the data, and maps that data to visual objects. To make layering functions more modular, flexible, and expressive, the add_fun() allows you to pass additional arguments to a layer function. Figure 1.4 makes use of this pattern, by creating a reusable function for layering both a particular city as well as the first, second, and third quartile of median monthly house sales (by city). # reusable function for highlighting a particular city layer_city &lt;- function(plot, name) { plot %&gt;% filter(city == name) %&gt;% add_lines(name = name) } # reusable function for plotting overall median &amp; IQR layer_iqr &lt;- function(plot) { plot %&gt;% group_by(date) %&gt;% summarise( q1 = quantile(median, 0.25, na.rm = TRUE), m = median(median, na.rm = TRUE), q3 = quantile(median, 0.75, na.rm = TRUE) ) %&gt;% add_lines(y = ~m, name = &quot;median&quot;, color = I(&quot;black&quot;)) %&gt;% add_ribbons(ymin = ~q1, ymax = ~q3, name = &quot;IQR&quot;, color = I(&quot;black&quot;)) } allCities %&gt;% add_fun(layer_iqr) %&gt;% add_fun(layer_city, &quot;Houston&quot;) %&gt;% add_fun(layer_city, &quot;San Antonio&quot;) Figure 1.4: First, second, and third quartile of median monthly house pirce in Texas. A layering function does not have to be a data-plot-pipeline itself. Its only requirement on a layering function is that the first argument is a plot object and it returns a plot object. This provides an opportunity to say, fit a model to the plot data, extract the model components you desire, and map those components to visuals. Furthermore, since plotly’s add_*() functions don’t require a data.frame, you can supply those components directly to attributes (as long as they are well-defined), as done in Figure 1.5 via the forecast package (Hyndman, n.d.). library(forecast) layer_forecast &lt;- function(plot) { d &lt;- plotly_data(plot) series &lt;- with(d, ts(median, frequency = 12, start = c(2000, 1), end = c(2015, 7)) ) fore &lt;- forecast(ets(series), h = 48, level = c(80, 95)) plot %&gt;% add_ribbons(x = time(fore$mean), ymin = fore$lower[, 2], ymax = fore$upper[, 2], color = I(&quot;gray95&quot;), name = &quot;95% confidence&quot;, inherit = FALSE) %&gt;% add_ribbons(x = time(fore$mean), ymin = fore$lower[, 1], ymax = fore$upper[, 1], color = I(&quot;gray80&quot;), name = &quot;80% confidence&quot;, inherit = FALSE) %&gt;% add_lines(x = time(fore$mean), y = fore$mean, color = I(&quot;blue&quot;), name = &quot;prediction&quot;) } txhousing %&gt;% group_by(city) %&gt;% plot_ly(x = ~date, y = ~median) %&gt;% add_lines(alpha = 0.2, name = &quot;Texan Cities&quot;, hoverinfo = &quot;none&quot;) %&gt;% add_fun(layer_iqr) %&gt;% add_fun(layer_forecast) Figure 1.5: Layering on a 4-year forecast from a exponential smoothing state space model. In summary, the “data-plot-pipeline” is desirable for a number of reasons: (1) makes your code easier to read and understand, (2) encourages you to think of both your data and plots using a single, uniform data structure, which (3) makes it easy to combine and reuse different pipelines, and (4) provides a natural mechanism for implementing the pipeline(s) necessary in interactive graphics system with support for Linked Highlighting (Wickham et al. 2010). As it turns out, we can even use these ideas when creating a plotly object via ggplotly(), as discused in the next section Extending ggplotly(). In practice, it’s easy to forget about “lingering” groups (e.g., mtcars %&gt;% group_by(vs, am) %&gt;% summarise(s = sum(mpg))), so in some cases, you may need to ungroup() your data before plotting it.↩ Credit to Winston Chang and Hadley Wickham for this idea. The add_fun() is very much like layer_f() function in ggvis.↩ Also, effectively putting a pipeline inside a pipeline↩ "],
["extending-ggplotly.html", "1.2 Extending ggplotly()", " 1.2 Extending ggplotly() 1.2.1 Customizing the layout Since the ggplotly() function returns a plotly object, we can manipulate that object in the same way that we would manipulate an object created with plot_ly(). A simple and obviously useful application of this is to specify interaction modes, like plotly.js’ layout.hovermode. p &lt;- ggplot(fortify(gold), aes(x, y)) + geom_line() gg &lt;- ggplotly(p) layout(gg, hovermode = &quot;x&quot;) We can also easily add a range slider to the x-axis, which allows you to zoom on the x-axis, without losing the global context. This is quite useful for quickly altering the limits of your plot to achieve an optimal aspect ratio for your data (William S. Cleveland 1988), without losing the global perspective. rangeslider(gg) Since a single plotly object can only have one layout, modifying the layout of ggplotly() is fairly easy, but it’s trickier to add and modify layers. 1.2.2 Adding layers Since ggplotly() returns a plotly object, and plotly objects have data associated with them, we can effectively associate data from a ggplot object with a plotly object, before or after summary statistics have been applied. Since each ggplot layer owns a data frame, it is useful to have some way to specify the particular layer of data of interest, which is the point of the layerData argument in ggplotly(). Also, when a particular layer applies a summary statistic (e.g., geom_bin()), or applies a model (e.g., geom_smooth()) to the data, it might be useful to access the output of that transformation, which is the point of the originalData argument in ggplotly(). p &lt;- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point() + geom_smooth() p %&gt;% ggplotly(layerData = 2, originalData = FALSE) %&gt;% plotly_data() #&gt; # A tibble: 80 × 13 #&gt; x y ymin ymax se PANEL group colour fill size linetype #&gt; * &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1.51 32.1 28.1 36.0 1.92 1 -1 #3366FF grey60 1 1 #&gt; 2 1.56 31.7 28.2 35.2 1.72 1 -1 #3366FF grey60 1 1 #&gt; 3 1.61 31.3 28.1 34.5 1.54 1 -1 #3366FF grey60 1 1 #&gt; 4 1.66 30.9 28.0 33.7 1.39 1 -1 #3366FF grey60 1 1 #&gt; 5 1.71 30.5 27.9 33.0 1.26 1 -1 #3366FF grey60 1 1 #&gt; 6 1.76 30.0 27.7 32.4 1.16 1 -1 #3366FF grey60 1 1 #&gt; # ... with 74 more rows, and 2 more variables: weight &lt;dbl&gt;, alpha &lt;dbl&gt; This is the dataset ggplot2 uses to actually draw the fitted values (as a line) and standard error bounds (as a ribbon). Figure 1.6 uses this data to add additional information about the model fit; in particular, it adds a vertical lines and annotations at the x-values that are associated with the highest and lowest amount uncertainty in y. p %&gt;% ggplotly(layerData = 2, originalData = F) %&gt;% add_fun(function(p) { p %&gt;% slice(which.max(se)) %&gt;% add_segments(x = ~x, xend = ~x, y = ~ymin, yend = ~ymax) %&gt;% add_annotations(&quot;Maximum uncertainty&quot;, ax = 60) }) %&gt;% add_fun(function(p) { p %&gt;% slice(which.min(se)) %&gt;% add_segments(x = ~x, xend = ~x, y = ~ymin, yend = ~ymax) %&gt;% add_annotations(&quot;Minimum uncertainty&quot;) }) Figure 1.6: Leveraging data associated with a geom_smooth() layer to display additional information about the model fit. Although it is not used in this example, it worth noting that when adding plotly layers to the output of ggplotly(), it will inherit the global mapping by default, which may or may not be desired, but the inherit argument in any of the add_*() functions may be set to FALSE to avoid this behavoir. 1.2.3 Modifying layers As mentioned previously, ggplotly() translates each ggplot2 layer into one or more plotly.js traces. In this translation, it is forced to make a number of assumptions about trace attribute values that may or may not be appropriate for the use case. The style() function is useful in this scenario, as it provides a way to modify trace attribute values in a plotly object. Before using it, you may want to inspect the actual traces in a given plotly object using the plotly_json() function. This function uses the listviewer package to display a convenient interactive view of the JSON object sent to plotly.js (de Jong and Russell 2016). By clicking on the arrow next to the data element, you can see the traces (data) behind the plot. In this case, we have three traces: one for the geom_point() layer and two for the geom_smooth() layer. plotly_json(p) Figure 1.7: Using listviewer to inspect a plotly object. Say, for example, we’d like to display information when hovering over points, but not when hovering over the fitted values or error bounds. The ggplot2 API has no semantics for making this distinction, but this is easily done in plotly.js by setting the hoverinfo attribute to &quot;none&quot;. Since the fitted values or error bounds are contained in the second and third traces, we can hide the information on just these traces using the traces attribute in the style() function: style(p, hoverinfo = &quot;none&quot;, traces = 2:3) "],
["choosing-an-interface.html", "1.3 Choosing an interface", " 1.3 Choosing an interface ggplot2 requires data frame(s) and can be inefficient (especially for time series). ggplot2 does not have a functional interface (making it awkward to combine with modern functional interfaces such as dplyr), and does not satisfy referential transparency (making it easier to program with – for more details, see ) ggplotly() tries to replicate exactly what you see in the corresponding static ggplot2 graph. To do so, it sends axis tick information to plotly as tickvals/ticktext properties, and consequently, axis ticks do not update on zoom events. ggplot2’s interface wasn’t designed for interactive graphics. Directly extending the grammar to support more advanced types of interaction (e.g., linked brushing) is a risky endeavor. -->"],
["the-plotly-cookbook.html", "2 The plotly cookbook", " 2 The plotly cookbook This chapter demonstrates the capabilities of plot_ly() through a series of examples. The plot_ly() function does provide a direct interface to plotly.js, so anything in the figure reference can be specified via plot_ly(), but this chapter will focus more on the semantics unique to the R package that can’t be found on the figure reference. Along the way, we will touch on some best practices in visualization. "],
["scatter-traces.html", "2.1 Scatter traces", " 2.1 Scatter traces A plotly visualization is composed of one (or more) trace(s), and every trace has a type. The default trace type, “scatter”, can be used to draw a large amount of geometries, and actually powers many of the add_*() functions such as add_markers(), add_lines(), add_paths(), add_segments(), add_ribbons(), and add_polygons(). Among other things, these functions make assumptions about the mode of the scatter trace, but any valid attribute(s) listed under the scatter section of the figure reference may be used to override defaults. You may notice some arguments are related to items in the in the figure reference, but are not listed (e.g., color/colors, symbol/symbols, linetype/linetypes, size/sizes). These arguments (documented on the help page help(plot_ly)) are unique to the R package and make it easier to scale data values to visual aesthetics. Generally speaking, the singular form of the argument defines the domain of the scale (data) and the plural form defines the range of the scale (visuals). To make it easier to alter default visual aesthetics (e.g., change all points from blue to black), interprets “AsIs” values (values wrapped with the I() function) as values that already live in visual space, and thus do not need to be scaled. The next section on scatterplots explores detailed use of the color/colors, symbol/symbols, &amp; size/sizes arguments. The section on lineplots explores detailed use of the linetype/linetypes. 2.1.1 Scatterplots The scatterplot is useful for visualizing the correlation between two quantitative variables. If you supply a numeric vector for x and y in plot_ly(), it defaults to a scatterplot, but you can also be explicit about adding a layer of markers/points via the add_markers() function. A common problem with scatterplots is overplotting, meaning that there are multiple observations occupying the same (or similar) x/y locations. There are a few ways to combat overplotting including: alpha transparency, hollow symbols, and 2D density estimation. Figure 2.1 shows how alpha transparency and hollow symbols can provide an improvment over the default. subplot( plot_ly(mpg, x = ~cty, y = ~hwy, name = &quot;default&quot;), plot_ly(mpg, x = ~cty, y = ~hwy) %&gt;% add_markers(alpha = 0.2, name = &quot;alpha&quot;), plot_ly(mpg, x = ~cty, y = ~hwy) %&gt;% add_markers(symbol = I(1), name = &quot;hollow&quot;) ) Figure 2.1: Three versions of a basic scatterplot In Figure 2.1, hollow circles are specified via symbol = I(1). By default, the symbol argument (as well as the color/size/linetype arguments) assumes value(s) are “data”, which need to be mapped to a visual palette (provided by symbols). Wrapping values with the I() function notifies plot_ly() that these values should be taken “AsIs”. If you compare the result of plot(1:25, 1:25, pch = 1:25) to Figure 2.2, you’ll see that plot_ly() can translate R’s plotting characters (pch), but you can also use plotly.js’ symbol syntax, if you desire. subplot( plot_ly(x = 1:25, y = 1:25, symbol = I(1:25), name = &quot;pch&quot;), plot_ly(mpg, x = ~cty, y = ~hwy, symbol = ~cyl, symbols = 1:3, name = &quot;cyl&quot;) ) Figure 2.2: Specifying symbol in a scatterplot When mapping a numeric variable to symbol, it creates only one trace, so no legend is generated. If you do want one trace per symbol, make sure the variable you’re mapping is a factor, as Figure 2.3 demonstrates. When plotting multiple traces, the default plotly.js color scale will apply, but you can set the color of every trace generated from this layer with color = I(&quot;black&quot;), or similar. p &lt;- plot_ly(mpg, x = ~cty, y = ~hwy, alpha = 0.3) subplot( add_markers(p, symbol = ~cyl, name = &quot;A single trace&quot;), add_markers(p, symbol = ~factor(cyl), color = I(&quot;black&quot;)) ) Figure 2.3: Mapping symbol to a factor The color argument adheres to similar rules as symbol: If numeric, color produces one trace, but colorbar is also generated to aide the decoding of colors back to data values. The colorbar() function can be used to customize the appearance of this automatically generated guide. The default colorscale is viridis, a perceptually-uniform colorscale (even when converted to black-and-white), and perceivable even to those with common forms of color blindness (Data Science 2016). If discrete, color produces one trace per value, meaning a legend is generated. If an ordered factor, the default colorscale is viridis (Garnier 2016); otherwise, it is the “Set2” palette from the RColorBrewer package (Neuwirth 2014) p &lt;- plot_ly(mpg, x = ~cty, y = ~hwy, alpha = 0.5) subplot( add_markers(p, color = ~cyl, showlegend = FALSE) %&gt;% colorbar(title = &quot;Viridis&quot;, len = 1/2, y = 1), add_markers(p, color = ~factor(cyl)) ) %&gt;% layout(showlegend = TRUE) Figure 2.4: Variations on a numeric color mapping. There are a number of ways to alter the default colorscale via the colors argument. This argument excepts: (1) a color brewer palette name (see the row names of RColorBrewer::brewer.pal.info for valid names), (2) a vector of colors to interpolate, or (3) a color interpolation function like colorRamp() or scales::colour_ramp(). Although this grants a lot of flexibility, one should be concious of using a sequential colorscale for numeric variables (&amp; ordered factors) as shown in 2.5, and a qualitative colorscale for discrete variables as shown in 2.6. (TODO: touch on lurking variables?) subplot( add_markers(p, color = ~cyl, colors = c(&quot;#132B43&quot;, &quot;#56B1F7&quot;)) %&gt;% colorbar(title = &quot;ggplot2 default&quot;, len = 1/3, y = 1), add_markers(p, color = ~cyl, colors = viridisLite::inferno(10)) %&gt;% colorbar(title = &quot;Inferno&quot;, len = 1/3, y = 2/3), add_markers(p, color = ~cyl, colors = colorRamp(c(&quot;red&quot;, &quot;white&quot;, &quot;blue&quot;))) %&gt;% colorbar(title = &quot;colorRamp&quot;, len = 1/3, y = 1/3) ) Figure 2.5: Three variations on a numeric color mapping subplot( add_markers(p, color = ~factor(cyl), colors = &quot;Pastel1&quot;), add_markers(p, color = ~factor(cyl), colors = colorRamp(c(&quot;red&quot;, &quot;blue&quot;))), add_markers(p, color = ~factor(cyl), colors = c(`4` = &quot;red&quot;, `5` = &quot;black&quot;, `6` = &quot;blue&quot;, `8` = &quot;green&quot;)) ) %&gt;% layout(showlegend = FALSE) Figure 2.6: Three variations on a discrete color mapping For scatterplots, the size argument controls the area of markers (unless otherwise specified via sizemode), and must be a numeric variable. The sizes argument controls the minimum and maximum size of circles, in pixels: subplot( add_markers(p, size = ~cyl, name = &quot;default&quot;), add_markers(p, size = ~cyl, sizes = c(1, 500), name = &quot;custom&quot;) ) 2.1.1.1 3D scatterplots To make a 3D scatterplot, just add a z attribute: plot_ly(mpg, x = ~cty, y = ~hwy, z = ~cyl) %&gt;% add_markers(color = ~cyl) Figure 2.7: A 3D scatterplot 2.1.1.2 Scatterplot matrices Scatterplot matrices can be made via plot_ly() and subplot(), but ggplotly() has a special method for translating ggmatrix objects from the GGally package to plotly objects (Schloerke et al. 2016). These objects are essentially a matrix of ggplot objects and are the underlying data structure which powers higher level functions in GGally, such as ggpairs() – a function for creating a generalized pairs plot (Emerson et al. 2013). The generalized pairs plot can be motivated as a generalization of the scatterplot matrix with support for categorical variables and different visual representations of the data powered by the grammar of graphics. Figure 2.8 shows an interactive version of the generalized pairs plot made via ggpairs() and ggplotly(). In Linking views without shiny, we explore how this framework can be extended to enable linked brushing in the generalized pairs plot. pm &lt;- GGally::ggpairs(iris) ggplotly(pm) Figure 2.8: An interactive version of the generalized pairs plot made via the ggpairs() function from the GGally package 2.1.2 Dotplots &amp; error bars A dotplot is similar to a scatterplot, except instead of two numeric axes, one is categorical. The usual goal of a dotplot is to compare value(s) on a numerical scale over numerous categories. In this context, dotplots are preferrable to pie charts since comparing position along a common scale is much easier than comparing angle or area (W. S. Cleveland and McGill 1984); (Bostock 2010). Furthermore, dotplots can be preferrable to bar charts, especially when comparing values within a narrow range far away from 0 (Few 2006). Also, when presenting point estimates, and uncertainty associated with those estimates, bar charts tend to exaggerate the difference in point estimates, and lose focus on uncertainty (Messing 2012). A popular application for dotplots (with error bars) is the so-called “coefficient plot” for visualizing the point estimates of coefficients and their standard error. The coefplot() function in the coefplot package (Lander 2016) and the ggcoef() function in the GGally both produce coefficient plots for many types of model objects in R using ggplot2, which we can translate to plotly via ggplotly(). Since these packages use points and segments to draw the coefficient plots, the hover information is not the best, and it’d be better to use error objects. Figure 2.9 uses the tidy() function from the broom package (Robinson 2016) to obtain a data frame with one row per model coefficient, and produce a coefficient plot with error bars along the x-axis. m &lt;- lm(Sepal.Length ~ Sepal.Width * Petal.Length * Petal.Width, data = iris) # arrange by estimate, then make term a factor to order categories in the plot d &lt;- broom::tidy(m) %&gt;% arrange(desc(estimate)) %&gt;% mutate(term = factor(term, levels = term)) plot_ly(d, x = ~estimate, y = ~term) %&gt;% add_markers(error_x = ~list(value = std.error)) %&gt;% layout(margin = list(l = 200)) Figure 2.9: A coefficient plot 2.1.3 Line plots This section surveys useful applications of add_lines() and add_paths(). The only difference between these functions is that add_lines() connects x/y pairs from left to right, instead of the order in which the data appears. Both functions understand the color, linetype, and alpha attributes5, as well as groupings defined by group_by(). Figure 1.2 uses group_by() to plot one line per city in the txhousing dataset using a single trace. Since there can only be one tooltip per trace, hovering over that plot does not reveal useful information. Although plotting many traces can be computationally expensive, it is necessary in order to display better information on hover. Since the color argument produces one trace per value (if the variable (city) is discrete), hovering on Figure 2.10 reveals the top ~10 cities at a given x value. Since 46 colors is too many to perceive in a single plot, Figure 2.10 also restricts the set of possible colors to black. plot_ly(txhousing, x = ~date, y = ~median) %&gt;% add_lines(color = ~city, colors = &quot;black&quot;, alpha = 0.2) Figure 2.10: Median house sales with one trace per city. Generally speaking, it’s hard to perceive more than 8 different colors/linetypes/symbols in a given plot, so sometimes we have to filter data to use these effectively. Here we use the dplyr package to find the top 5 cities in terms of average monthly sales (top5), then effectively filter the original data to contain just these cities via semi_join(). Once we have the data is filtered, mapping city to color or linetype is trivial. The color palette can be altered via the colors argument, and follows the same rules as scatterplots. The linetype palette can be altered via the linetypes argument, and accepts R’s lty values or plotly.js dash values. library(dplyr) top5 &lt;- txhousing %&gt;% group_by(city) %&gt;% summarise(m = mean(sales, na.rm = TRUE)) %&gt;% arrange(desc(m)) %&gt;% top_n(5) p &lt;- semi_join(txhousing, top5) %&gt;% plot_ly(x = ~date, y = ~median) subplot( add_lines(p, color = ~city), add_lines(p, linetype = ~city), shareX = TRUE, nrows = 2 ) 2.1.3.1 Density plots In Bars &amp; histograms, we leveraged a number of algorithms in R for computing the “optimal” number of bins for a histogram, via hist(), and routing those results to add_bars(). kerns &lt;- c(&quot;gaussian&quot;, &quot;epanechnikov&quot;, &quot;rectangular&quot;, &quot;triangular&quot;, &quot;biweight&quot;, &quot;cosine&quot;, &quot;optcosine&quot;) p &lt;- plot_ly() for (k in kerns) { d &lt;- density(txhousing$median, kernel = k, na.rm = TRUE) p &lt;- add_lines(p, x = d$x, y = d$y, name = k) } layout(p, xaxis = list(title = &quot;Median monthly price&quot;)) 2.1.3.2 Parallel Coordinates One very useful, but often overlooked, visualization technique is the parallel coordinates plot. Parallel coordinates provide a way to compare values along a common (or non-aligned) positional scale(s) – the most basic of all perceptual tasks – in more than 3 dimensions (W. S. Cleveland and McGill 1984). Usually each line represents every measurement for a given row (or observation) in a data set. When measurements are on very different scales, some care must be taken, and variables must transformed to be put on a common scale. As Figure 2.11 shows, even when variables are measured on a similar scale, it can still be a informative to transform variables in different ways. iris$obs &lt;- seq_len(nrow(iris)) iris_pcp &lt;- function(transform = identity) { iris[] &lt;- purrr::map_if(iris, is.numeric, transform) tidyr::gather(iris, variable, value, -Species, -obs) %&gt;% group_by(obs) %&gt;% plot_ly(x = ~variable, y = ~value, color = ~Species) %&gt;% add_lines(alpha = 0.3) } subplot( iris_pcp(), iris_pcp(scale), iris_pcp(scales::rescale) ) %&gt;% hide_legend() Figure 2.11: Parallel coordinates plots of the Iris dataset. On the left is the raw measurements. In the middle, each variable is scaled to have mean of 0 and standard deviation of 1. On the right, each variable is scaled to have a minimum of 0 and a maximum of 1. It is also worth noting that the GGally offers a ggparcoord() function which creates parallel coordinate plots via ggplot2, which we can convert to plotly via ggplotly(). In linked highlighting, parallel coordinates are linked to lower dimensional (but sometimes higher resolution) graphics of related data to guide multi-variate data exploration. 2.1.3.3 3D line plots To make a 3D line plot, just add a z attribute (in addition to x and y): plot_ly(mpg, x = ~cty, y = ~hwy, z = ~cyl) %&gt;% add_lines(color = ~displ) Figure 2.12: A 3D scatterplot 2.1.4 Segments The add_segments() function essentially provides a way to connect two points ((x, y) to (xend, yend)) with a line. Segments form the building blocks for many useful chart types, including candlestick charts, a popular way to visualize stock prices. Figure 2.13 uses the quantmod package (Ryan 2016) to obtain stock price data for Microsoft and plots two segments for each day: one to encode the opening/closing values, and one to encode the daily high/low. library(quantmod) msft &lt;- getSymbols(&quot;MSFT&quot;, auto.assign = F) dat &lt;- as.data.frame(msft) dat$date &lt;- index(msft) dat &lt;- subset(dat, date &gt;= &quot;2016-01-01&quot;) names(dat) &lt;- sub(&quot;^MSFT\\\\.&quot;, &quot;&quot;, names(dat)) plot_ly(dat, x = ~date, xend = ~date, color = ~Close &gt; Open, colors = c(&quot;red&quot;, &quot;forestgreen&quot;), hoverinfo = &quot;none&quot;) %&gt;% add_segments(y = ~Low, yend = ~High, size = I(1)) %&gt;% add_segments(y = ~Open, yend = ~Close, size = I(3)) %&gt;% layout(showlegend = FALSE, yaxis = list(title = &quot;Price&quot;)) %&gt;% rangeslider() Figure 2.13: A candelstick chart 2.1.5 Ribbons Ribbons are useful for showing uncertainy bounds as a function of x. The add_ribbons() function creates ribbons and requires the arguments: ymin and ymax. The augment() function from the broom package appends observational-level model components (e.g., fitted values stored as a new column .fitted) which is useful for extracting those components in a form that is convenient for visualization. m &lt;- lm(mpg ~ wt, data = mtcars) broom::augment(m) %&gt;% plot_ly(x = ~wt, showlegend = FALSE) %&gt;% add_markers(y = ~mpg, color = I(&quot;black&quot;)) %&gt;% add_ribbons(ymin = ~.fitted - 1.96 * .se.fit, ymax = ~.fitted + 1.96 * .se.fit, color = I(&quot;gray80&quot;)) %&gt;% add_lines(y = ~.fitted, color = I(&quot;steelblue&quot;)) 2.1.6 Polygons The add_polygons() function is essentially equivalent to add_paths() with the fill attribute set to “toself”. Polygons from the basis for other, higher-level, geometries such as add_ribbons(), but can be useful in their own right. map_data(&quot;world&quot;, &quot;canada&quot;) %&gt;% group_by(group) %&gt;% plot_ly(x = ~long, y = ~lat, alpha = 0.2) %&gt;% add_polygons(hoverinfo = &quot;none&quot;, color = I(&quot;black&quot;)) %&gt;% add_markers(text = ~paste(name, &quot;&lt;br /&gt;&quot;, pop), hoverinfo = &quot;text&quot;, color = I(&quot;red&quot;), data = maps::canada.cities) %&gt;% layout(showlegend = FALSE) plotly.js currently does not support data arrays for scatter.line.width or scatter.line.color, meaning a single line trace can only have one width/color in 2D line plot, and consequently numeric color/size mappings won’t work↩ "],
["maps.html", "2.2 Maps", " 2.2 Maps 2.2.1 Using scatter traces As shown in polygons, it is possible to create maps using plotly’s default (cartesian) coordinate system, but plotly.js also has support for plotting scatter traces on top of either a custom geo layout or a mapbox layout. Figure 2.14 compares the three different layout options in a single subplot. dat &lt;- map_data(&quot;world&quot;, &quot;canada&quot;) %&gt;% group_by(group) map1 &lt;- plot_ly(dat, x = ~long, y = ~lat) %&gt;% add_paths(size = I(1)) %&gt;% add_segments(x = -100, xend = -50, y = 50, 75) map2 &lt;- plot_mapbox(dat, x = ~long, y = ~lat) %&gt;% add_paths(size = I(2)) %&gt;% add_segments(x = -100, xend = -50, y = 50, 75) %&gt;% layout(mapbox = list(zoom = 0, center = list(lat = ~median(lat), lon = ~median(long)) )) # geo() is the only object type which supports different map projections map3 &lt;- plot_geo(dat, x = ~long, y = ~lat) %&gt;% add_markers(size = I(1)) %&gt;% add_segments(x = -100, xend = -50, y = 50, 75) %&gt;% layout(geo = list(projection = list(type = &quot;mercator&quot;))) subplot(map1, map2) %&gt;% subplot(map3, nrows = 2) %&gt;% hide_legend() Figure 2.14: A few maps Any of the add_*() functions found under scatter traces should work as expected on plotly-geo (initialized via plot_geo()) or plotly-mapbox (initialized via plot_mapbox()) objects. You can think of plot_geo() and plot_mapbox() as special cases (or more opiniated versions) of plot_ly(). For one, they won’t allow you to mix scatter and non-scatter traces in a single plot object, which you probably don’t want to do anyway. In order to enable Figure 2.14, plotly.js can’t make this restriction, but since we have subplot() in R, we can make this restriction without sacrificing flexibility. 2.2.2 Choropleths In addition to scatter traces, plotly-geo objects can also create a choropleth trace/layer. Figure 2.15 shows the population density of the U.S. via a choropleth, and also layers on markers for the state center locations, using the U.S. state data from the datasets package (R Core Team 2016). By simply providing a z attribute, plotly-geo objects will try to create a choropleth, but you’ll also need to provide locations and a locationmode. density &lt;- state.x77[, &quot;Population&quot;] / state.x77[, &quot;Area&quot;] g &lt;- list( scope = &#39;usa&#39;, projection = list(type = &#39;albers usa&#39;), lakecolor = toRGB(&#39;white&#39;) ) plot_geo() %&gt;% add_trace( z = ~density, text = state.name, locations = state.abb, locationmode = &#39;USA-states&#39; ) %&gt;% add_markers( x = state.center[[&quot;x&quot;]], y = state.center[[&quot;y&quot;]], size = I(2), symbol = I(8), color = I(&quot;white&quot;), hoverinfo = &quot;none&quot; ) %&gt;% layout(geo = g) Figure 2.15: A map of U.S. population density using the state.x77 data from the datasets package. "],
["bars-histograms.html", "2.3 Bars &amp; histograms", " 2.3 Bars &amp; histograms The add_bars() and add_histogram() functions wrap the bar and histogram plotly.js trace types. The main difference between them is that bar traces require bar heights (both x and y), whereas histogram traces require just a single variable, and plotly.js handles binning in the browser.6 And perhaps confusingly, both of these functions can be used to visualize the distribution of either a numeric or a discrete variable. So, essentially, the only difference between them is where the binning occurs. Figure 2.16 compares the default binning algorithm in plotly.js to a few different algorithms available in R via the hist() function. Although plotly.js has the ability to customize histogram bins via xbins/ybins, R has diverse facilities for estimating the optimal number of bins in a histogram that we can easily leverage.7 The hist() function alone allows us to reference 3 famous algorithms by name (Sturges 1926); (Freedman and Diaconis 1981); (David W Scott 1979), but there are also packages (e.g. the histogram package) which extend this interface to incorporate more methodology (Mildenberger, Rozenholc, and Zasada. 2009). The price_hist() function below wraps the hist() function to obtain the binning results, and map those bins to a plotly version of the histogram using add_bars(). p1 &lt;- plot_ly(diamonds, x = ~price) %&gt;% add_histogram(name = &quot;plotly.js&quot;) price_hist &lt;- function(method = &quot;FD&quot;) { h &lt;- hist(diamonds$price, breaks = method, plot = FALSE) plot_ly(x = h$mids, y = h$counts) %&gt;% add_bars(name = method) } subplot( p1, price_hist(), price_hist(&quot;Sturges&quot;), price_hist(&quot;Scott&quot;), nrows = 4, shareX = TRUE ) Figure 2.16: plotly.js’s default binning algorithm versus R’s hist() default Figure 2.17 demonstrates two ways of creating a basic bar chart. Although the visual results are the same, its worth noting the difference in implementation. The add_histogram() function sends all of the observed values to the browser and lets plotly.js perform the binning. It takes more human effort to perform the binning in R, but doing so has the benefit of sending less data, and requiring less computation work of the web browser. In this case, we have only about 50,000 records, so there is much of a difference in page load times or page size. However, with 1 Million records, page load time more than doubles and page size nearly doubles.8 p1 &lt;- plot_ly(diamonds, x = ~cut) %&gt;% add_histogram() p2 &lt;- diamonds %&gt;% dplyr::count(cut) %&gt;% plot_ly(x = ~cut, y = ~n) %&gt;% add_bars() subplot(p1, p2) %&gt;% hide_legend() Figure 2.17: Number of diamonds by cut. 2.3.1 Multiple numeric distributions It is often useful to see how the numeric distribution changes with respect to a discrete variable. When using bars to visualize multiple numeric distributions, I recommend plotting each distribution on its own axis, rather than trying to overlay them on a single axis.9. This is where the subplot() infrastructure, and its support for trellis displays, comes in handy. Figure 2.18 shows a trellis display of diamond price by diamond color. Note how the one_plot() function defines what to display on each panel, then a split-apply-recombine strategy is employed to generate the trellis display. one_plot &lt;- function(d) { plot_ly(d, x = ~price) %&gt;% add_annotations( ~paste(&quot;Clarity:&quot;, unique(clarity)), x = 0.5, y = 1, xref = &quot;paper&quot;, yref = &quot;paper&quot;, showarrow = FALSE ) } diamonds %&gt;% split(.$clarity) %&gt;% lapply(one_plot) %&gt;% subplot(nrows = 2, shareX = TRUE, titleX = FALSE) %&gt;% hide_legend() Figure 2.18: A trellis display of diamond price by diamond color. 2.3.2 Multiple discrete distributions Visualizing multiple discrete distributions is difficult. The subtle complexity is due to the fact that both counts and proportions are important for understanding multi-variate discrete distributions. Figure 2.19 presents diamond counts, divided by both their cut and clarity, using a grouped bar chart. plot_ly(diamonds, x = ~cut, color = ~clarity) %&gt;% add_histogram() Figure 2.19: A grouped bar chart Figure 2.19 is useful for comparing the number of diamonds by clarity, given a type of cut. For instance, within “Ideal” diamonds, a cut of “VS1” is most popular, “VS2” is second most popular, and “I1” the least popular. The distribution of clarity within “Ideal” diamonds seems to be fairly similar to other diamonds, but it’s hard to make this comparison using raw counts. Figure 2.20 makes this comparison easier by showing the relative frequency of diamonds by clarity, given a cut. # number of diamonds by cut and clarity (n) cc &lt;- count(diamonds, cut, clarity) # number of diamonds by cut (nn) cc2 &lt;- left_join(cc, count(cc, cut, wt = n)) cc2 %&gt;% mutate(prop = n / nn) %&gt;% plot_ly(x = ~cut, y = ~prop, color = ~clarity) %&gt;% add_bars() %&gt;% layout(barmode = &quot;stack&quot;) Figure 2.20: A stacked bar chart showing the proportion of clarity within This type of plot, also known as a spine plot, is a special case of a mosaic plot. In a mosaic plot, you can scale both bar widths and heights according to discrete distributions. For mosaic plots, I recommend using the ggmosaic package (Jeppson, Hofmann, and Cook, n.d.), which implements a custom ggplot2 geom designed for mosaic plots, which we can convert to plotly via ggplotly(). Figure 2.21 show a mosaic plot of cut by clarity. Notice how the bar widths are scaled proportional to the cut frequency. library(ggmosaic) p &lt;- ggplot(data = cc) + geom_mosaic(aes(weight = n, x = product(cut), fill = clarity)) #&gt; Error in as.vector(y): attempt to apply non-function ggplotly(p) Figure 2.21: Using ggmosaic and ggplotly() to create advanced interactive visualizations of categorical data This has some interesting applications for linked highlighting as it allows for summary statistics to be computed on-the-fly based on a selection↩ Optimal in this context is the number of bins which minimizes the distance between the empirical histogram and the underlying density.↩ These tests were run on Google Chrome and loaded a page with a single bar chart. Here are the results for add_histogram() and here are the results for add_bars()↩ It’s much easier to visualize multiple numeric distributions on a single axis using lines↩ "],
["boxplots.html", "2.4 Boxplots", " 2.4 Boxplots Boxplots encode the five number summary of a numeric variable, and are more efficient than trellis displays of histograms for comparing many numeric distributions. The add_boxplot() function requires one numeric variable, and guarantees boxplots are oriented correctly, regardless of whether the numeric variable is placed on the x or y scale. As Figure 2.22 shows, on the axis orthogonal to the numeric axis, you can provide a discrete variable (for conditioning) or supply a single value (to name the axis category). p &lt;- plot_ly(diamonds, y = ~price, color = I(&quot;black&quot;), alpha = 0.1, boxpoints = &quot;suspectedoutliers&quot;) p1 &lt;- p %&gt;% add_boxplot(x = &quot;Overall&quot;) p2 &lt;- p %&gt;% add_boxplot(x = ~cut) subplot( p1, p2, shareY = TRUE, widths = c(0.2, 0.8), margin = 0 ) %&gt;% hide_legend() Figure 2.22: Overall diamond price and price by cut. If you want to partition by more than one discrete variable, I recommend mapping the interaction of those variables to the discrete axis, and coloring by the nested variable, as Figure 2.23 does with diamond clarity and cut. plot_ly(diamonds, x = ~price, y = ~interaction(clarity, cut)) %&gt;% add_boxplot(color = ~clarity) %&gt;% layout(yaxis = list(title = &quot;&quot;), margin = list(l = 100)) Figure 2.23: Diamond prices by cut and clarity. It is also helpful to sort the boxplots according to something meaningful, such as the median price. Figure 2.24 presents the same information as Figure 2.23, but sorts the boxplots by their median, and makes it immediately clear that diamonds with a cut of “SI2” have the highest diamond price, on average. d &lt;- diamonds %&gt;% mutate(cc = interaction(clarity, cut)) # interaction levels sorted by median price lvls &lt;- d %&gt;% group_by(cc) %&gt;% summarise(m = median(price)) %&gt;% arrange(m) %&gt;% .[[&quot;cc&quot;]] plot_ly(d, x = ~price, y = ~factor(cc, lvls)) %&gt;% add_boxplot(color = ~clarity) %&gt;% layout(yaxis = list(title = &quot;&quot;), margin = list(l = 100)) Figure 2.24: Diamond prices by cut and clarity, sorted by price median. Similar to add_histogram(), add_boxplot() sends the raw data to the browser, and lets plotly.js compute summary statistics. Unfortunately, plotly.js does not yet allow precomputed statistics for boxplots.10 Follow the issue here https://github.com/plotly/plotly.js/issues/242↩ "],
["d-distributions.html", "2.5 2D distributions", " 2.5 2D distributions 2.5.1 Rectangular binning in plotly.js The plotly package provides two functions for displaying rectangular bins: add_heatmap() and add_histogram2d(). For numeric data, the add_heatmap() function is a 2D analog of add_bars() (bins must be pre-computed), and the add_histogram2d() function is a 2D analog of add_histogram() (bins can be computed in the browser). Thus, I recommend add_histogram2d() for exploratory purposes, since you don’t have to think about how to perform binning. It also provides a useful zsmooth attribute for effectively increasing the number of bins (currently, “best” performs a bi-linear interpolation, a type of nearest neighbors algorithm), and nbinsx/nbinsy attributes to set the number of bins in the x and/or y directions. Figure 2.25 compares three different uses of add_histogram(): (1) plotly.js’ default binning algorithm, (2) the default plus smoothing, (3) setting the number of bins in the x and y directions. p &lt;- plot_ly(diamonds, x = ~log(carat), y = ~log(price)) subplot( add_histogram2d(p) %&gt;% colorbar(title = &quot;default&quot;, len = 1/3, y = 1) %&gt;% layout(xaxis = list(title = &quot;default&quot;)), add_histogram2d(p, zsmooth = &quot;best&quot;) %&gt;% colorbar(title = &quot;zsmooth&quot;, len = 1/3, y = 2/3 - 0.05) %&gt;% layout(xaxis = list(title = &quot;zsmooth&quot;)), add_histogram2d(p, nbinsx = 60, nbinsy = 60) %&gt;% colorbar(title = &quot;nbins&quot;, len = 1/3, y = 1/3 - 0.1) %&gt;% layout(xaxis = list(title = &quot;nbins&quot;)), shareY = TRUE, titleX = TRUE ) Figure 2.25: Three different uses of histogram2d() 2.5.2 Rectangular binning in R In Bars &amp; histograms, we leveraged a number of algorithms in R for computing the “optimal” number of bins for a histogram, via hist(), and routing those results to add_bars(). There is a surprising lack of research and computational tools for the 2D analog, and among the research that does exist, solutions usually depend on characteristics of the unknown underlying distribution, so the typical approach is to assume a Gaussian form (David W. Scott 1992). Kernel density estimation is another non Practically speaking, that assumption is not very useful, but thankfully , and specifically the kde2d() function from the MASS package, provides a well-supported rule-of-thumb. kde_count &lt;- function(x, y, ...) { kde &lt;- MASS::kde2d(x, y, ...) df &lt;- with(kde, setNames(expand.grid(x, y), c(&quot;x&quot;, &quot;y&quot;))) df$count &lt;- with(kde, c(z) * length(x) * diff(x)[1] * diff(y)[1]) data.frame(df) } kd &lt;- with(diamonds, kde_count(log(carat), log(price), n = 30)) plot_ly(kd, x = ~x, y = ~y, z = ~count) %&gt;% add_heatmap() %&gt;% colorbar(title = &quot;Number of diamonds&quot;) Figure 2.26: 2D Density estimation via the kde2d() function 2.5.3 Basic heatmaps The add_heatmap() function can also handle categorical x and y variables. corr &lt;- cor(diamonds[vapply(diamonds, is.numeric, logical(1))]) plot_ly(x = rownames(corr), y = colnames(corr), z = corr) %&gt;% add_heatmap() %&gt;% colorbar(limits = c(-1, 1)) A heatmap with categorical axes is basically a two-way table. The Titanic dataset is a four-way table that we can put into a tidy data frame using the tidy() function from the broom package. broom::tidy(Titanic) %&gt;% plot_ly(x = ~interaction(Age, Survived), y = ~interaction(Class, Sex)) %&gt;% add_heatmap(z = ~Freq) #one_heatmap &lt;- function(d) { # plot_ly(d, x = ~Class, y = ~Sex) %&gt;% # add_heatmap(z = ~Freq) %&gt;% # add_annotations( # ~unique(paste(Age, Survived, sep = &quot;, &quot;)), x = 0.5, y = 1, # yanchor = &quot;bottom&quot;, xanchor = &quot;middle&quot;, # xref = &quot;paper&quot;, yref = &quot;paper&quot;, showarrow = FALSE # ) #} # #tidy(Titanic) %&gt;% # group_by(Age, Survived) %&gt;% # do(p = one_heatmap(.)) %&gt;% # subplot( # nrows = 2, margin = c(0.01, 0.01, 0.04, 0.04), # shareX = TRUE, shareY = TRUE, # titleY = FALSE, titleX = FALSE # ) 2.5.4 Contours plot_ly(diamonds, x = ~cut, y = ~clarity) %&gt;% add_histogram2dcontour() "],
["d-plots.html", "2.6 3D plots", " 2.6 3D plots 2.6.1 Surface 2.6.2 Mesh "],
["annotations.html", "2.7 Annotations", " 2.7 Annotations The add_annotations() function -->"],
["subplot.html", "3 Arranging multiple views", " 3 Arranging multiple views The subplot() function provides a flexible interface for arranging multiple plotly plots in a single view. It is more flexible than most trellis display frameworks (e.g., ggplot2’s facet_wrap()) as you don’t have to condition on a value of common variable in each display (Richard A. Becker 1996). Its capabilities and interface is similar to the grid.arrange() function from the gridExtra package, which allows you to arrange multiple grid grobs in a single view, effectively providing a way to arrange (possibly unrelated) ggplot2 and/or lattice plots in a single view (R Core Team 2016); (Auguie 2016); (Sarkar 2008). The simplest way to use it is to pass plotly objects directly to subplot(). library(plotly) p1 &lt;- plot_ly(economics, x = ~date, y = ~unemploy, name = &quot;unemploy&quot;) %&gt;% add_lines() p2 &lt;- plot_ly(economics, x = ~date, y = ~uempmed, name = &quot;uempmed&quot;) %&gt;% add_lines() subplot(p1, p2) Although subplot() accepts an arbitrary number of plot objects, passing a list of plots can save typing and redundant code when dealing with a large number of plots. To demonstrate, let’s create one time series for each variable in the economics dataset and share the x-axis so that zoom/pan events are synchronized across each series: vars &lt;- setdiff(names(economics), &quot;date&quot;) plots &lt;- lapply(vars, function(var) { plot_ly(economics, x = ~date, y = as.formula(paste0(&quot;~&quot;, var)), name = var) %&gt;% add_lines() }) subplot(plots, nrows = length(plots), shareX = TRUE, titleX = FALSE) Figure 3.1: Five different economic variables on different y scales and a common x scale. Zoom and pan events in the x-direction are synchronized across plots. A plotly subplot is a single plotly graph with multiple traces anchored on different axes. If you pre-specify an axis ID for each trace, subplot() will respect that ID. Figure 3.2 uses this fact in correspondence with the fact that mapping a discrete variable to color creates one trace per value. In addition to providing more control over trace placement, this provides a convenient way to control coloring (we could have symbol/linetype to acheive the same effect). economics %&gt;% tidyr::gather(variable, value, -date) %&gt;% transform(id = as.integer(factor(variable))) %&gt;% plot_ly(x = ~date, y = ~value, color = ~variable, colors = &quot;Dark2&quot;, yaxis = ~paste0(&quot;y&quot;, id)) %&gt;% add_lines() %&gt;% subplot(nrows = 5, shareX = TRUE) Figure 3.2: Pre-populating y axis IDs. Conceptually, subplot() provides a way to place a collection of plots into a table with a given number of rows and columns. The number of rows (and, by consequence, the number of columns) is specified via the nrows argument. By default each row/column shares an equal proportion of the overall height/width, but as shown in the diagram below, that default can be changed via the heights and widths arguments. This flexibility is quite useful for a number of visualizations, for example, a joint density plot (the new heatmaply package is another good example). x &lt;- rnorm(100) y &lt;- rnorm(100) s &lt;- subplot( plot_ly(x = x, type = &quot;histogram&quot;, color = I(&quot;black&quot;)), plotly_empty(), plot_ly(x = x, y = y, color = I(&quot;black&quot;)), plot_ly(y = y, color = I(&quot;black&quot;)), nrows = 2, heights = c(0.2, 0.8), widths = c(0.8, 0.2), shareX = TRUE, shareY = TRUE, titleX = FALSE, titleY = FALSE ) layout(s, showlegend = FALSE) Note that, since subplot() returns a plotly object, any layout attribute can be modified downstream via layout(). "],
["recursive-subplots.html", "3.1 Recursive subplots", " 3.1 Recursive subplots The subplot() function is designed to work recursively so that you can have subplots of subplots. This idea is useful when your desired layout doesn’t conform to the table structure described in the previous section. In fact, you can think of a subplot of subplots like a spreadsheet with merged cells. plotList &lt;- function(nplots) { lapply(seq_len(nplots), function(x) plot_ly()) } s1 &lt;- subplot(plotList(6), nrows = 2, shareX = TRUE, shareY = TRUE) s2 &lt;- subplot(plotList(2), shareY = TRUE) subplot(s1, s2, plot_ly(), nrows = 3, margin = 0.04, heights = c(0.6, 0.3, 0.1)) The concept is particularly useful when you want plot(s) in a given row to have different widths from plot(s) in another row. # specify some map projection/options g &lt;- list( scope = &#39;usa&#39;, projection = list(type = &#39;albers usa&#39;), lakecolor = toRGB(&#39;white&#39;) ) # create a map of population density density &lt;- state.x77[, &quot;Population&quot;] / state.x77[, &quot;Area&quot;] map &lt;- plot_geo(z = ~density, text = state.name, locations = state.abb, locationmode = &#39;USA-states&#39;) %&gt;% layout(geo = g) # create a bunch of horizontal bar charts vars &lt;- colnames(state.x77) barcharts &lt;- lapply(vars, function(var) { plot_ly(x = state.x77[, var], y = state.name) %&gt;% add_bars(orientation = &quot;h&quot;, name = var) %&gt;% layout(showlegend = FALSE, hovermode = &quot;y&quot;, yaxis = list(showticklabels = FALSE)) }) subplot( subplot(barcharts, margin = 0.01), map, nrows = 2, heights = c(0.3, 0.7) ) "],
["ggplot2-subplots.html", "3.2 ggplot2 subplots", " 3.2 ggplot2 subplots The subplot() function also understands ggplot2 objects, and converts them to an interactive web-based version via ggplotly() before arranging them in the final layout. e &lt;- tidyr::gather(economics, variable, value, -date) gg1 &lt;- ggplot(e, aes(date, value)) + geom_line() + facet_wrap(~variable, scales = &quot;free_y&quot;, ncol = 1) gg2 &lt;- ggplot(e, aes(factor(1), value)) + geom_violin() + facet_wrap(~variable, scales = &quot;free_y&quot;, ncol = 1) + theme(axis.text = element_blank(), axis.ticks = element_blank()) subplot(gg1, gg2) %&gt;% layout(margin = list(l = 50)) -->"],
["animating-views.html", "4 Animating views", " 4 Animating views The code is this section is still under development and is likely to change. To run any of the code you see in this section, you’ll need this developmental version of the package: devtools::install_github(“ropensci/plotly#741”) Both plot_ly() and ggplotly() understand a frame aesthetic. data(gapminder, package = &quot;gapminder&quot;) p &lt;- ggplot(gapminder, aes(gdpPercap, lifeExp, size = pop, color = continent, frame = year)) + geom_point() + scale_x_log10() ggplotly(p) IDEAS: * Grand tour * Demonstrate high variance in density estimation via binning (i.e., same data and different anchor points for the bins can result in very different values for the binned frequencies) "],
["multiple-linked-views.html", "5 Multiple linked views", " 5 Multiple linked views The code is this section is still under development and is likely to change. To run any of the code you see in this section, you’ll need this developmental version of the package: devtools::install_github(“ropensci/plotly#554”) Multiple linked views is a concept that has existed in many forms within the statistical graphics and information visualization community for many years (Becker and Cleveland 1987); (Cook and Swayne 2007); (Ahlberg, Williamson, and Shneiderman 1997). Cook, Buja, and Swayne (2007) provides nice motivation for and definition of multiple linked views: Multiple linked views are the optimal framework for posing queries about data. A user should be able to pose a query graphically, and a computer should be able to present the response graphically as well. Both query and response should occur in the same visual field. This calls for a mechanism that links the graphical query to the graphical response. A graphical user interface that has such linking mechanisms is an implementation of the notion of “multiple linked views.” There are a number of R packages that provide a graphics rendering toolkits with built-in support for multiple linked views. Some are implemented as desktop applications (Wickham et al. 2008); (Yihui Xie 2013); (Urbanek 2011); (Waddell and Oldford 2015) while others are within a web-based environment (T. D. Hocking, VanderPlas, and Sievert 2015); (Chang and Wickham 2016); (Hafen and Continuum Analytics, Inc. 2016). In addition to being easier to share, the advantage of using web-based option(s) is that we can link views across different systems. To date, the most versatile tool for linking arbitrary views in R is shiny (Chang et al. 2016), which provides a reactive programming framework for authoring web applications powered by R. Linking views with shiny explains how to access plotly events on a shiny server, and informing related views about the events. Although shiny apps provide a tremendous amount of flexibility when linking views, deploying and sharing shiny apps is way more complicated than a standalone HTML file. When you print a plotly object (or any object built on top of the htmlwidgets (Vaidyanathan et al. 2016) infrastructure) it produces a standalone HTML file with some interactivity baked into it. The plotly package is unique in the sense that you can link multiple views without shiny in three different ways: inside the same plotly object, link multiple plotly objects, or even link to other htmlwidget packages such as leaflet (Cheng and Xie 2016). Furthermore, since plotly.js has some built-in support for performing statistical summaries, in some cases, we can produce aggregated views of selected data. Linking views without shiny explains this framework in detail through a series of examples. Before exploring the two different approaches for linking views, it can be useful to understand a bit about how interactive graphics systems work, in general. Andreas Buja and McDonald (1988) and Wickham et al. (2010) discuss the fundamental elements that all interactive graphics systems must possess – the most important being the concept of a data-plot-pipeline. As Wickham et al. (2010) states: “A pipeline controls the transformation from data to graphical objects on our screens”. Most, if not all, of the software discussed in this work describes systems implemented as desktop applications, where the pipeline resides on a single machine. While this is convenient for developers, it impedes the user’s ability to share their work with others. Figure 5.1 provides a simple visual depiction of the two options available when implementing the pipeline within a web-based environment. Linking views without shiny explores cases where the pipeline resides entirely within a client’s web-browser, without any calls to a seperate process. This is highly desirable because visualizations are then easily shared and viewed from a single file, without any software requirements (besides a web browser). On the other hand, it is a restrictive environment for statistical computing since we can not directly leverage R’s computational facilities.11 On other words, whenever the pipeline involves re-computing a statistical model, or performing a complicated aggregation, I suggest linking views with shiny. Figure 5.1: A visual depiction of the different approaches to implementing a pipeline in a web-based environment. The R package shiny exposes the pipeline to users in R, which requires a web server for viewing. The R package crosstalk will allow developers to implement and expose the pipeline on both the server and client levels. If the number of possible selection states is small, it may be possible to pre-compute all possible (statistical) results, and navigate them without recomputing on the fly. TODO: provide an example!!↩ "],
["linking-views-with-shiny.html", "5.1 Linking views with shiny", " 5.1 Linking views with shiny 5.1.1 Accessing events in shiny The plotly.js library emits custom events when a user interacts directly with a graph. The event_data() function provides a mechanism for accessing the data corresponding to those events within a shiny app. The shiny app in Figure 5.2 is designed to demonstrate the most useful plotly events one may access via event_data(): mouse hover (&quot;plotly_hover&quot;), click (&quot;plotly_click&quot;), and click+drag (&quot;plotly_selected&quot;). All of these events return selections on the data scale, not on a pixel scale, which is useful for updating views. There are currently four different modes for click+drag interactions in plotly.js, but only two will trigger a &quot;plotly_selected&quot; event: rectangular and lasso selection. The other two dragmodes, zoom and pan, both emit a &quot;plotly_relayout&quot; event which could be useful for say, providing global context in relation to a zoom event and/or recomputing a model based on new x/y limits. In Figure 5.2, the default click+drag mode was set to rectangular selection set via the dragmode attribute, but the mode can also be changed interactively via the mode bar at the top of the graph. The video in Figure 5.2 helps demonstrate how different user events cause different blocks of code to be evaluated on the R server.12 Conceptually, you can think of events as different inputs that becomes invalidated when the event is triggered by plotly.js. Moreover, similar to restrictions placed on references to input value(s) in shiny, event_data() has to be called within a reactive expressions. As RStudio’s lesson on reactive expressions points out: A reactive expression is an R expression that uses widget input [(e.g., event_data())] and returns a value. Any of the render*() functions in shiny turn a regular R expression into a reactive expression. In Figure 5.2, every use of event_data() appears within renderPrint() since we only need to display the result of the event on the user interface with verbatimTextOutput(). In the next section, we use the return result of event_data() to display more interesting and informative views of user events. Figure 5.2: A video demonstration of plotly events in shiny. The video can be accessed here 5.1.2 Updating views Obtaining data from a plotly event is easy, but updating view(s) based on the result of an event can be difficult. To start with something fairly easy, consider two scatterplots showing the same observations, but on different axes (i.e.., a subset of a scatterplot matrix). Figure 5.3 shows a linked lasso brush between two scatterplots. The main idea is that we first plot all the observations in black, then highlight the selection by adding an additional layer of selected points in red using the data returned by event_data(). In order to guarantee that we can uniquely identify observations in the event data, it is also crucial that we attach a key attribute to each observation (here the rownames of the data), which we can then use to filter the original data down to the selected observations. In Figure 5.3, I conciously update the source of the selection (the top plot) to match the visual characteristics of the target (the bottom plot). In general, whenever linking views to display graphical selection(s), matching the visual characteristics of the selection both the source and target(s) can aide interpretation, especially when using interactive graphics to present results to others. Although the update rule in Figure 5.3 is to simply layer on additional points, a full redraw is performed during the update, which can impact performance when dealing with a large amount of graphical elements.13 Figure 5.3: A video demonstration of linked brushing in a shiny app. The video can be accessed here and the code to run the example is here Since the update rule is the same for each view in Figure 5.3, we end up with a lot of redundant code that can be made more modular, as shown here. Since the only difference between the two views is the x/y variables, we can write a function that accepts x/y variables as input, and output a plotly object. Since this function outputs a plotly object, and is dependent upon event_data() (which can only be called within a reactive context), this function can only be called within a reactive context provided by the renderPlotly() function in the plotly package. Making code more modular not only makes it less reading, but it leaves you less prone to making mistakes. TODO: keep going and talk about targeting Figure 5.4: Linked brushing between a scatterplot and marginal histograms. 5.1.3 Targeting views The linked brushing example in Figure 5.3 has bi-directional communication, meaning a &quot;plotly_selected&quot; event deriving from either view, will impact the other view. In other words, each view can be either the source or target of the selection. Figure 5.5 shows a heatmap of a correlation matrix linked to a scatterplot. Figure 5.5: Clicking on a cell in a correlation matrix to view the corresponding scatterplot 5.1.4 Advanced usage of event data Could use this as an example – https://github.com/ropensci/plotly/issues/730 You can also run the example yourself using the following code – shiny::runApp(system.file(&quot;examples&quot;, &quot;plotlyEvents&quot;, package = &quot;plotly&quot;))↩ When updating a plot within a shiny app, typically↩ "],
["linking-views-without-shiny.html", "5.2 Linking views without shiny", " 5.2 Linking views without shiny 5.2.1 A motivating example library(crosstalk) library(plotly) sd &lt;- SharedData$new(txhousing, ~year) p &lt;- ggplot(sd, aes(month, median)) + geom_line(aes(group = year)) + geom_smooth(data = txhousing, method = &quot;gam&quot;) + facet_wrap(~ city) ggplotly(p) %&gt;% highlight(on = &quot;plotly_hover&quot;, defaultValues = 2015, color = &quot;red&quot;) 5.2.2 Linking to different plotly objects 5.2.3 Linking aggregated views TODO: show 06-plotly-pipeline.R example. Explain the importance of the pipeline. 5.2.4 Linking to leaflet library(plotly) library(leaflet) library(crosstalk) library(htmltools) sd &lt;- SharedData$new(quakes) p &lt;- plot_ly(sd, x = ~depth, y = ~mag) %&gt;% add_markers(alpha = 0.5) map &lt;- leaflet(sd) %&gt;% addTiles() %&gt;% addCircles() browsable(tagList(list(p, map))) 5.2.5 Custom linking via JavaScript Accessing plotly.js events in shiny is easy (for example), but shiny adds a lot of additional infrastructure that makes it hard to share your work, especially at scale. Very soon, plotly R users will have ways to perform highlighting and linked highlighting without shiny or any knowledge of HTML/JavaScript. However, if you do know some JavaScript, you can access (and respond to) plotly.js events without shiny, without having to leave the comfort of your R prompt, thanks to the onRender() function from the htmlwidgets package (Vaidyanathan et al. 2016). This function allows you to write a JavaScript function which will be invoked on the htmlwidget object after it is done rendering. This JavaScript function should have at least two arguments: (1) the DOM element containing the htmlwidget (el) and (2) the data passed from R (x). Figure 5.6 the onRender() function to send “event data” to the browser’s console upon hovering a point. library(plotly) library(htmlwidgets) plot_ly(mtcars, x = ~wt, y = ~mpg) %&gt;% onRender(&quot; function(el, x) { var gd = document.getElementById(el.id); gd.on(&#39;plotly_hover&#39;, function(pt) { console.log(&#39;hover&#39;, pt); }); } &quot;) Figure 5.6: A simple scatterplot that emits data whenever the user hovers on a point. 5.2.6 Highlighting options TODO: Talk about the convenience of having “standard” events generated across chart types. When working with something like D3, you typically have to bind to DOM elements when attaching listeners, which does not generalize well. 5.2.7 Limitations As discussed in previous chapters, plotly graphs have zoom, pan, and identification type interactions enabled by default. This chapter discusses methods that enable other types of useful interactions listed in Table 5.1. Table 5.1: A taxonomy of interaction types Technique Related Questions Examples Identification What is this point/mark? Hover for additional info Zoom &amp; pan Is there local structure that can’t be viewed globally? Click &amp; drag to alter x/y axis limits Animation How does a distribution change over time? How does a fitted model look when projected into high-dimensional space? The grand tour Linked highlighting How does the marginal/joint compare to a conditional? Linked brushing on a scatterplot matrix Filter How does this subset compare to another? What happened during this time period? Click on legend entries shiny::selectInput() / shiny::sliderInput() Currently not working with filled polygons (TODO: is this still true?) – https://github.com/plotly/plotly.js/issues/884 Currently not working with gl2d – https://github.com/plotly/plotly.js/issues/886 Currently leaflet is the only htmlwidget, with crosstalk support, that will respect non-default arguments in plotly’s highlight() function. -->"],
["references.html", "6 References", " 6 References Ahlberg, Christopher, Christopher Williamson, and Ben Shneiderman. 1997. “Dynamic Queries for Information Exploration: An Implementation and Evaluation.” ACM CHI Conference Proceedings, July, 1–8. Andreas Buja, Catherine Hurley, Daniel Asimov, and John A. McDonald. 1988. “Elements of a Viewing Pipeline for Data Analysis.” In Dynamic Graphics for Statistics, edited by William S. Cleveland and Marylyn E. McGill. Belmont, California: Wadsworth, Inc. Auguie, Baptiste. 2016. GridExtra: Miscellaneous Functions for “Grid” Graphics. https://CRAN.R-project.org/package=gridExtra. Bache, Stefan Milton, and Hadley Wickham. 2014. Magrittr: A Forward-Pipe Operator for R. https://CRAN.R-project.org/package=magrittr. Becker, RA, and WS Cleveland. 1987. “Brushing Scatterplots.” Technometrics 29 (2): 127–42. Bostock, Jeffrey Heer AND Michael. 2010. “Crowdsourcing Graphical Perception: Using Mechanical Turk to Assess Visualization Design.” In ACM Human Factors in Computing Systems (Chi), 203–12. http://vis.stanford.edu/papers/crowdsourcing-graphical-perception. Chang, Winston, and Hadley Wickham. 2016. Ggvis: Interactive Grammar of Graphics. https://CRAN.R-project.org/package=ggvis. Chang, Winston, Joe Cheng, JJ Allaire, Yihui Xie, and Jonathan McPherson. 2016. Shiny: Web Application Framework for R. https://CRAN.R-project.org/package=shiny. Cheng, Joe, and Yihui Xie. 2016. Leaflet: Create Interactive Web Maps with the Javascript ’Leaflet’ Library. http://rstudio.github.io/leaflet/. Cleveland, William S, and Robert McGill. 1984. “Graphical Perception: Theory, Experimentation, and Application to the Development of Graphical Methods.” Journal of the American Statistical Association 79 (September): 531–54. Cook, Dianne, and Deborah F. Swayne. 2007. Interactive and Dynamic Graphics for Data Analysis : With R and Ggobi. Use R ! New York: Springer. http://www.ggobi.org/book/. Cook, Dianne, Andreas Buja, and Deborah F Swayne. 2007. “Interactive High-Dimensional Data Visualization.” Journal of Computational and Graphical Statistics, December, 1–23. Data Science, Berkeley Institute for. 2016. “Mpl Colormaps.” http://web.archive.org/web/20160601125258/http://bids.github.io/colormap/. de Jong, Jos, and Kenton Russell. 2016. Listviewer: ’Htmlwidget’ for Interactive Views of R Lists. https://github.com/timelyportfolio/listviewer. Emerson, John W., Walton A. Green, Barret Schloerke, Jason Crowley, Dianne Cook, Heike Hofmann, and Hadley Wickham. 2013. “The Generalized Pairs Plot.” Journal of Computational and Graphical Statistics 22 (1): 79–91. doi:10.1080/10618600.2012.694762. Few, Stephen. 2006. “Data Visualization: Rules for Encoding Values in Graph.” https://web.archive.org/web/20160404214629/http://www.perceptualedge.com/articles/b-eye/encoding_values_in_graph.pdf. Freedman, D., and P. Diaconis. 1981. “On the Histogram as a Density Estimator: L_2 Theory.” Zeitschrift Für Wahrscheinlichkeitstheorie Und Verwandte Gebiete 57: 453–76. Garnier, Simon. 2016. ViridisLite: Default Color Maps from ’Matplotlib’ (Lite Version). https://CRAN.R-project.org/package=viridisLite. Hafen, Ryan, and Continuum Analytics, Inc. 2016. Rbokeh: R Interface for Bokeh. https://CRAN.R-project.org/package=rbokeh. Hocking, Toby Dylan, Susan VanderPlas, and Carson Sievert. 2015. Animint: Interactive Animations. Hyndman, Rob J. n.d. Forecast: Forecasting Functions for Time Series and Linear Models. http://github.com/robjhyndman/forecast. Jeppson, Haley, Heike Hofmann, and Di Cook. n.d. Ggmosaic: Mosaic Plots in the ’Ggplot2’ Framework. http://github.com/haleyjeppson/ggmosaic. Lander, Jared P. 2016. Coefplot: Plots Coefficients from Fitted Models. https://CRAN.R-project.org/package=coefplot. Messing, Solomon. 2012. “Visualization Series: Insight from Cleveland and Tufte on Plotting Numeric Data by Groups.” http://web.archive.org/web/20160602202734/https://solomonmessing.wordpress.com/2012/03/04/visualization-series-insight-from-cleveland-and-tufte-on-plotting-numeric-data-by-groups/. Mildenberger, Thoralf, Yves Rozenholc, and David Zasada. 2009. Histogram: Construction of Regular and Irregular Histograms with Different Options for Automatic Choice of Bins. https://CRAN.R-project.org/package=histogram. Neuwirth, Erich. 2014. RColorBrewer: ColorBrewer Palettes. https://CRAN.R-project.org/package=RColorBrewer. R Core Team. 2016. R: A Language and Environment for Statistical Computing. Vienna, Austria: R Foundation for Statistical Computing. https://www.R-project.org/. Richard A. Becker, Ming-Jen Shyu, William S. Cleveland. 1996. “The Visual Design and Control of Trellis Display.” Journal of Computational and Graphical Statistics 5 (2). [American Statistical Association, Taylor &amp; Francis, Ltd., Institute of Mathematical Statistics, Interface Foundation of America]: 123–55. http://www.jstor.org/stable/1390777. Robinson, David. 2016. Broom: Convert Statistical Analysis Objects into Tidy Data Frames. https://CRAN.R-project.org/package=broom. Ryan, Jeffrey A. 2016. Quantmod: Quantitative Financial Modelling Framework. https://CRAN.R-project.org/package=quantmod. Sarkar, Deepayan. 2008. Lattice: Multivariate Data Visualization with R. New York: Springer. http://lmdvr.r-forge.r-project.org. Schloerke, Barret, Jason Crowley, Di Cook, Francois Briatte, Moritz Marbach, Edwin Thoen, Amos Elberg, and Joseph Larmarange. 2016. GGally: Extension to ’Ggplot2’. Scott, David W. 1979. “On Optimal and Data-Based Histograms.” Biometrika 66: 605–10. Scott, David W. 1992. Multivariate Density Estimation: Theory, Practice, and Visualization. Wiley &amp; Sons. Sievert, Carson, Chris Parmer, Toby Hocking, Scott Chamberlain, Karthik Ram, Marianne Corvellec, and Pedro Despouy. 2016. Plotly: Create Interactive Web Graphics via ’Plotly.js’. Sturges, Herbert A. 1926. “The Choice of a Class Interval.” Journal of the American Statistical Association 21 (153): 65–66. doi:10.1080/01621459.1926.10502161. Urbanek, Simon. 2011. Acinonyx: IPlots EXtreme. http://www.rforge.net/Acinonyx/. Vaidyanathan, Ramnath, Yihui Xie, JJ Allaire, Joe Cheng, and Kenton Russell. 2016. Htmlwidgets: HTML Widgets for R. https://CRAN.R-project.org/package=htmlwidgets. Waddell, Adrian R., and R. Wayne Oldford. 2015. Loon: Interactive Statistical Visualization. http://www.uwaterloon.ca. Wickham, Hadley. 2009. Ggplot2: Elegant Graphics for Data Analysis. Springer-Verlag New York. http://ggplot2.org. ———. 2010. “A Layered Grammar of Graphics.” Journal of Computational and Graphical Statistics 19 (1): 3–28. ———. 2016. Tidyr: Easily Tidy Data with ‘Spread()‘ and ‘Gather()‘ Functions. https://github.com/hadley/tidyr. Wickham, Hadley, and Romain Francois. 2016. Dplyr: A Grammar of Data Manipulation. https://CRAN.R-project.org/package=dplyr. Wickham, Hadley, Michael Lawrence, Dianne Cook, Andreas Buja, Heike Hofmann, and Deborah F Swayne. 2010. “The Plumbing of Interactive Graphics.” Computational Statistics, April, 1–7. Wickham, Hadley, Michael Lawrence, Duncan Temple Lang, and Deborah F Swayne. 2008. “An Introduction to Rggobi.” R-News 8 (2): 3–7. http://CRAN.R-project.org/doc/Rnews/Rnews_2008-2.pdf. Wilkinson, Leland. 2005. The Grammar of Graphics (Statistics and Computing). Secaucus, NJ, USA: Springer-Verlag New York, Inc. William S. Cleveland, Robert McGill, Marylyn E. McGill. 1988. “The Shape Parameter of a Two-Variable Graph.” Journal of the American Statistical Association 83 (402). [American Statistical Association, Taylor &amp; Francis, Ltd.]: 289–300. http://www.jstor.org/stable/2288843. Yihui Xie, Di Cook, Heike Hofmann. 2013. Interactive Statistical Graphics Based on Qt. "]
]
