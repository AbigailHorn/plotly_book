[
["index.html", "plotly for R Overview", " plotly for R Carson Sievert Overview This website explains and partially documents the R package plotly, a high-level interface to the open source JavaScript graphing library plotly.js (which powers plot.ly). The R package already has numerous examples and documentation on https://plot.ly/r and https://plot.ly/ggplot2, but this website provides more of a cohesive narrative to help explain fundamental concepts and recent developments. By reading from start to finish, readers new to R and plotly should be able to get up and running fairly quickly. That being said, advanced R and plotly users should still find the majority of this material useful and informative. I highly recommend copying/pasting examples into your R console, and modifying them as you read along, to aid the learning process. This work is licensed under the Creative Commons Attribution-NonCommercial-NoDerivs 3.0 United States License. "],
["installation.html", "Installation", " Installation If you have R installed, you can install the stable release of plotly by typing this in your R console: install.packages(&quot;plotly&quot;) Or you can install the development release via the devtools package: if (!require(&quot;devtools&quot;)) install.packages(&quot;devtools&quot;) devtools::install_github(&quot;ropensci/plotly&quot;) The version of the R package used to build this site is: packageVersion(&quot;plotly&quot;) #&gt; [1] &#39;4.8.0.9000&#39; "],
["get-started.html", "Get started", " Get started To ensure plotly is installed correctly, try loading the package and creating this example by pasting the code inside your R console. library(plotly) plot_ly(z = ~volcano) plotly uses the htmlwidget framework, which allows plots to work seamlessly and consistently in various contexts (e.g., R Markdown documents, shiny apps, inside RStudio, or any other R command prompt) without an internet connection. IPython/Jupyter notebook users should wrap plots with the embed_notebook() function to embed them inline inside a notebook. "],
["plot-ly-for-collaboration.html", "plot.ly for collaboration", " plot.ly for collaboration plot.ly subscribers can use the api_create() function to publish plots from R onto plotly’s web platform. This platform makes it very easy to host/share your graphs, collaborate with others, and is free to use for public graphs.1 Once a plot is hosted on your account, others may copy/fork your graph to their account (with the right permissions) using a friendly user-interface. Here is a quick demonstration of that workflow from inside RStudio: As long as you can view a plot hosted on http://plot.ly, you can bring the data behind with plot into R via the get_figure() function. This makes it easy to access and modify plots created with any plotly.js interface (e.g., Python, MATLAB, Julia, Scala, etc) from your R console. Not only is this web-based user-interface to plotly.js useful for collaborating with others, but it is also useful for completing tasks that are cumbersome to do at the command-line. For instance, annotations can be added to any plot via a point-and-click interface: If you need privacy or customer support, pricing options↩ "],
["two-approaches-one-object.html", "1 Two approaches, one object", " 1 Two approaches, one object There are two main ways to initiate a plotly object in R. The plot_ly() function transforms data into a plotly object, while the ggplotly() function transforms a ggplot object into a plotly object (Wickham 2009); (Sievert et al. 2016). Regardless of how a plotly object is created, printing it results in an interactive web-based visualization with tooltips, zooming, and panning enabled by default. The R package also has special semantics for arranging, linking, and animating plotly objects. This chapter discusses some of the philosophy behind each approach, explores some of their similarities, and explains why understanding both approaches is extremely powerful. The initial inspiration for the plot_ly() function was to support plotly.js chart types that ggplot2 doesn’t support, such as 3D surface and mesh plots. Over time, this effort snowballed into an interface to the entire plotly.js graphing library with additional abstractions inspired by the grammar of graphics (Wilkinson 2005). This newer “non-ggplot2” interface to plotly.js is currently not, and may never be, as fully featured as ggplot2. Since we can already translate a fairly large amount of ggplot objects to plotly objects, I’d rather not reinvent those same abstractions, and advance our ability to link multiple views. The next section uses a case study to introduce some of the similarities between ggplotly()/plot_ly(), introduces the concept of a data-plot-pipeline, and also demonstrates how to extend ggplotly() with functions that can modify plotly objects. References "],
["txhousing-case-study.html", "1.1 A case study of housing sales in Texas", " 1.1 A case study of housing sales in Texas The plotly package depends on ggplot2 which bundles a data set on monthly housing sales in Texan cities acquired from the TAMU real estate center. After the loading the package, the data is “lazily loaded” into your session, so you may reference it by name: library(plotly) txhousing #&gt; # A tibble: 8,602 x 9 #&gt; city year month sales volume median listings inventory date #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Abilene 2000 1 72 5380000 71400 701 6.3 2000 #&gt; 2 Abilene 2000 2 98 6505000 58700 746 6.6 2000. #&gt; 3 Abilene 2000 3 130 9285000 58100 784 6.8 2000. #&gt; 4 Abilene 2000 4 98 9730000 68600 785 6.9 2000. #&gt; 5 Abilene 2000 5 141 10590000 67300 794 6.8 2000. #&gt; 6 Abilene 2000 6 156 13910000 66900 780 6.6 2000. #&gt; # ... with 8,596 more rows In attempt to understand house price behavior over time, we could plot date on x, median on y, and group the lines connecting these x/y pairs by city. Using ggplot2, we can initiate a ggplot object with the ggplot() function which accepts a data frame and a mapping from data variables to visual aesthetics. By just initiating the object, ggplot2 won’t know how to geometrically represent the mapping until we add a layer to the plot via one of geom_*() (or stat_*()) functions (in this case, we want geom_line()). In this case, it is also a good idea to specify alpha transparency so that 5 lines plotted on top of each other appear as solid black, to help avoid overplotting. If you’re new to ggplot2, the ggplot2 cheatsheet provides a nice quick overview. The online docs or R graphics cookbook are helpful for learning by example, and the ggplot2 book provides a nice overview of the conceptual underpinnings. p &lt;- ggplot(txhousing, aes(date, median)) + geom_line(aes(group = city), alpha = 0.2) 1.1.1 The ggplotly() function Now that we have a valid ggplot2 object, p, the plotly package provides the ggplotly() function which converts a ggplot object to a plotly object. By default, it supplies the entire aesthetic mapping to the tooltip, but the tooltip argument provides a way to restrict tooltip info to a subset of that mapping. Furthermore, in cases where the statistic of a layer is something other than the identity function (e.g., geom_bin2d() and geom_hex()), relevant “intermediate” variables generated in the process are also supplied to the tooltip. This provides a nice mechanism for decoding visual aesthetics (e.g., color) used to represent a measure of interest (e.g, count/value). Figure 1.1 demonstrates tooltip functionality for a number of scenarios, and uses subplot() function from the plotly package (discussed in more detail in Arranging multiple views) to concisely display numerous interactive versions of ggplot objects. subplot( p, ggplotly(p, tooltip = &quot;city&quot;), ggplot(txhousing, aes(date, median)) + geom_bin2d(), ggplot(txhousing, aes(date, median)) + geom_hex(), nrows = 2, shareX = TRUE, shareY = TRUE, titleY = FALSE, titleX = FALSE ) Figure 1.1: Monthly median house price in the state of Texas. The top row displays the raw data (by city) and the bottom row shows 2D binning on the raw data. The binning is helpful for showing the overall trend, but hovering on the lines in the top row helps reveal more detailed information about each city. Although ggplot2 does not have a text aesthetic, the ggplotly() function recognizes this aesthetic and displays it in the tooltip by default. In addition to providing a way to supply “meta” information, it also provides a way to customize your tooltips (do this by restricting the tooltip to the text aesthetic – ggplotly(p, tooltip = “text”)) The ggplotly() function translates most things that you can do in ggplot2, but not quite everything. To help demonstrate the coverage, I’ve built a plotly version of the ggplot2 docs. This version of the docs displays the ggplotly() version of each plot in a static form (to reduce page loading time), but you can click any plot to view its interactive version. The next section demonstrates how to create plotly.js visualizations via the R package, without ggplot2, via the plot_ly() function. We’ll then leverage those concepts to extend ggplotly(). 1.1.2 The plot_ly() interface 1.1.2.1 The Layered Grammar of Graphics The cognitive framework underlying the plot_ly() interface draws inspiration from the layered grammar of graphics (Wickham 2010), but in contrast to ggplotly(), it provides a more flexible and direct interface to plotly.js. It is more direct in the sense that it doesn’t call ggplot2’s sometimes expensive plot building routines, and it is more flexible in the sense that data frames are not required, which is useful for visualizing matrices, as shown in Get Started. Although data frames are not required, using them is highly recommended, especially when constructing a plot with multiple layers or groups. When a data frame is associated with a plotly object, it allows us to manipulate the data underlying that object in the same way we would directly manipulate the data. Currently, plot_ly() borrows semantics from and provides special plotly methods for generic functions in the dplyr and tidyr packages (Wickham and Francois 2016); (Wickham 2016). Most importantly, plot_ly() recognizes and preserves groupings created with dplyr’s group_by() function. library(dplyr) tx &lt;- group_by(txhousing, city) # initiate a plotly object with date on x and median on y p &lt;- plot_ly(tx, x = ~date, y = ~median) # plotly_data() returns data associated with a plotly object plotly_data(p) #&gt; # A tibble: 8,602 x 9 #&gt; # Groups: city [46] #&gt; city year month sales volume median listings inventory date #&gt; * &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Abilene 2000 1 72 5380000 71400 701 6.3 2000 #&gt; 2 Abilene 2000 2 98 6505000 58700 746 6.6 2000. #&gt; 3 Abilene 2000 3 130 9285000 58100 784 6.8 2000. #&gt; 4 Abilene 2000 4 98 9730000 68600 785 6.9 2000. #&gt; 5 Abilene 2000 5 141 10590000 67300 794 6.8 2000. #&gt; 6 Abilene 2000 6 156 13910000 66900 780 6.6 2000. #&gt; # ... with 8,596 more rows Defining groups in this fashion ensures plot_ly() will produce at least one graphical mark per group.2 So far we’ve specified x/y attributes in the plotly object p, but we have not yet specified the geometric relation between these x/y pairs. Similar to geom_line() in ggplot2, the add_lines() function connects (a group of) x/y pairs with lines in the order of their x values, which is useful when plotting time series as shown in Figure 1.2. # add a line highlighting houston add_lines( # plots one line per city since p knows city is a grouping variable add_lines(p, alpha = 0.2, name = &quot;Texan Cities&quot;, hoverinfo = &quot;none&quot;), name = &quot;Houston&quot;, data = filter(txhousing, city == &quot;Houston&quot;) ) Figure 1.2: Monthly median house price in Houston in comparison to other Texan cities. The plotly package has a collection of add_*() functions, all of which inherit attributes defined in plot_ly(). These functions also inherit the data associated with the plotly object provided as input, unless otherwise specified with the data argument. I prefer to think about add_*() functions like a layer in ggplot2, which is slightly different, but related to a plotly.js trace. In Figure 1.2, there is a 1-to-1 correspondence between layers and traces, but add_*() functions do generate numerous traces whenever mapping a discrete variable to a visual aesthetic (e.g., color). In this case, since each call to add_lines() generates a single trace, it makes sense to name the trace, so a sensible legend entry is created. In the first layer of Figure 1.2, there is one line per city, but all these lines belong a single trace. We could have produced one trace for each line, but this is way more computationally expensive because, among other things, each trace produces a legend entry and tries to display meaningful hover information. It is much more efficient to render this layer as a single trace with missing values to differentiate groups. In fact, this is exactly how the group aesthetic is translated in ggplotly(); otherwise, layers with many groups (e.g., geom_map()) would be slow to render. 1.1.2.2 The data-plot-pipeline Since every plotly function modifies a plotly object (or the data underlying that object), we can express complex multi-layer plots as a sequence (or, more specifically, a directed acyclic graph) of data manipulations and mappings to the visual space. Moreover, plotly functions are designed to take a plotly object as input, and return a modified plotly object, making it easy to chain together operations via the pipe operator (%&gt;%) from the magrittr package (Bache and Wickham 2014). Consequently, we can re-express Figure 1.2 in a much more readable and understandable fashion. allCities &lt;- txhousing %&gt;% group_by(city) %&gt;% plot_ly(x = ~date, y = ~median) %&gt;% add_lines(alpha = 0.2, name = &quot;Texan Cities&quot;, hoverinfo = &quot;none&quot;) allCities %&gt;% filter(city == &quot;Houston&quot;) %&gt;% add_lines(name = &quot;Houston&quot;) Sometimes the directed acyclic graph property of a pipeline can be too restrictive for certain types of plots. In this example, after filtering the data down to Houston, there is no way to recover the original data inside the pipeline. The add_fun() function helps to work-around this restriction3 – it works by applying a function to the plotly object, but does not affect the data associated with the plotly object. This effectively provides a way to isolate data transformations within the pipeline4. Figure 1.3 uses this idea to highlight both Houston and San Antonio. allCities %&gt;% add_fun(function(plot) { plot %&gt;% filter(city == &quot;Houston&quot;) %&gt;% add_lines(name = &quot;Houston&quot;) }) %&gt;% add_fun(function(plot) { plot %&gt;% filter(city == &quot;San Antonio&quot;) %&gt;% add_lines(name = &quot;San Antonio&quot;) }) Figure 1.3: Monthly median house price in Houston and San Antonio in comparison to other Texan cities. It is useful to think of the function supplied to add_fun() as a “layer” function – a function that accepts a plot object as input, possibly applies a transformation to the data, and maps that data to visual objects. To make layering functions more modular, flexible, and expressive, the add_fun() allows you to pass additional arguments to a layer function. Figure 1.4 makes use of this pattern, by creating a reusable function for layering both a particular city as well as the first, second, and third quartile of median monthly house sales (by city). # reusable function for highlighting a particular city layer_city &lt;- function(plot, name) { plot %&gt;% filter(city == name) %&gt;% add_lines(name = name) } # reusable function for plotting overall median &amp; IQR layer_iqr &lt;- function(plot) { plot %&gt;% group_by(date) %&gt;% summarise( q1 = quantile(median, 0.25, na.rm = TRUE), m = median(median, na.rm = TRUE), q3 = quantile(median, 0.75, na.rm = TRUE) ) %&gt;% add_lines(y = ~m, name = &quot;median&quot;, color = I(&quot;black&quot;)) %&gt;% add_ribbons(ymin = ~q1, ymax = ~q3, name = &quot;IQR&quot;, color = I(&quot;black&quot;)) } allCities %&gt;% add_fun(layer_iqr) %&gt;% add_fun(layer_city, &quot;Houston&quot;) %&gt;% add_fun(layer_city, &quot;San Antonio&quot;) Figure 1.4: First, second, and third quartile of median monthly house price in Texas. A layering function does not have to be a data-plot-pipeline itself. Its only requirement on a layering function is that the first argument is a plot object and it returns a plot object. This provides an opportunity to say, fit a model to the plot data, extract the model components you desire, and map those components to visuals. Furthermore, since plotly’s add_*() functions don’t require a data.frame, you can supply those components directly to attributes (as long as they are well-defined), as done in Figure 1.5 via the forecast package (Hyndman, n.d.). library(forecast) layer_forecast &lt;- function(plot) { d &lt;- plotly_data(plot) series &lt;- with(d, ts(median, frequency = 12, start = c(2000, 1), end = c(2015, 7)) ) fore &lt;- forecast(ets(series), h = 48, level = c(80, 95)) plot %&gt;% add_ribbons(x = time(fore$mean), ymin = fore$lower[, 2], ymax = fore$upper[, 2], color = I(&quot;gray95&quot;), name = &quot;95% confidence&quot;, inherit = FALSE) %&gt;% add_ribbons(x = time(fore$mean), ymin = fore$lower[, 1], ymax = fore$upper[, 1], color = I(&quot;gray80&quot;), name = &quot;80% confidence&quot;, inherit = FALSE) %&gt;% add_lines(x = time(fore$mean), y = fore$mean, color = I(&quot;blue&quot;), name = &quot;prediction&quot;) } txhousing %&gt;% group_by(city) %&gt;% plot_ly(x = ~date, y = ~median) %&gt;% add_lines(alpha = 0.2, name = &quot;Texan Cities&quot;, hoverinfo = &quot;none&quot;) %&gt;% add_fun(layer_iqr) %&gt;% add_fun(layer_forecast) Figure 1.5: Layering on a 4-year forecast from a exponential smoothing state space model. In summary, the “data-plot-pipeline” is desirable for a number of reasons: (1) makes your code easier to read and understand, (2) encourages you to think of both your data and plots using a single, uniform data structure, which (3) makes it easy to combine and reuse transformations. As it turns out, we can even use these ideas when creating a plotly object via ggplotly(), as discussed in the next section Extending ggplotly(). References "],
["extending-ggplotly.html", "1.2 Extending ggplotly()", " 1.2 Extending ggplotly() 1.2.1 Customizing the layout Since the ggplotly() function returns a plotly object, we can manipulate that object in the same way that we would manipulate any other plotly object. A simple and useful application of this is to specify interaction modes, like plotly.js’ layout.dragmode for specifying the mode of click+drag events. Figure 1.6 demonstrates how the default for this attribute can be modified via the layout() function. p &lt;- ggplot(fortify(gold), aes(x, y)) + geom_line() gg &lt;- ggplotly(p) layout(gg, dragmode = &quot;pan&quot;) Figure 1.6: Customizing the dragmode of an interactive ggplot2 graph. Perhaps a more useful application is to add a range slider to the x-axis, which allows you to zoom on the x-axis, without losing the global context. This is quite useful for quickly altering the limits of your plot to achieve an optimal aspect ratio for your data (William S. Cleveland 1988), without losing the global perspective. Figure 1.7 uses the rangeslider() function to add a rangeslider to the plot. rangeslider(gg) Figure 1.7: Adding a rangeslider to an interactive ggplot2 graph. Since a single plotly object can only have one layout, modifying the layout of ggplotly() is fairly easy, but it’s trickier to add and modify layers. 1.2.2 Modifying layers As mentioned previously, ggplotly() translates each ggplot2 layer into one or more plotly.js traces. In this translation, it is forced to make a number of assumptions about trace attribute values that may or may not be appropriate for the use case. The style() function is useful in this scenario, as it provides a way to modify trace attribute values in a plotly object. Before using it, you may want to inspect the actual traces in a given plotly object using the plotly_json() function. This function uses the listviewer package to display a convenient interactive view of the JSON object sent to plotly.js (de Jong and Russell 2016). By clicking on the arrow next to the data element, you can see the traces (data) behind the plot. In this case, we have three traces: one for the geom_point() layer and two for the geom_smooth() layer. p &lt;- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point() + geom_smooth() plotly_json(p) Figure 1.8: Using listviewer to inspect the JSON representation of a plotly object. Say, for example, we’d like to display information when hovering over points, but not when hovering over the fitted values or error bounds. The ggplot2 API has no semantics for making this distinction, but this is easily done in plotly.js by setting the hoverinfo attribute to &quot;none&quot;. Since the fitted values or error bounds are contained in the second and third traces, we can hide the information on just these traces using the traces attribute in the style() function. Generally speaking, the style() function is designed modify attribute values of trace(s) within a plotly object, which is primarily useful for customizing defaults produced via ggplotly(). style(p, hoverinfo = &quot;none&quot;, traces = 2:3) Figure 1.9: Using the style() function to modify hoverinfo attribute values of a plotly object created via ggplotly() (by default, ggplotly() displays hoverinfo for all traces). In this case, the hoverinfo for a fitted line and error bounds are hidden. 1.2.3 Leveraging statistical output Since ggplotly() returns a plotly object, and plotly objects can have data attached to them, it attaches data from ggplot2 layer(s) (either before or after summary statistics have been applied). Furthermore, since each ggplot layer owns a data frame, it is useful to have some way to specify the particular layer of data of interest, which is done via the layerData argument in ggplotly(). Also, when a particular layer applies a summary statistic (e.g., geom_bin()), or applies a statistical model (e.g., geom_smooth()) to the data, it might be useful to access the output of that transformation, which is the point of the originalData argument in ggplotly(). p &lt;- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point() + geom_smooth() p %&gt;% ggplotly(layerData = 2, originalData = FALSE) %&gt;% plotly_data() #&gt; # A tibble: 80 x 13 #&gt; x y ymin ymax se PANEL group colour fill size linetype #&gt; * &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1.51 32.1 28.1 36.0 1.92 1 -1 #3366… grey… 1 1 #&gt; 2 1.56 31.7 28.2 35.2 1.72 1 -1 #3366… grey… 1 1 #&gt; 3 1.61 31.3 28.1 34.5 1.54 1 -1 #3366… grey… 1 1 #&gt; 4 1.66 30.9 28.0 33.7 1.39 1 -1 #3366… grey… 1 1 #&gt; 5 1.71 30.5 27.9 33.0 1.26 1 -1 #3366… grey… 1 1 #&gt; 6 1.76 30.0 27.7 32.4 1.16 1 -1 #3366… grey… 1 1 #&gt; # ... with 74 more rows, and 2 more variables: weight &lt;dbl&gt;, alpha &lt;dbl&gt; The data shown above is the data ggplot2 uses to actually draw the fitted values (as a line) and standard error bounds (as a ribbon). Figure 1.10 leverages this data to add additional information about the model fit; in particular, it adds a vertical lines and annotations at the x-values that are associated with the highest and lowest amount uncertainty in the fitted values. Producing a plot like this with ggplot2 would be impossible using geom_smooth() alone.5 Providing a simple visual clue like this can help combat visual misperceptions of uncertainty bands due to the sine illusion (VanderPlas and Hofmann 2015). p %&gt;% ggplotly(layerData = 2, originalData = F) %&gt;% add_fun(function(p) { p %&gt;% slice(which.max(se)) %&gt;% add_segments(x = ~x, xend = ~x, y = ~ymin, yend = ~ymax) %&gt;% add_annotations(&quot;Maximum uncertainty&quot;, ax = 60) }) %&gt;% add_fun(function(p) { p %&gt;% slice(which.min(se)) %&gt;% add_segments(x = ~x, xend = ~x, y = ~ymin, yend = ~ymax) %&gt;% add_annotations(&quot;Minimum uncertainty&quot;) }) Figure 1.10: Leveraging data associated with a geom_smooth() layer to display additional information about the model fit. In addition to leveraging output from StatSmooth, it is sometimes useful to leverage output of other statistics, especially for annotation purposes. Figure 1.11 leverages the output of StatBin to add annotations to a stacked bar chart. Annotation is primarily helpful for displaying the heights of bars in a stacked bar chart, since decoding the heights of bars is a fairly difficult perceptual task (Cleveland and McGill 1984). As result, it is much easier to compare bar heights representing the proportion of diamonds with a given clarity across various diamond cuts. p &lt;- ggplot(diamonds, aes(cut, fill = clarity)) + geom_bar(position = &quot;fill&quot;) ggplotly(p, originalData = FALSE) %&gt;% mutate(ydiff = ymax - ymin) %&gt;% add_text( x = ~x, y = ~(ymin + ymax) / 2, text = ~ifelse(ydiff &gt; 0.02, round(ydiff, 2), &quot;&quot;), showlegend = FALSE, hoverinfo = &quot;none&quot;, color = I(&quot;black&quot;), size = I(9) ) Figure 1.11: Leveraging output from StatBin to add annotations to a stacked bar chart (created via geom_bar()) which makes it easier to compare bar heights. Another useful application is labelling the levels of each piece/polygon output by StatDensity2d as shown in Figure 1.12. Note that, in this example, the add_text() layer takes advantage of ggplotly()’s ability to inherit aesthetics from the global mapping. Furthermore, since originalData is FALSE, it attaches the “built” aesthetics (i.e., the x/y positions after StatDensity2d has been applied to the raw data). p &lt;- ggplot(MASS::geyser, aes(x = waiting, y = duration)) + geom_density2d() ggplotly(p, originalData = FALSE) %&gt;% group_by(piece) %&gt;% slice(which.min(y)) %&gt;% add_text( text = ~level, size = I(9), color = I(&quot;black&quot;), hoverinfo = &quot;none&quot; ) Figure 1.12: Leveraging output from StatDensity2d to add annotations to contour levels. References "],
["the-plotly-cookbook.html", "2 The plotly cookbook", " 2 The plotly cookbook This chapter demonstrates the rendering capabilities of plot_ly() through a series of examples. The plot_ly() function provides a direct interface to plotly.js, so anything in the figure reference can be specified via plot_ly(), but this chapter will focus more on the special semantics unique to the R package that can’t be found on the figure reference. Along the way, we will touch on some best practices in visualization. "],
["scatter-traces.html", "2.1 Scatter traces", " 2.1 Scatter traces A plotly visualization is composed of one (or more) trace(s), and every trace has a type. The default trace type, “scatter”, can be used to draw a large amount of geometries, and actually powers many of the add_*() functions such as add_markers(), add_lines(), add_paths(), add_segments(), add_ribbons(), and add_polygons(). Among other things, these functions make assumptions about the mode of the scatter trace, but any valid attribute(s) listed under the scatter section of the figure reference may be used to override defaults. The plot_ly() function has a number of arguments that make it easier to scale data values to visual aesthetics (e.g., color/colors, symbol/symbols, linetype/linetypes, size/sizes). These arguments are unique to the R package and dynamically determine what objects in the figure reference to populate (e.g., marker.color vs line.color). Generally speaking, the singular form of the argument defines the domain of the scale (data) and the plural form defines the range of the scale (visuals). To make it easier to alter default visual aesthetics (e.g., change all points from blue to black), “AsIs” values (values wrapped with the I() function) are interpreted as values that already live in visual space, and thus do not need to be scaled. The next section on scatterplots explores detailed use of the color/colors, symbol/symbols, &amp; size/sizes arguments. The section on lineplots explores detailed use of the linetype/linetypes. 2.1.1 Scatterplots The scatterplot is useful for visualizing the correlation between two quantitative variables. If you supply a numeric vector for x and y in plot_ly(), it defaults to a scatterplot, but you can also be explicit about adding a layer of markers/points via the add_markers() function. A common problem with scatterplots is overplotting, meaning that there are multiple observations occupying the same (or similar) x/y locations. There are a few ways to combat overplotting including: alpha transparency, hollow symbols, and 2D density estimation. Figure 2.1 shows how alpha transparency and hollow symbols can provide an improvement over the default. subplot( plot_ly(mpg, x = ~cty, y = ~hwy, name = &quot;default&quot;), plot_ly(mpg, x = ~cty, y = ~hwy) %&gt;% add_markers(alpha = 0.2, name = &quot;alpha&quot;), plot_ly(mpg, x = ~cty, y = ~hwy) %&gt;% add_markers(symbol = I(1), name = &quot;hollow&quot;) ) Figure 2.1: Three versions of a basic scatterplot In Figure 2.1, hollow circles are specified via symbol = I(1). By default, the symbol argument (as well as the color/size/linetype arguments) assumes value(s) are “data”, which need to be mapped to a visual palette (provided by symbols). Wrapping values with the I() function notifies plot_ly() that these values should be taken “AsIs”. If you compare the result of plot(1:25, 1:25, pch = 1:25) to Figure 2.2, you’ll see that plot_ly() can translate R’s plotting characters (pch), but you can also use plotly.js’ symbol syntax, if you desire. subplot( plot_ly(x = 1:25, y = 1:25, symbol = I(1:25), name = &quot;pch&quot;), plot_ly(mpg, x = ~cty, y = ~hwy, symbol = ~cyl, symbols = 1:3, name = &quot;cyl&quot;) ) Figure 2.2: Specifying symbol in a scatterplot When mapping a numeric variable to symbol, it creates only one trace, so no legend is generated. If you do want one trace per symbol, make sure the variable you’re mapping is a factor, as Figure 2.3 demonstrates. When plotting multiple traces, the default plotly.js color scale will apply, but you can set the color of every trace generated from this layer with color = I(&quot;black&quot;), or similar. p &lt;- plot_ly(mpg, x = ~cty, y = ~hwy, alpha = 0.3) subplot( add_markers(p, symbol = ~cyl, name = &quot;A single trace&quot;), add_markers(p, symbol = ~factor(cyl), color = I(&quot;black&quot;)) ) Figure 2.3: Mapping symbol to a factor The color argument adheres to similar rules as symbol: If numeric, color produces one trace, but colorbar is also generated to aide the decoding of colors back to data values. The colorbar() function can be used to customize the appearance of this automatically generated guide. The default colorscale is viridis, a perceptually-uniform colorscale (even when converted to black-and-white), and perceivable even to those with common forms of color blindness (Data Science 2016). If discrete, color produces one trace per value, meaning a legend is generated. If an ordered factor, the default colorscale is viridis (Garnier 2016); otherwise, it is the “Set2” palette from the RColorBrewer package (Neuwirth 2014) p &lt;- plot_ly(mpg, x = ~cty, y = ~hwy, alpha = 0.5) subplot( add_markers(p, color = ~cyl, showlegend = FALSE) %&gt;% colorbar(title = &quot;Viridis&quot;), add_markers(p, color = ~factor(cyl)) ) Figure 2.4: Variations on a numeric color mapping. There are a number of ways to alter the default colorscale via the colors argument. This argument excepts: (1) a color brewer palette name (see the row names of RColorBrewer::brewer.pal.info for valid names), (2) a vector of colors to interpolate, or (3) a color interpolation function like colorRamp() or scales::colour_ramp(). Although this grants a lot of flexibility, one should be conscious of using a sequential colorscale for numeric variables (&amp; ordered factors) as shown in 2.5, and a qualitative colorscale for discrete variables as shown in 2.6. col1 &lt;- c(&quot;#132B43&quot;, &quot;#56B1F7&quot;) col2 &lt;- viridisLite::inferno(10) col3 &lt;- colorRamp(c(&quot;red&quot;, &quot;white&quot;, &quot;blue&quot;)) subplot( add_markers(p, color = ~cyl, colors = col1) %&gt;% colorbar(title = &quot;ggplot2 default&quot;), add_markers(p, color = ~cyl, colors = col2) %&gt;% colorbar(title = &quot;Inferno&quot;), add_markers(p, color = ~cyl, colors = col3) %&gt;% colorbar(title = &quot;colorRamp&quot;) ) %&gt;% hide_legend() Figure 2.5: Three variations on a numeric color mapping col1 &lt;- &quot;Pastel1&quot; col2 &lt;- colorRamp(c(&quot;red&quot;, &quot;blue&quot;)) col3 &lt;- c(`4` = &quot;red&quot;, `5` = &quot;black&quot;, `6` = &quot;blue&quot;, `8` = &quot;green&quot;) subplot( add_markers(p, color = ~factor(cyl), colors = col1), add_markers(p, color = ~factor(cyl), colors = col2), add_markers(p, color = ~factor(cyl), colors = col3) ) %&gt;% hide_legend() Figure 2.6: Three variations on a discrete color mapping For scatterplots, the size argument controls the area of markers (unless otherwise specified via sizemode), and must be a numeric variable. The sizes argument controls the minimum and maximum size of circles, in pixels: subplot( add_markers(p, size = ~cyl, name = &quot;default&quot;), add_markers(p, size = ~cyl, sizes = c(1, 500), name = &quot;custom&quot;) ) Figure 2.7: Controlling the size range via sizes (measured in pixels). 2.1.1.1 3D scatterplots To make a 3D scatterplot, just add a z attribute: plot_ly(mpg, x = ~cty, y = ~hwy, z = ~cyl) %&gt;% add_markers(color = ~cyl) Figure 2.8: A 3D scatterplot 2.1.1.2 Scatterplot matrices Scatterplot matrices can be made via plot_ly() and subplot(), but ggplotly() has a special method for translating ggmatrix objects from the GGally package to plotly objects (Schloerke et al. 2016). These objects are essentially a matrix of ggplot objects and are the underlying data structure which powers higher level functions in GGally, such as ggpairs() – a function for creating a generalized pairs plot (Emerson et al. 2013). The generalized pairs plot can be motivated as a generalization of the scatterplot matrix with support for categorical variables and different visual representations of the data powered by the grammar of graphics. Figure 2.9 shows an interactive version of the generalized pairs plot made via ggpairs() and ggplotly(). In Linking views without shiny, we explore how this framework can be extended to enable linked brushing in the generalized pairs plot. pm &lt;- GGally::ggpairs(iris) ggplotly(pm) Figure 2.9: An interactive version of the generalized pairs plot made via the ggpairs() function from the GGally package 2.1.2 Dotplots &amp; error bars A dotplot is similar to a scatterplot, except instead of two numeric axes, one is categorical. The usual goal of a dotplot is to compare value(s) on a numerical scale over numerous categories. In this context, dotplots are preferable to pie charts since comparing position along a common scale is much easier than comparing angle or area (Cleveland and McGill 1984); (Bostock 2010). Furthermore, dotplots can be preferable to bar charts, especially when comparing values within a narrow range far away from 0 (Few 2006). Also, when presenting point estimates, and uncertainty associated with those estimates, bar charts tend to exaggerate the difference in point estimates, and lose focus on uncertainty (Messing 2012). A popular application for dotplots (with error bars) is the so-called “coefficient plot” for visualizing the point estimates of coefficients and their standard error. The coefplot() function in the coefplot package (Lander 2016) and the ggcoef() function in the GGally both produce coefficient plots for many types of model objects in R using ggplot2, which we can translate to plotly via ggplotly(). Since these packages use points and segments to draw the coefficient plots, the hover information is not the best, and it’d be better to use error objects. Figure 2.10 uses the tidy() function from the broom package (Robinson 2016) to obtain a data frame with one row per model coefficient, and produce a coefficient plot with error bars along the x-axis. m &lt;- lm(Sepal.Length~Sepal.Width*Petal.Length*Petal.Width, data = iris) # to order categories sensibly arrange by estimate then coerce factor d &lt;- broom::tidy(m) %&gt;% arrange(desc(estimate)) %&gt;% mutate(term = factor(term, levels = term)) plot_ly(d, x = ~estimate, y = ~term) %&gt;% add_markers(error_x = ~list(value = std.error)) %&gt;% layout(margin = list(l = 200)) Figure 2.10: A coefficient plot 2.1.3 Line plots This section surveys useful applications of add_lines() and add_paths(). The only difference between these functions is that add_lines() connects x/y pairs from left to right, instead of the order in which the data appears. Both functions understand the color, linetype, and alpha attributes6, as well as groupings defined by group_by(). Figure 1.2 uses group_by() to plot one line per city in the txhousing dataset using a single trace. Since there can only be one tooltip per trace, hovering over that plot does not reveal useful information. Although plotting many traces can be computationally expensive, it is necessary in order to display better information on hover. Since the color argument produces one trace per value (if the variable (city) is discrete), hovering on Figure 2.11 reveals the top ~10 cities at a given x value. Since 46 colors is too many to perceive in a single plot, Figure 2.11 also restricts the set of possible colors to black. plot_ly(txhousing, x = ~date, y = ~median) %&gt;% add_lines(color = ~city, colors = &quot;black&quot;, alpha = 0.2) Figure 2.11: Median house sales with one trace per city. Generally speaking, it’s hard to perceive more than 8 different colors/linetypes/symbols in a given plot, so sometimes we have to filter data to use these effectively. Here we use the dplyr package to find the top 5 cities in terms of average monthly sales (top5), then effectively filter the original data to contain just these cities via semi_join(). As Figure 2.12 demonstrates, once we have the data is filtered, mapping city to color or linetype is trivial. The color palette can be altered via the colors argument, and follows the same rules as scatterplots. The linetype palette can be altered via the linetypes argument, and accepts R’s lty values or plotly.js dash values. library(dplyr) top5 &lt;- txhousing %&gt;% group_by(city) %&gt;% summarise(m = mean(sales, na.rm = TRUE)) %&gt;% arrange(desc(m)) %&gt;% top_n(5) p &lt;- semi_join(txhousing, top5, by = &quot;city&quot;) %&gt;% plot_ly(x = ~date, y = ~median) subplot( add_lines(p, color = ~city), add_lines(p, linetype = ~city), shareX = TRUE, nrows = 2 ) Figure 2.12: Using color and/or linetype to differentiate groups of lines. 2.1.3.1 Density plots In Bars &amp; histograms, we leveraged a number of algorithms in R for computing the “optimal” number of bins for a histogram, via hist(), and routing those results to add_bars(). We can leverage the density() function for computing kernel density estimates in a similar way, and routing the results to add_lines(), as is done in 2.13. kerns &lt;- c(&quot;gaussian&quot;, &quot;epanechnikov&quot;, &quot;rectangular&quot;, &quot;triangular&quot;, &quot;biweight&quot;, &quot;cosine&quot;, &quot;optcosine&quot;) p &lt;- plot_ly() for (k in kerns) { d &lt;- density(txhousing$median, kernel = k, na.rm = TRUE) p &lt;- add_lines(p, x = d$x, y = d$y, name = k) } layout(p, xaxis = list(title = &quot;Median monthly price&quot;)) Figure 2.13: Various kernel density estimates. 2.1.3.2 Parallel Coordinates One very useful, but often overlooked, visualization technique is the parallel coordinates plot. Parallel coordinates provide a way to compare values along a common (or non-aligned) positional scale(s) – the most basic of all perceptual tasks – in more than 3 dimensions (Cleveland and McGill 1984). Usually each line represents every measurement for a given row (or observation) in a data set. When measurements are on very different scales, some care must be taken, and variables must transformed to be put on a common scale. As Figure 2.14 shows, even when variables are measured on a similar scale, it can still be a informative to transform variables in different ways. iris$obs &lt;- seq_len(nrow(iris)) iris_pcp &lt;- function(transform = identity) { iris[] &lt;- purrr::map_if(iris, is.numeric, transform) tidyr::gather(iris, variable, value, -Species, -obs) %&gt;% group_by(obs) %&gt;% plot_ly(x = ~variable, y = ~value, color = ~Species) %&gt;% add_lines(alpha = 0.3) } subplot( iris_pcp(), iris_pcp(scale), iris_pcp(scales::rescale) ) %&gt;% hide_legend() Figure 2.14: Parallel coordinates plots of the Iris dataset. On the left is the raw measurements. In the middle, each variable is scaled to have mean of 0 and standard deviation of 1. On the right, each variable is scaled to have a minimum of 0 and a maximum of 1. It is also worth noting that the GGally offers a ggparcoord() function which creates parallel coordinate plots via ggplot2, which we can convert to plotly via ggplotly(). Thanks to the linked highlighting framework, parallel coordinates created in this way could be linked to lower dimensional (but sometimes higher resolution) graphics of related data to guide multi-variate data exploration. 2.1.3.3 3D paths To make a path in 3D, use add_paths() in the same way you would for a 2D path, but add a third variable z, as Figure 2.15 does. plot_ly(mpg, x = ~cty, y = ~hwy, z = ~cyl) %&gt;% add_paths(color = ~displ) Figure 2.15: A path in 3D Figure 2.16 uses add_lines() instead of add_paths() to ensure the points are connected by the x axis instead of the row ordering. plot_ly(mpg, x = ~cty, y = ~hwy, z = ~cyl) %&gt;% add_lines(color = ~displ) Figure 2.16: A 3D line plot 2.1.4 Segments The add_segments() function essentially provides a way to connect two points ((x, y) to (xend, yend)) with a line. Segments form the building blocks for many useful chart types, including candlestick charts, a popular way to visualize stock prices. Figure 2.17 uses the quantmod package (Ryan 2016) to obtain stock price data for Microsoft and plots two segments for each day: one to encode the opening/closing values, and one to encode the daily high/low. library(quantmod) msft &lt;- getSymbols(&quot;MSFT&quot;, auto.assign = F) dat &lt;- as.data.frame(msft) dat$date &lt;- index(msft) dat &lt;- subset(dat, date &gt;= &quot;2016-01-01&quot;) names(dat) &lt;- sub(&quot;^MSFT\\\\.&quot;, &quot;&quot;, names(dat)) plot_ly(dat, x = ~date, xend = ~date, color = ~Close &gt; Open, colors = c(&quot;red&quot;, &quot;forestgreen&quot;), hoverinfo = &quot;none&quot;) %&gt;% add_segments(y = ~Low, yend = ~High, size = I(1)) %&gt;% add_segments(y = ~Open, yend = ~Close, size = I(3)) %&gt;% layout(showlegend = FALSE, yaxis = list(title = &quot;Price&quot;)) %&gt;% rangeslider() Figure 2.17: A candlestick chart 2.1.5 Ribbons Ribbons are useful for showing uncertainty bounds as a function of x. The add_ribbons() function creates ribbons and requires the arguments: x, ymin, and ymax. The augment() function from the broom package appends observational-level model components (e.g., fitted values stored as a new column .fitted) which is useful for extracting those components in a convenient form for visualization. Figure 2.18 shows the fitted values and uncertainty bounds from a linear model object. m &lt;- lm(mpg ~ wt, data = mtcars) broom::augment(m) %&gt;% plot_ly(x = ~wt, showlegend = FALSE) %&gt;% add_markers(y = ~mpg, color = I(&quot;black&quot;)) %&gt;% add_ribbons(ymin = ~.fitted - 1.96 * .se.fit, ymax = ~.fitted + 1.96 * .se.fit, color = I(&quot;gray80&quot;)) %&gt;% add_lines(y = ~.fitted, color = I(&quot;steelblue&quot;)) Figure 2.18: Plotting fitted values and uncertainty bounds of a linear model via the broom package. 2.1.6 Polygons The add_polygons() function is essentially equivalent to add_paths() with the fill attribute set to “toself”. Polygons from the basis for other, higher-level, geometries such as add_ribbons(), but can be useful in their own right. map_data(&quot;world&quot;, &quot;canada&quot;) %&gt;% group_by(group) %&gt;% plot_ly(x = ~long, y = ~lat, alpha = 0.2) %&gt;% add_polygons(hoverinfo = &quot;none&quot;, color = I(&quot;black&quot;)) %&gt;% add_markers(text = ~paste(name, &quot;&lt;br /&gt;&quot;, pop), hoverinfo = &quot;text&quot;, color = I(&quot;red&quot;), data = maps::canada.cities) %&gt;% layout(showlegend = FALSE) Figure 2.19: A map of Canada using the default cartesian coordinate system. References "],
["maps.html", "2.2 Maps", " 2.2 Maps 2.2.1 Using scatter traces As shown in polygons, it is possible to create maps using plotly’s default (Cartesian) coordinate system, but plotly.js also has support for plotting scatter traces on top of either a custom geo layout or a mapbox layout. Figure ?? compares the three different layout options in a single subplot. dat &lt;- map_data(&quot;world&quot;, &quot;canada&quot;) %&gt;% group_by(group) map1 &lt;- plot_mapbox(dat, x = ~long, y = ~lat) %&gt;% add_paths(size = I(2)) %&gt;% add_segments(x = -100, xend = -50, y = 50, 75) %&gt;% layout(mapbox = list( zoom = 0, center = list(lat = ~median(lat), lon = ~median(long)) )) # geo() is the only object type which supports different map projections map2 &lt;- plot_geo(dat, x = ~long, y = ~lat) %&gt;% add_markers(size = I(1)) %&gt;% add_segments(x = -100, xend = -50, y = 50, 75) %&gt;% layout(geo = list(projection = list(type = &quot;mercator&quot;))) map3 &lt;- plot_ly(dat, x = ~long, y = ~lat) %&gt;% add_paths(size = I(1)) %&gt;% add_segments(x = -100, xend = -50, y = 50, 75) %&gt;% layout( xaxis = list( scaleanchor = &quot;y&quot;, scaleratio = 1 ) ) htmltools::tagList(map1, map2, map3) 2.2.2 Choropleths In addition to scatter traces, plotly-geo objects also support a “native” choropleth api (i.e., plotly.js manages the geo-spatial coordinates). Figure 2.20 shows the population density of the U.S. via a choropleth, and also layers on markers for the state center locations, using the U.S. state data from the datasets package (R Core Team 2016). By simply providing a z attribute, plotly-geo objects will try to create a choropleth, but you’ll also need to provide locations and a locationmode. density &lt;- state.x77[, &quot;Population&quot;] / state.x77[, &quot;Area&quot;] g &lt;- list( scope = &#39;usa&#39;, projection = list(type = &#39;albers usa&#39;), lakecolor = toRGB(&#39;white&#39;) ) plot_geo() %&gt;% add_trace( z = ~density, text = state.name, locations = state.abb, locationmode = &#39;USA-states&#39; ) %&gt;% add_markers( x = state.center[[&quot;x&quot;]], y = state.center[[&quot;y&quot;]], size = I(2), symbol = I(8), color = I(&quot;white&quot;), hoverinfo = &quot;none&quot; ) %&gt;% layout(geo = g) Figure 2.20: A map of U.S. population density using the state.x77 data from the datasets package. Any of the add_*() functions found under scatter traces should work as expected on plotly-geo (initialized via plot_geo()) or plotly-mapbox (initialized via plot_mapbox()) objects. You can think of plot_geo() and plot_mapbox() as special cases (or more opinionated versions) of plot_ly(). For one, they won’t allow you to mix scatter and non-scatter traces in a single plot object, which you probably don’t want to do anyway. In order to enable Figure ??, plotly.js can’t make this restriction, but since we have subplot() in R, we can make this restriction without sacrificing flexibility. 2.2.3 Using geom_sf() A more flexible and perhaps intuitive way to create maps is via ggplot2’s geom_sf() which makes it easy to visualize any geo-spatial object supported by the sf package (Pebesma 2018). library(ggplot2) nc &lt;- sf::st_read(system.file(&quot;shape/nc.shp&quot;, package = &quot;sf&quot;), quiet = TRUE) p &lt;- ggplot(nc) + geom_sf(aes(fill = AREA)) ggplotly(p) The most brilliant thing about sf is that it stores geo-spatial structures in a special list-column of a data frame. This allows each row to represent the real unit of observation/interest – whether be a polygon, multi-polygon, point, line, or even a collection of these features – and as a result, supports workflows that leverage tidy-data principles. This is way more intuitive compared to older workflows based on, say using ggplot2::fortify() to obtain a data structure where a row to represents particular point along a feature and having another column track which point belongs to each feature (for example). 2.2.4 Using ggmap Since plotly has the ability to embed raster-based images, it’s also possible convert maps generated via the ggmap package (Kahle and Wickham 2013). #library(ggmap) #basemap &lt;- get_map(maptype = &quot;satellite&quot;, zoom = 8) #ggplotly(ggmap(basemap)) References "],
["bars-histograms.html", "2.3 Bars &amp; histograms", " 2.3 Bars &amp; histograms The add_bars() and add_histogram() functions wrap the bar and histogram plotly.js trace types. The main difference between them is that bar traces require bar heights (both x and y), whereas histogram traces require just a single variable, and plotly.js handles binning in the browser.7 And perhaps confusingly, both of these functions can be used to visualize the distribution of either a numeric or a discrete variable. So, essentially, the only difference between them is where the binning occurs. Figure 2.21 compares the default binning algorithm in plotly.js to a few different algorithms available in R via the hist() function. Although plotly.js has the ability to customize histogram bins via xbins/ybins, R has diverse facilities for estimating the optimal number of bins in a histogram that we can easily leverage.8 The hist() function alone allows us to reference 3 famous algorithms by name (Sturges 1926); (Freedman and Diaconis 1981); (Scott 1979), but there are also packages (e.g. the histogram package) which extend this interface to incorporate more methodology (Mildenberger, Rozenholc, and Zasada. 2009). The price_hist() function below wraps the hist() function to obtain the binning results, and map those bins to a plotly version of the histogram using add_bars(). p1 &lt;- plot_ly(diamonds, x = ~price) %&gt;% add_histogram(name = &quot;plotly.js&quot;) price_hist &lt;- function(method = &quot;FD&quot;) { h &lt;- hist(diamonds$price, breaks = method, plot = FALSE) plot_ly(x = h$mids, y = h$counts) %&gt;% add_bars(name = method) } subplot( p1, price_hist(), price_hist(&quot;Sturges&quot;), price_hist(&quot;Scott&quot;), nrows = 4, shareX = TRUE ) Figure 2.21: plotly.js’s default binning algorithm versus R’s hist() default Figure 2.22 demonstrates two ways of creating a basic bar chart. Although the visual results are the same, its worth noting the difference in implementation. The add_histogram() function sends all of the observed values to the browser and lets plotly.js perform the binning. It takes more human effort to perform the binning in R, but doing so has the benefit of sending less data, and requiring less computation work of the web browser. In this case, we have only about 50,000 records, so there is much of a difference in page load times or page size. However, with 1 Million records, page load time more than doubles and page size nearly doubles.9 p1 &lt;- plot_ly(diamonds, x = ~cut) %&gt;% add_histogram() p2 &lt;- diamonds %&gt;% dplyr::count(cut) %&gt;% plot_ly(x = ~cut, y = ~n) %&gt;% add_bars() subplot(p1, p2) %&gt;% hide_legend() Figure 2.22: Number of diamonds by cut. 2.3.1 Multiple numeric distributions It is often useful to see how the numeric distribution changes with respect to a discrete variable. When using bars to visualize multiple numeric distributions, I recommend plotting each distribution on its own axis, rather than trying to overlay them on a single axis.10. This is where the subplot() infrastructure, and its support for trellis displays, comes in handy. Figure 2.23 shows a trellis display of diamond price by diamond color. Note how the one_plot() function defines what to display on each panel, then a split-apply-recombine strategy is employed to generate the trellis display. one_plot &lt;- function(d) { plot_ly(d, x = ~price) %&gt;% add_annotations( ~unique(clarity), x = 0.5, y = 1, xref = &quot;paper&quot;, yref = &quot;paper&quot;, showarrow = FALSE ) } diamonds %&gt;% split(.$clarity) %&gt;% lapply(one_plot) %&gt;% subplot(nrows = 2, shareX = TRUE, titleX = FALSE) %&gt;% hide_legend() Figure 2.23: A trellis display of diamond price by diamond clarity. 2.3.2 Multiple discrete distributions Visualizing multiple discrete distributions is difficult. The subtle complexity is due to the fact that both counts and proportions are important for understanding multi-variate discrete distributions. Figure 2.24 presents diamond counts, divided by both their cut and clarity, using a grouped bar chart. plot_ly(diamonds, x = ~cut, color = ~clarity) %&gt;% add_histogram() Figure 2.24: A grouped bar chart Figure 2.24 is useful for comparing the number of diamonds by clarity, given a type of cut. For instance, within “Ideal” diamonds, a cut of “VS1” is most popular, “VS2” is second most popular, and “I1” the least popular. The distribution of clarity within “Ideal” diamonds seems to be fairly similar to other diamonds, but it’s hard to make this comparison using raw counts. Figure 2.25 makes this comparison easier by showing the relative frequency of diamonds by clarity, given a cut. # number of diamonds by cut and clarity (n) cc &lt;- count(diamonds, cut, clarity) # number of diamonds by cut (nn) cc2 &lt;- left_join(cc, count(cc, cut, wt = n)) cc2 %&gt;% mutate(prop = n / nn) %&gt;% plot_ly(x = ~cut, y = ~prop, color = ~clarity) %&gt;% add_bars() %&gt;% layout(barmode = &quot;stack&quot;) Figure 2.25: A stacked bar chart showing the proportion of diamond clarity within cut. This type of plot, also known as a spine plot, is a special case of a mosaic plot. In a mosaic plot, you can scale both bar widths and heights according to discrete distributions. For mosaic plots, I recommend using the ggmosaic package (Jeppson, Hofmann, and Cook 2016), which implements a custom ggplot2 geom designed for mosaic plots, which we can convert to plotly via ggplotly(). Figure ?? show a mosaic plot of cut by clarity. Notice how the bar widths are scaled proportional to the cut frequency. library(ggmosaic) p &lt;- ggplot(data = cc) + geom_mosaic(aes(weight = n, x = product(cut), fill = clarity)) ggplotly(p) References "],
["boxplots.html", "2.4 Boxplots", " 2.4 Boxplots Boxplots encode the five number summary of a numeric variable, and are more efficient than trellis displays of histograms for comparing many numeric distributions. The add_boxplot() function requires one numeric variable, and guarantees boxplots are oriented correctly, regardless of whether the numeric variable is placed on the x or y scale. As Figure 2.26 shows, on the axis orthogonal to the numeric axis, you can provide a discrete variable (for conditioning) or supply a single value (to name the axis category). p &lt;- plot_ly(diamonds, y = ~price, color = I(&quot;black&quot;), alpha = 0.1, boxpoints = &quot;suspectedoutliers&quot;) p1 &lt;- p %&gt;% add_boxplot(x = &quot;Overall&quot;) p2 &lt;- p %&gt;% add_boxplot(x = ~cut) subplot( p1, p2, shareY = TRUE, widths = c(0.2, 0.8), margin = 0 ) %&gt;% hide_legend() Figure 2.26: Overall diamond price and price by cut. If you want to partition by more than one discrete variable, I recommend mapping the interaction of those variables to the discrete axis, and coloring by the nested variable, as Figure 2.27 does with diamond clarity and cut. plot_ly(diamonds, x = ~price, y = ~interaction(clarity, cut)) %&gt;% add_boxplot(color = ~clarity) %&gt;% layout(yaxis = list(title = &quot;&quot;), margin = list(l = 100)) Figure 2.27: Diamond prices by cut and clarity. It is also helpful to sort the boxplots according to something meaningful, such as the median price. Figure 2.28 presents the same information as Figure 2.27, but sorts the boxplots by their median, and makes it immediately clear that diamonds with a cut of “SI2” have the highest diamond price, on average. d &lt;- diamonds %&gt;% mutate(cc = interaction(clarity, cut)) # interaction levels sorted by median price lvls &lt;- d %&gt;% group_by(cc) %&gt;% summarise(m = median(price)) %&gt;% arrange(m) %&gt;% .[[&quot;cc&quot;]] plot_ly(d, x = ~price, y = ~factor(cc, lvls)) %&gt;% add_boxplot(color = ~clarity) %&gt;% layout(yaxis = list(title = &quot;&quot;), margin = list(l = 100)) Figure 2.28: Diamond prices by cut and clarity, sorted by price median. Similar to add_histogram(), add_boxplot() sends the raw data to the browser, and lets plotly.js compute summary statistics. Unfortunately, plotly.js does not yet allow precomputed statistics for boxplots.11 Follow the issue here https://github.com/plotly/plotly.js/issues/242↩ "],
["d-frequencies.html", "2.5 2D frequencies", " 2.5 2D frequencies 2.5.1 Rectangular binning in plotly.js The plotly package provides two functions for displaying rectangular bins: add_heatmap() and add_histogram2d(). For numeric data, the add_heatmap() function is a 2D analog of add_bars() (bins must be pre-computed), and the add_histogram2d() function is a 2D analog of add_histogram() (bins can be computed in the browser). Thus, I recommend add_histogram2d() for exploratory purposes, since you don’t have to think about how to perform binning. It also provides a useful zsmooth attribute for effectively increasing the number of bins (currently, “best” performs a bi-linear interpolation, a type of nearest neighbors algorithm), and nbinsx/nbinsy attributes to set the number of bins in the x and/or y directions. Figure 2.29 compares three different uses of add_histogram(): (1) plotly.js’ default binning algorithm, (2) the default plus smoothing, (3) setting the number of bins in the x and y directions. Its also worth noting that filled contours, instead of bins, can be used in any of these cases by using histogram2dcontour() instead of histogram2d(). p &lt;- plot_ly(diamonds, x = ~log(carat), y = ~log(price)) subplot( add_histogram2d(p) %&gt;% colorbar(title = &quot;default&quot;) %&gt;% layout(xaxis = list(title = &quot;default&quot;)), add_histogram2d(p, zsmooth = &quot;best&quot;) %&gt;% colorbar(title = &quot;zsmooth&quot;) %&gt;% layout(xaxis = list(title = &quot;zsmooth&quot;)), add_histogram2d(p, nbinsx = 60, nbinsy = 60) %&gt;% colorbar(title = &quot;nbins&quot;) %&gt;% layout(xaxis = list(title = &quot;nbins&quot;)), shareY = TRUE, titleX = TRUE ) Figure 2.29: Three different uses of histogram2d() 2.5.2 Rectangular binning in R In Bars &amp; histograms, we leveraged a number of algorithms in R for computing the “optimal” number of bins for a histogram, via hist(), and routing those results to add_bars(). There is a surprising lack of research and computational tools for the 2D analog, and among the research that does exist, solutions usually depend on characteristics of the unknown underlying distribution, so the typical approach is to assume a Gaussian form (Scott 1992). Practically speaking, that assumption is not very useful, but 2D kernel density estimation provides a useful alternative that tends to be more robust to changes in distributional form. Although kernel density estimation requires choice of kernel and a bandwidth parameter, the kde2d() function from the MASS package provides a well-supported rule-of-thumb for estimating the bandwidth of a Gaussian kernel density (Venables and Ripley 2002). Figure 2.30 uses kde2d() to estimate a 2D density, scales the relative frequency to an absolute frequency, then uses the add_heatmap() function to display the results as a heatmap. kde_count &lt;- function(x, y, ...) { kde &lt;- MASS::kde2d(x, y, ...) df &lt;- with(kde, setNames(expand.grid(x, y), c(&quot;x&quot;, &quot;y&quot;))) # The &#39;z&#39; returned by kde2d() is a proportion, # but we can scale it to a count df$count &lt;- with(kde, c(z) * length(x) * diff(x)[1] * diff(y)[1]) data.frame(df) } kd &lt;- with(diamonds, kde_count(log(carat), log(price), n = 30)) plot_ly(kd, x = ~x, y = ~y, z = ~count) %&gt;% add_heatmap() %&gt;% colorbar(title = &quot;Number of diamonds&quot;) Figure 2.30: 2D Density estimation via the kde2d() function 2.5.3 Categorical axes The functions add_histogram(), add_histogram2contour(), and add_heatmap() all support categorical axes. Thus, add_histogram() can be used to easily display 2-way contingency tables, but since its easier to compare values along a common scale rather than compare colors (Cleveland and McGill 1984), I recommend creating grouped bar charts instead. The add_heatmap() function can still be useful for categorical axes, however, as it allows us to display whatever quantity we want along the z axis (color). Figure 2.31 uses add_heatmap() to display a correlation matrix. Notice how the limits arguments in the colorbar() function can be used to expand the limits of the color scale to reflect the range of possible correlations (something that is not easily done in plotly.js). corr &lt;- cor(diamonds[vapply(diamonds, is.numeric, logical(1))]) plot_ly(x = rownames(corr), y = colnames(corr), z = corr) %&gt;% add_heatmap() %&gt;% colorbar(limits = c(-1, 1)) Figure 2.31: Displaying a correlation matrix with add_heatmap() and controling the scale limits with colorbar(). References "],
["other-3d-plots.html", "2.6 Other 3D plots", " 2.6 Other 3D plots In scatter traces, we saw how to make 3D scatter plots and 3D paths/lines, but plotly.js also supports 3D surface and triangular mesh surfaces (aka trisurf plots). For a nice tutorial on creating trisurf plots in R via plot_ly(), I recommend visiting this tutorial. Creating 3D surfaces with add_surface() is a lot like creating heatmaps with add_heatmap(). In fact, you can even create 3D surfaces over categorical x/y (try changing add_heatmap() to add_surface() in Figure 2.31)! That being said, there should be a sensible ordering to the x/y axes in a surface plot since plotly.js interpolates z values. Usually the 3D surface is over a continuous region, as is done in Figure 2.32 to display the height of a volcano. If a numeric matrix is provided to z as in Figure 2.32, the x and y attributes do not have to be provided, but if they are, the length of x should match the number of columns in the matrix and y should match the number of rows. x &lt;- seq_len(nrow(volcano)) + 100 y &lt;- seq_len(ncol(volcano)) + 500 plot_ly() %&gt;% add_surface(x = ~x, y = ~y, z = ~volcano) Figure 2.32: A 3D surface of volcano height. "],
["raster-images.html", "2.7 Raster images", " 2.7 Raster images In R, there is native support for raster objects which encode bitmap images as essentially a matrix of color codes. m &lt;- matrix(hcl(0, 80, seq(50, 80, 10)), nrow = 4, ncol = 5) (r &lt;- as.raster(m)) #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] &quot;#C54E6D&quot; &quot;#C54E6D&quot; &quot;#C54E6D&quot; &quot;#C54E6D&quot; &quot;#C54E6D&quot; #&gt; [2,] &quot;#E16A86&quot; &quot;#E16A86&quot; &quot;#E16A86&quot; &quot;#E16A86&quot; &quot;#E16A86&quot; #&gt; [3,] &quot;#FE86A1&quot; &quot;#FE86A1&quot; &quot;#FE86A1&quot; &quot;#FE86A1&quot; &quot;#FE86A1&quot; #&gt; [4,] &quot;#FFA2BC&quot; &quot;#FFA2BC&quot; &quot;#FFA2BC&quot; &quot;#FFA2BC&quot; &quot;#FFA2BC&quot; plot(r) The raster2uri() function converts raster objects to a data URI, so they can be easily embedded via plotly’s image API: plot_ly() %&gt;% layout(images = list( source = raster2uri(r), # converts a raster object to a data URI. xref = &quot;x&quot;, yref = &quot;y&quot;, x = 0, y = 0, sizex = 1, sizey = 1, sizing = &quot;stretch&quot;, xanchor = &quot;left&quot;, yanchor = &quot;bottom&quot; )) Figure 2.33: A simple raster object displayed as an image For more examples of the image API, see https://plot.ly/r/logos/ "],
["whats-a-data-view.html", "3 What’s a data view?", " 3 What’s a data view? The term ‘view’ is used throughout subsequent sections of this book, so here we take a moment to frame its use in a wider context. This term is often used in interactive statistical graphics literature, and Wills (2008) puts it quite nicely, “a ‘data view’ can be though of as anything that gives the user a way of examining data so as to gain insight and understanding. A data view is usually thought of as a barchart, scatterplot, or other traditional statistical graphic, but we use the term more generally, including ‘views’ such as the results of a regression analysis, a neural net prediction, or a set of descriptive statistics”. In this book, more often than not, the term ‘view’ typically refers to a statistical graphic. In fact, Section 5.1 is all about linking multiple graphics together through a graphical database querying framework. However, many of the concepts covered can be applied more generally to any ‘view’, especially Section 6 since the reactive programming framework that shiny provides is agnostic towards the type of view that one is linking. References "],
["arranging-multiple-views.html", "4 Arranging multiple views", " 4 Arranging multiple views One technique essential to high-dimensional data analysis is the ability to arrange multiple views. Ideally, these views are linked in some way to foster comparisons (the next chapter discusses linking techniques). The next section, Arranging htmlwidgets describes techniques for arranging htmlwidget objects, which many R packages for creating web-based data visualizations build upon, including plotly. Typically interactivity is isolated within an htmlwidget object, but Linking views without shiny explores some more recent work on enabling interactivity across htmlwidget objects. The following section, Subplots describes the subplot() function, which is useful for merging multiple plotly objects into a single htmlwidget object. The main benefit of merging (rather than arranging) plotly objects is that it gives us the ability to synchronize zoom and pan events across multiple axes. The last section, Navigating many views discusses some useful tools for restricting focus on interesting views when there are more views than you can possibly digest visually. "],
["arranging-htmlwidgets.html", "4.1 Arranging htmlwidgets", " 4.1 Arranging htmlwidgets Since plotly objects inherit properties from an htmlwidget object, any method that works for arranging htmlwidgets also works for plotly objects. In some sense, an htmlwidget object is just a collection of HTML tags, and the htmltools package provides some useful functions for working with HTML tags (RStudio and Inc. 2016). The tagList() function gathers multiple HTML tags into a tag list, and when printing a tag list inside of a knitr/rmarkdown document (Xie 2016); (Allaire et al. 2016), it knows to render as HTML. However, when printing via the R/RStudio console, you must use browsable() to render and open the tag list as a web page (otherwise, it prints the HTML tags to your R console). Those familiar with shiny might already be familiar with using uiOutput() and/or renderUI() to dynamically render tag lists server-side. library(htmltools) library(plotly) p &lt;- plot_ly(x = rnorm(100)) # NOTE: you don&#39;t need browsable() in rmarkdown, but you do at the R prompt browsable(tagList(p, p)) Figure 4.1: Printing multiple htmlwidget objects with tagList(). To render tag lists at the command line, wrap them in browsable() Figure 4.1 renders two plots, each in its own row spanning the width of the page, because each htmlwidget object is an HTML &lt;div&gt; tag. More often than not, it is desirable to arrange multiple plots in a given row, and there are a few ways to do that. A very flexible approach is to wrap all of your plots in a flexbox (i.e., an HTML &lt;div&gt; with display: flex Cascading Style Sheets (CSS) property). The tags$div() function from htmltools provides a way to wrap a &lt;div&gt; around both tag lists and htmlwidget objects, and set attributes, such as style. As Figure 4.2 demonstrates, this approach also provides a nice way to add custom styling to the page, such as borders around each panel. tags$div( style = &quot;display: flex; flex-wrap: wrap&quot;, tags$div(p, style = &quot;width: 50%; padding: 1em; border: solid;&quot;), tags$div(p, style = &quot;width: 50%; padding: 1em; border: solid;&quot;), tags$div(p, style = &quot;width: 100%; padding: 1em; border: solid;&quot;) ) Figure 4.2: Arranging multiple htmlwidgets with flexbox Another way to arrange multiple htmlwidget objects on a single page is to leverage the fluidPage(), fluidRow(), and column() functions from the shiny package. library(shiny) fluidPage( fluidRow(p), fluidRow( column(6, p), column(6, p) ) ) Figure 4.3: Arranging multiple htmlwidgets with fluidPage() from the shiny package. All the arrangement approaches discussed thus far are agnostic to output format, meaning that they can be used to arrange htmlwidgets within any knitr/rmarkdown document.12 If the htmlwidgets do not need to be embedded within a larger document that requires an opinionated output format, the flexdashboard package provides a rmarkdown template for generating dashboards, with a convenient syntax for arranging views (Allaire 2016). References "],
["merging-plotly-objects.html", "4.2 Merging plotly objects", " 4.2 Merging plotly objects The subplot() function provides a flexible interface for merging multiple plotly objects into a single object (i.e., view). It is more flexible than most trellis display frameworks (e.g., ggplot2’s facet_wrap()) as you don’t have to condition on a value of common variable in each display (Richard A. Becker 1996). Its capabilities and interface is similar to the grid.arrange() function from the gridExtra package, which allows you to arrange multiple grid grobs in a single view, effectively providing a way to arrange (possibly unrelated) ggplot2 and/or lattice plots in a single view (R Core Team 2016); (Auguie 2016); (Sarkar 2008). Figure 4.4 shows the most simple way to use subplot() which is to directly supply plotly objects. library(plotly) p1 &lt;- plot_ly(economics, x = ~date, y = ~unemploy) %&gt;% add_lines(name = &quot;unemploy&quot;) p2 &lt;- plot_ly(economics, x = ~date, y = ~uempmed) %&gt;% add_lines(name = &quot;uempmed&quot;) subplot(p1, p2) Figure 4.4: The most basic use of subplot() to merge multiple plotly objects into a single plotly object. Although subplot() accepts an arbitrary number of plot objects, passing a list of plots can save typing and redundant code when dealing with a large number of plots. Figure 4.5 shows one time series for each variable in the economics dataset and share the x-axis so that zoom/pan events are synchronized across each series: vars &lt;- setdiff(names(economics), &quot;date&quot;) plots &lt;- lapply(vars, function(var) { plot_ly(economics, x = ~date, y = as.formula(paste0(&quot;~&quot;, var))) %&gt;% add_lines(name = var) }) subplot(plots, nrows = length(plots), shareX = TRUE, titleX = FALSE) Figure 4.5: Five different economic variables on different y scales and a common x scale. Zoom and pan events in the x-direction are synchronized across plots. A plotly subplot is a single plotly graph with multiple traces anchored on different axes. If you pre-specify an axis ID for each trace, subplot() will respect that ID. Figure 4.6 uses this fact in correspondence with the fact that mapping a discrete variable to color creates one trace per value. In addition to providing more control over trace placement, this provides a convenient way to control coloring (we could have symbol/linetype to achieve the same effect). economics %&gt;% tidyr::gather(variable, value, -date) %&gt;% transform(id = as.integer(factor(variable))) %&gt;% plot_ly(x = ~date, y = ~value, color = ~variable, colors = &quot;Dark2&quot;, yaxis = ~paste0(&quot;y&quot;, id)) %&gt;% add_lines() %&gt;% subplot(nrows = 5, shareX = TRUE) Figure 4.6: Pre-populating y axis IDs. Conceptually, subplot() provides a way to place a collection of plots into a table with a given number of rows and columns. The number of rows (and, by consequence, the number of columns) is specified via the nrows argument. By default each row/column shares an equal proportion of the overall height/width, but as shown in Figure 4.7 the default can be changed via the heights and widths arguments. Figure 4.7: A visual diagram of controling the heights of rows and widths of columns. This flexibility is quite useful for a number of visualizations, for example, as shown in Figure 4.8, a joint density plot is really of subplot of joint and marginal densities. The heatmaply package is great example of leveraging subplot() in a similar way to create interactive dendrograms (Galili 2016). x &lt;- rnorm(100) y &lt;- rnorm(100) s &lt;- subplot( plot_ly(x = x, color = I(&quot;black&quot;)), plotly_empty(), plot_ly(x = x, y = y, color = I(&quot;black&quot;)), plot_ly(y = y, color = I(&quot;black&quot;)), nrows = 2, heights = c(0.2, 0.8), widths = c(0.8, 0.2), shareX = TRUE, shareY = TRUE, titleX = FALSE, titleY = FALSE ) layout(s, showlegend = FALSE) Figure 4.8: A joint density plot with synchronized axes. 4.2.1 Recursive subplots The subplot() function returns a plotly object so it can be modified like any other plotly object. This effectively means that subplots work recursively (i.e., you can have subplots within subplots). This idea is useful when your desired layout doesn’t conform to the table structure described in the previous section. In fact, you can think of a subplot of subplots like a spreadsheet with merged cells. Figure 4.9 gives a basic example where each row of the outer-most subplot contains a different number of columns. plotList &lt;- function(nplots) { lapply(seq_len(nplots), function(x) plot_ly()) } s1 &lt;- subplot(plotList(6), nrows = 2, shareX = TRUE, shareY = TRUE) s2 &lt;- subplot(plotList(2), shareY = TRUE) subplot( s1, s2, plot_ly(), nrows = 3, margin = 0.04, heights = c(0.6, 0.3, 0.1) ) Figure 4.9: Recursive subplots. The concept is particularly useful when you want plot(s) in a given row to have different widths from plot(s) in another row. Figure 4.10 uses this recursive behavior to place many bar charts in the first row, and a single choropleth in the second row. # specify some map projection/options g &lt;- list( scope = &#39;usa&#39;, projection = list(type = &#39;albers usa&#39;), lakecolor = toRGB(&#39;white&#39;) ) # create a map of population density density &lt;- state.x77[, &quot;Population&quot;] / state.x77[, &quot;Area&quot;] map &lt;- plot_geo(z = ~density, text = state.name, locations = state.abb, locationmode = &#39;USA-states&#39;) %&gt;% layout(geo = g) # create a bunch of horizontal bar charts vars &lt;- colnames(state.x77) barcharts &lt;- lapply(vars, function(var) { plot_ly(x = state.x77[, var], y = state.name) %&gt;% add_bars(orientation = &quot;h&quot;, name = var) %&gt;% layout(showlegend = FALSE, hovermode = &quot;y&quot;, yaxis = list(showticklabels = FALSE)) }) subplot( subplot(barcharts, margin = 0.01), map, nrows = 2, heights = c(0.3, 0.7), margin = 0.1 ) Figure 4.10: Multiple bar charts of US statistics by state in a subplot with a choropleth of population density 4.2.2 ggplot2 subplots Underneath the hood, ggplot2 facets are implemented as subplots, which enables the synchronized zoom events on shared axes. Since subplots work recursively, it is also possible to have a subplot of ggplot2 faceted plots, as Figure 4.11 shows. Moreover, subplot() can understand ggplot objects, so there is no need to translate them to plotly object via ggplotly() (unless you want to leverage some of the ggplotly() arguments, such as tooltip for customizing information displayed on hover). e &lt;- tidyr::gather(economics, variable, value, -date) gg1 &lt;- ggplot(e, aes(date, value)) + geom_line() + facet_wrap(~variable, scales = &quot;free_y&quot;, ncol = 1) gg2 &lt;- ggplot(e, aes(factor(1), value)) + geom_violin() + facet_wrap(~variable, scales = &quot;free_y&quot;, ncol = 1) + theme(axis.text = element_blank(), axis.ticks = element_blank()) subplot(gg1, gg2) %&gt;% layout(margin = list(l = 50)) Figure 4.11: Arranging multiple faceted ggplot2 plots into a plotly subplot. References "],
["navigating-many-views.html", "4.3 Navigating many views", " 4.3 Navigating many views Sometimes you have to consider way more views than you can possibly digest visually. In Multiple linked views, we explore some useful techniques for implementing the popular visualization mantra from Shneiderman (1996): “Overview first, zoom and filter, then details-on-demand.” In fact, Figure 6.8 from that section provides an example of this mantra put into practice. The correlation matrix provides an overview of the correlation structure between all the variables, and by clicking a cell, it populates a scatterplot between those two specific variables. This works fine with tens or hundreds or variables, but once you have thousands or tens-of-thousands of variables, this technique begins to fall apart. At that point, you may be better off defining a range of correlations that you’re interested in exploring, or better yet, incorporating another measure (e.g., a test statistic), then focusing on views that match a certain criteria. Tukey and Tukey (n.d.) first described the idea of using quantitative measurements of scatterplot characteristics (e.g. correlation) to help guide exploratory analysis of many variables. This idea, coined scagnostics (short for scatterplot diagnostics), has since been made explicit, and many measures have been explored, even measures specifically useful for time-series have been proposed (Wilkinson, Anand, and Grossman 2005); (Wilkinson and Wills 2008); (Dang and Wilkinson 2012). Probably the most universally useful scagnostic is the outlying measure which helps identify projections of the data space that contain outlying observations. Of course, the idea of associating quantitative measures with a graphical display of data can be generalized to include more that just scatterplots, and in this more general case, these measures are sometimes referred to as cognostics. The same problems and principles that inspired scagnostics has inspired work on more general divide &amp; recombine technique(s) for working with navigating through many statistical artifacts (Cleveland and Hafen 2014); (Saptarshi Guha and Cleveland 2012), including visualizations (Hafen et al. 2013). The trelliscope package provides a system for computing arbitrary cognostics on each panel of a trellis display as well as an interactive graphical user interface for defining (and navigating through) interesting panels based on those cognostics (Hafen 2016). This system also allows users to define the graphical method for displaying each panel, so plotly graphs can easily be embedded. The trelliscope package is currently built upon shiny, but as Figure 4.12 demonstrates, the trelliscopejs package provides lower-level tools that allow one to create trelliscope displays without shiny (Hafen and Schloerke, n.d.). library(trelliscopejs) qplot(cty, hwy, data = mpg) + xlim(7, 37) + ylim(9, 47) + theme_bw() + facet_trelliscope( ~ manufacturer + class, nrow = 2, ncol = 4, as_plotly = TRUE, plotly_args = list(dynamicTicks = T) ) Figure 4.12: Using plotly within a trelliscope References "],
["linking-views-client-side.html", "5 Linking views client-side", " 5 Linking views client-side Linking of multiple data views offers a powerful approach to visualization as well as communication of structure in high-dimensional data. In particular, linking of multiple 1-2 dimensional statistical graphics can often lead to insight that a single view could not possibly reveal. For decades, statisticians and computer scientists have been using and authoring systems for multiple linked views, many of which can be found in the ASA’s video library. Some noteworthy videos include focusing and linking, missing values, and exploring Tour De France data (Swayne, Cook, and Buja 1998) (Theus and Urbanek 2008). These early systems were incredibly sophisticated, but the interactive graphics they produce are not easily shared, replicated, or incorporated in a larger document. Web technologies offer the infrastructure to address these issues, which is a big reason why many modern interactive graphics systems are web based. When talking about interactive web-based graphics, it’s important to recognize the difference between a web application and a purely client-side webpage, especially when it comes to saving, sharing, and hosting the result. A web application relies on a client-server relationship where the client’s (i.e., end user) web browser requests content from a remote server. This model is necessary whenever the webpage needs to execute computer code that is not natively supported by the client’s web browser. As Section 6 details, the flexibility that a web application framework, like shiny, offers is an incredibly productive and powerful way to link multiple data views; but when it comes to distributing a web application, it introduces a lot of complexity and computational infrastructure that may or may not be necessary. Figure 5.1 is a basic illustration of the difference between a web application and a purely client-side web page. Thanks to JavaScript and HTML5, purely client-side web pages can still be dynamic without any software dependencies besides a modern web browser. In fact, Section (graphical-queries) outlines plotly’s graphical querying framework for linking multiple plots entirely client-side, which makes the result very easy to distribute (see Section (saving)). There are, of course, many useful examples of linked and dynamic views that can not be easily expressed as a database query, but a suprising amount actually can, and the remainder can likely be quickly implemented as a shiny web application. Figure 5.1: A diagram of the graphical querying framework underlying Figure 5.7. The graphical querying framework implemented by plotly is inspired by Buja et al. (1991), where direct manipulation of graphical elements in multiple linked plots is used to perform data base queries and visually reveal high-dimensional structure in real-time. Cook, Buja, and Swayne (2007) goes on to argue this framework is preferable to posing data base queries dynamically via a menus, as described by Ahlberg, Williamson, and Shneiderman (1991), and goes on to state that “Multiple linked views are the optimal framework for posing queries about data”. The next section shows you how to implement similar graphical queries in a standalone webpage using R code. References "],
["graphical-queries.html", "5.1 Graphical queries", " 5.1 Graphical queries This section focuses on a particular approach to linking views known as graphical (database) queries using the R package plotly. With plotly, one can write R code to pose graphical queries that operate entirely client-side in a web browser (i.e., no special web server or callback to R is required). In addition to teaching you how to pose queries with the highlight_key() function, this section shows you how to control how queries are triggered and visually rendered via the highlight() function. Figure 5.2 shows a scatterplot of the relationship between weight and miles per gallon of 32 cars. It also uses highlight_key() to assign the number of cylinders to each point so that when a particular point is ‘queried’ all points with the same number of cylinders are highlighted (the number of cylinders is displayed with text just for demonstration purposes). By default, a mouse click triggers a query, and a double-click clears the query, but both of these events can be customized through the highlight() function. By typing help(highlight) in your R console, you can learn more about what events are supported for turning graphical queries on and off. library(plotly) mtcars %&gt;% highlight_key(~cyl) %&gt;% plot_ly(x = ~wt, y = ~mpg, text = ~cyl, mode = &quot;markers+text&quot;, textposition = &quot;top&quot;, hoverinfo = &quot;x+y&quot;) %&gt;% highlight(on = &quot;plotly_hover&quot;, off = &quot;plotly_doubleclick&quot;) Figure 5.2: A visual depiction of how highlight_key() attaches metadata to graphical elements to enable graphical database queries. Each point represents a different car and the number of cylinders (cyl) is assigned as metadata so that when a particular point is queried all points with the same number of cylinders are highlighted. Generally speaking, highlight_key() assigns data values to graphical marks so that when graphical mark(s) are directly manipulated through the on event, it uses the corresponding data values (call it $SELECTION_VALUE) to perform an SQL query of the following form. SELECT * FROM mtcars WHERE cyl IN $SELECTION_VALUE For a more compelling application, lets use graphical querying to explore the txhousing dataset first introduced in Section 1.1. Recall how Figure 1.3 shows Houston and San Antonio housing prices relative to other Texan cities by programmatically highlighting their time series. Instead of highlighting with code, we could allow anyone to explore prices in any city through graphical queries, as shown in Figure 5.3. One subtlety to be aware of in terms of the implementation of this graphical query is that every point along a line may have a different data value assigned to it. In this case, since the city column is used as both the visual grouping and interactive querying variable, we can query an individual time series by clicking on a point along that line. Section 5.3.1 has examples of using different grouping and querying variables to query multiple related groups of visual geometries at once, which can be a powerful technique.13 # set `city` as the SQL &#39;query by&#39; column tx &lt;- highlight_key(txhousing, ~city) # initiate a plotly object base &lt;- plot_ly(tx, color = I(&quot;black&quot;)) %&gt;% group_by(city) # create a time series of median house price time_series &lt;- base %&gt;% group_by(city) %&gt;% add_lines(x = ~date, y = ~median) # set a default query to &#39;South Padre Island&#39; which can be changed via mouse click highlight(time_series, on = &quot;plotly_click&quot;, defaultValue = &quot;South Padre Island&quot;) Figure 5.3: Graphical query of housing prices in various Texas cities. The query in this particular example must be triggered through clicking directly on a time series. Querying a city via direct manipulation is somewhat helpful for focusing on a particular time series, but it’s not so helpful for querying a city by name and/or comparing multiple cities at once. As it turns out, plotly makes it easy to add a selectize.js powered dropdown widget for querying by name (aka indirect manipulation) by setting selectize = TRUE.14 When it comes to comparing multiple cities, we want to be able to both retain previous selections (persistent = TRUE) as well as control the highlighting color (dynamic = TRUE). This videos explains how to use these features in Figure 5.4 to compare pricing across different cities. highlight(time_series, on = &quot;plotly_click&quot;, selectize = TRUE, dynamic = TRUE, persistent = TRUE) Figure 5.4: Using a selectize dropdown widget to search for cities by name and comparing multiple cities through persistent selection with a dynamic highlighting color. See this video for a demo and audio explanation. By querying a few different cities in Figure 5.4, one obvious thing we can learn is that not every city has complete pricing information (e.g., South Padre Island, San Marcos, etc). To learn more about what cities are missing information as well as how that missingness is structured, Figure 5.5 links a view of the raw time series to a dot-plot of the corresponding number of missing values per city. In addition to making it easy to see how cities rank in terms of missing house prices, it also provides a way to query the corresponding time series (i.e., reveal the structure of those missing values) by brushing cities in the dot-plot. This general pattern of linking aggregated views of the data to more detailed views fits the famous and practical information visualization advice from Shneiderman (1996): “Overview first, zoom and filter, then details on demand”. # remember, `base` is a plotly object, but we can use dplyr verbs to # manipulate the input data # (`txhousing` with `city` as a grouping and querying variable) dot_plot &lt;- base %&gt;% summarise(miss = sum(is.na(median))) %&gt;% filter(miss &gt; 0) %&gt;% add_markers(x = ~miss, y = ~forcats::fct_reorder(city, miss), hoverinfo = &quot;x+y&quot;) %&gt;% layout( xaxis = list(title = &quot;Number of months missing&quot;), yaxis = list(title = &quot;&quot;) ) subplot(dot_plot, time_series, widths = c(0.2, 0.8), titleX = TRUE) %&gt;% layout(showlegend = FALSE) %&gt;% highlight(on = &quot;plotly_selected&quot;, dynamic = TRUE, selectize = TRUE) Figure 5.5: Linking a dot-plot of the number of missing housing prices with the raw time series. By brushing markers on the dot-plot, their raw time series is highlighted on the right hand side. How does plotly know to highlight the time series when markers in the dot-plot are selected? The answer lies in what data values are embedded in the graphical markers via highlight_key(). When ‘South Padre Island’ is selected, like in Figure 5.6, it seems as though the logic says to simply change the color of any graphical elements that match that value, but the logic behind plotly’s graphical queries is a bit more subtle and powerful. Another, more accurate, framing of the logic is to first imagine a linked database query being performed behind the scenes (as in Figure 5.6). When ‘South Padre Island’ is selected, it first filters the aggregated dot-plot data down to just that one row, then it filters down the raw time-series data down to every row with ‘South Padre Island’ as a city. The drawing logic will then call Plotly.addTrace() with the newly filtered data which adds a new graphical layer representing the selection, allowing us to have finely-tuned control over the visual encoding of the data query. Figure 5.6: A diagram of the graphical querying framework underlying Figure 5.5. The biggest advantage of drawing an entirely new graphical layer with the filtered data is that it becomes easy to leverage statistical trace types for producing summaries that are conditional on the query. Figure 5.7 leverages this functionality to dynamically produce probability densities of house price in response to a query events. Section 5.3.2 has more examples of leveraging statistical trace types with graphical queries. hist &lt;- base %&gt;% add_histogram(x = ~median, histnorm = &quot;probability density&quot;) subplot(time_series, hist, nrows = 2) %&gt;% layout(barmode = &quot;overlay&quot;, showlegend = FALSE) %&gt;% highlight(dynamic = TRUE, selectize = TRUE, selected = attrs_selected(opacity = 0.3)) Figure 5.7: Linking house prices as a function of time with their probability density estimates. Another neat consequence of drawing a completely new layer is that we can control the plotly.js attributes in that layer through the selected argument of the highlight() function. In Figure 5.7 we use it to ensure the new highlighting layer has some transparency to more easily compare the city specific distribution to the overall distribution. This section is designed to help give you a foundation for leveraging graphical queries in your own work. Hopefully by now you have a rough idea what graphical queries are, how they can be useful, and how to create them with highlight_key() and highlight(). Understanding the basic idea is one thing, but applying it effectively to new problems is another thing entirely. To help spark your imagination and demonstrate what’s possible, Section 5.3 has numerous subsections each with numerous examples of graphical queries in action. References "],
["filter.html", "5.2 Highlight versus filter events", " 5.2 Highlight versus filter events Section 5.1 provides an overview of plotly’s framework for highlight events, but it also supports filter events. These events trigger slightly different logic: A highlight event dims the opacity of existing marks, then adds an additional graphical layer representing the selection. A filter event completely remove existing marks and rescales axes to the remaining data.15 Figure 5.8 provides a quick visual depiction in the difference between filter and highlight events. At least currently, filter events must be fired from filter widgets from the crosstalk package, and these widgets expect an object of class SharedData as input. As it turns out, the highlight_key() function, introduced in section 5.1, creates a SharedData instance and is essentially a wrapper for crosstalk::SharedData$new(). class(highlight_key(mtcars)) #&gt; [1] &quot;SharedData&quot; &quot;R6&quot; Figure 5.8 demonstrates the main difference in logic between filter and highlight events. Notice how, in the code implementation, the ‘querying variable’ definition for filter events is part of the filter widget. That is, city is defined as the variable of interest in filter_select(), not in the creation of tx. That is (intentionally) different from the approach for highlight events, where the ‘querying variable’ is a property of the dataset behind the graphical elements. library(crosstalk) # generally speaking, use a &quot;unique&quot; key for filter, # especially when you have multiple filters! tx &lt;- highlight_key(txhousing) gg &lt;- ggplot(tx) + geom_line(aes(date, median, group = city)) filter &lt;- bscols( filter_select(&quot;id&quot;, &quot;Select a city&quot;, tx, ~city), ggplotly(gg, dynamicTicks = TRUE), widths = c(12, 12) ) tx2 &lt;- highlight_key(txhousing, ~city, &quot;Select a city&quot;) gg &lt;- ggplot(tx2) + geom_line(aes(date, median, group = city)) select &lt;- highlight( ggplotly(gg, tooltip = &quot;city&quot;), selectize = TRUE, persistent = TRUE ) bscols(filter, select) Figure 5.8: Comparing filter to highlight events. Filter events completely remove existing marks and rescales axes to the remaining data. When using multiple filter widgets to filter the same dataset, as done in Figure 5.9, you should avoid referencing a non-unique querying variable (i.e., key-column) in the SharedData object used to populate the filter widgets. Remember that the default behavior of highlight_key() and SharedData$new() is to use the row-index (which is unique). This ensures the intersection of multiple filtering widgets queries the correct subset of data. library(crosstalk) tx &lt;- highlight_key(txhousing) widgets &lt;- bscols( widths = c(12, 12, 12), filter_select(&quot;city&quot;, &quot;Cities&quot;, tx, ~city), filter_slider(&quot;sales&quot;, &quot;Sales&quot;, tx, ~sales), filter_checkbox(&quot;year&quot;, &quot;Years&quot;, tx, ~year, inline = TRUE) ) bscols( widths = c(4, 8), widgets, plot_ly(tx, x = ~date, y = ~median, showlegend = FALSE) %&gt;% add_lines(color = ~city, colors = &quot;black&quot;) ) Cities Sales Years 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 Figure 5.9: Filtering on multiple variables. As Figure 5.10 demonstrates, filter and highlight events can work in conjunction with various htmlwidgets. In fact, since the semantics of filter are more well-defined than highlight, linking filter events across htmlwidgets via crosstalk should generally be more well-supported.16 library(leaflet) eqs &lt;- highlight_key(quakes) stations &lt;- filter_slider(&quot;station&quot;, &quot;Number of Stations&quot;, eqs, ~stations) p &lt;- plot_ly(eqs, x = ~depth, y = ~mag) %&gt;% add_markers(alpha = 0.5) %&gt;% highlight(&quot;plotly_selected&quot;) map &lt;- leaflet(eqs) %&gt;% addTiles() %&gt;% addCircles() bscols( widths = c(6, 6, 3), p, map, stations ) Figure 5.10: Linking plotly and leaflet through both filter and highlight events. When combining filter and highlight events, one (current) limitation to be aware of is that the highlighting variable has to be nested inside filter variable(s). For example, in Figure 5.11, we can filter by continent and highlight by country, but there is currently no way to highlight by contintent and filter by country. library(gapminder) g &lt;- highlight_key(gapminder, ~country) continent_filter &lt;- filter_select(&quot;filter&quot;, &quot;Select a country&quot;, g, ~continent) p &lt;- plot_ly(g) %&gt;% group_by(country) %&gt;% add_lines(x = ~year, y = ~lifeExp, color = ~continent) %&gt;% layout(xaxis = list(title = &quot;&quot;)) %&gt;% highlight(selected = attrs_selected(showlegend = FALSE)) bscols(continent_filter, p, widths = 12) Figure 5.11: Combining filtering and highlighting with non-unique querying variables When using ggplotly(), you need to specify dynamicTicks = TRUE.↩ All R packages with crosstalk support are currently listed here – https://rstudio.github.io/crosstalk/widgets.html↩ "],
["querying-examples.html", "5.3 Examples", " 5.3 Examples 5.3.1 Querying facetted charts A facetted chart, also known as a trellis or small multiples display, is an effective way to observe how a certain relationship or visual pattern changes with a discrete variable (Richard A. Becker 1996) (Tufte 2001). The implementation of a facetted chart partitions a data set into groups, then produces a graphical panel for each group using a fixed visual encoding (e.g. a scatterplot). When these groups are related in some way, it can be useful to consider linking the panels through graphical queries to reveal greater insight, especially when it comes to making comparisons both within and across multiple groups. Figure 5.12 is an example of making comparisons both within and across panels via graphical querying in a facetted chart. Each panel represents one year of English Premier League standings across time and each line represents a team (the querying variable). Since the x-axis represents the number of games within season and y-axis tracks cumulative points relative to the league average, lines with a positive slope represent above average performance and a negative slope represents below average performance. This design makes it easy to query a good (or bad) team for a particular year (via direct manipulation) to see who the team is as well as how they’ve compared to the competition in other years. In addition, the dynamic and persistent color brush allows us to query other teams to compare both within and across years. This example is shipped as a demo with the plotly package and uses data from the engsoccerdata package (Curley 2016). # By entering this demo in your R console it will print out the actual source code necessary to recreate the graphic # Also, `demo(package = &quot;plotly&quot;)` will list of all demos shipped with plotly demo(&quot;crosstalk-highlight-epl-2&quot;, package = &quot;plotly&quot;) Figure 5.12: Graphical querying in a facetted display of English Premier League standings over time. The combination of direct and indirect manipulation with the dynamic color brush makes it easy to make comparisons between good and/or bad teams relative to their known rivals. The demo above requires some fairly advanced data pre-processing, so to learn how to implement graphical queries in trellis displays, let’s work with more minimal examples. Figure 5.13 gives us yet another look at the txhousing dataset. This time we focus on just four cities and give each city it’s own panel in the trellis display by leveraging facet_wrap() from ggplot2. Within each panel, we’ll wrap the house price time series by year by putting the month on the x-axis and grouping by year. Then, to link these panels, we can ulitize year as a querying variable. As a result, not only do we have the ability to analyze annual trends within city, but we can also query specific years to compare unusual or interesting years both within and across cities. library(dplyr) txsmall &lt;- txhousing %&gt;% select(city, year, month, median) %&gt;% filter(city %in% c(&quot;Galveston&quot;, &quot;Midland&quot;, &quot;Odessa&quot;, &quot;South Padre Island&quot;)) txsmall %&gt;% highlight_key(~year) %&gt;% { ggplot(., aes(month, median, group = year)) + geom_line() + facet_wrap(~city, ncol = 2) } %&gt;% ggplotly(tooltip = &quot;year&quot;) Figure 5.13: Monthly median house prices in four Texan cities. Querying by year allows one to compare unusual or interesting years both within and across cities. Figure 5.14 displays the same information as 5.13, but shows a way to implement a linked trellis display via plot_ly() instead of ggplotly(). This approach leverages dplyr::do() to create plotly object for each city/panel, then routes that list of plots into subplot(). One nuance here is that the querying variable has to be defined within the do() statement, but everytime highlight_key() is called, it creates a crosstalk::SharedData object belonging to a new unique group, so to link these panels together the group must be set to a constant value (here we’ve set group = &quot;txhousing-trellis&quot;). txsmall %&gt;% group_by(city) %&gt;% do( p = highlight_key(., ~year, group = &quot;txhousing-trellis&quot;) %&gt;% plot_ly(showlegend = FALSE) %&gt;% group_by(year) %&gt;% add_lines( x = ~month, y = ~median, text = ~year, hoverinfo = &quot;text&quot; ) %&gt;% add_annotations( text = ~unique(city), x = 0.5, y = 1, xref = &quot;paper&quot;, yref = &quot;paper&quot;, xanchor = &quot;center&quot;, yanchor = &quot;bottom&quot;, showarrow = FALSE ) ) %&gt;% subplot(nrows = 2, margin = 0.05, shareY = TRUE, shareX = TRUE, titleY = FALSE) Figure 5.14: Using plot_ly() instead of ggplotly() to implement a linked trellis display. 5.3.2 Statistical queries 5.3.2.1 Statistical queries with plot_ly() Figure 5.7 introduced the concept of leveraging statistical trace types inside the graphical querying framework. This section gives some more examples of leveraging these trace types to dynamically produce statistical summaries of graphical queries. But first, to help understand what makes a trace “statistical”, consider the difference between add_bars() and add_histogram() (described in detail in Section 2.3). The important difference here is that add_bars() requires the bar heights to be pre-specified, whereas plotly.js does the relevant computations in add_histogram(). More generally, with a statistical trace, you provide a collection of “raw” values and plotly.js performs the statistical summaries necessary to render the graphic. As Figure 5.22 shows, sometimes you’ll want to fix certain parameters of the summary (e.g., number of bins in a histogram) to ensure the selection layer is comparable to original layer. Figure 5.15 demonstrates routing of a scatterplot brushing event to two different statistical trace types: add_boxplot() and add_histogram(). Here we’ve selected all cars with 4 cylinders to show that cylinders appears to have a significant impact on miles per gallon for pickups and sport utility vehicles, but the interactive graphic allows us to query any subset of cars. Often times, with scatterplot brushing, it’s desirable to have the row index inform the SQL query (i.e., have a 1-to-1 mapping between a row of data and the marker encoding that row). This happens to be the default behavior of highlight_key() – if no data variable is specified, then it automatically uses the row index as the querying variable. demo(&quot;crosstalk-highlight-binned-target-a&quot;, package = &quot;plotly&quot;) Figure 5.15: Linking a (jittered) dotplot of engine displacement by number of cylinders with boxplots of miles per gallon split by class and a bar chart of Dynamic 2-way ANOVA. When using a statistical trace type with graphical queries, it’s often desirable to set the querying variable as the row index. That’s because, with a statistical trace, numerous data values are attached to each graphical mark; and in that case, it’s most intuitive if each value queries just one observation. Figure 5.16 gives a simple example of linking a (dynamic) bar chart with a scatterplot in this way to allow us to query interesting regions of the data space defined by engine displacement (disp), miles per gallon highway (hwy), and the class of car (class). Notice how selections can derive from either view, and since we’ve specified &quot;plotly_selected&quot; as the on event, either rectangular or lasso selections can be used to trigger the query. d &lt;- highlight_key(mpg) base &lt;- plot_ly(d, color = I(&quot;black&quot;), showlegend = FALSE) subplot( add_histogram(base, x = ~class), add_markers(base, x = ~displ, y = ~hwy) ) %&gt;% # Selections are actually additional traces, and, by default, # plotly.js will try to dodge bars placed under the same category layout(barmode = &quot;overlay&quot;, dragmode = &quot;lasso&quot;) %&gt;% highlight(&quot;plotly_selected&quot;) Figure 5.16: Linking a bar chart with a scatterplot to query interesting regions of the data space defined by engine displacement (disp), miles per gallon highway (hwy), and the class of car (class). Notice how, by using add_histogram(), the number of cars within each class is dynamically computed by plotly.js. Figure 5.17 adds two more statistical trace types to Figure 5.16 to further explore how miles per gallon highway is related to fuel type (fl) and front/rear/4 wheel drive (drv). In particular, one can effectively condition on these discrete variables to see how the other distributions respond by brushing and dragging over markers. For example, in Figure 5.17, front-wheel drive cars are highlighted in red, then 4-wheel drive cars in blue, and as a result, we can see that the main effect of going from 4 to front wheel-drive is are also large interaction effect sizes with regular and diesel fuel types. d &lt;- highlight_key(mpg) base &lt;- plot_ly(d, color = I(&quot;black&quot;), showlegend = FALSE) subplot( add_markers(base, x = ~displ, y = ~hwy), add_boxplot(base, x = ~fl, y = ~hwy) %&gt;% add_markers(x = ~fl, y = ~hwy, alpha = 0.1), add_trace(base, x = ~drv, y = ~hwy, type = &quot;violin&quot;) %&gt;% add_markers(x = ~drv, y = ~hwy, alpha = 0.1), shareY = TRUE ) %&gt;% subplot(add_histogram(base, x = ~class), nrows = 2) %&gt;% # Selections are actually additional traces, and, by default, # plotly.js will try to dodge bars placed under the same category layout(barmode = &quot;overlay&quot;) %&gt;% highlight(&quot;plotly_selected&quot;, dynamic = TRUE) Figure 5.17: Using statistical queries to perform a 2-way ANOVA on the mpg dataset. Cars with front-wheel drive are highlighted in red and 4-wheel drive highlighted in blue. The dynamically rendered boxplots by fuel type indicate significant interaction effects. 5.3.3 Statistical queries with ggplotly() Compared to plot_ly(), statistical queries (client-side) with ggplotly() are fundamentally limited. That’s because, the statistical R functions that ggplot2 relies on to generate the graphical layers can’t necessarily be recomputed with different input data in your web browser. That being said, this is really only an issue when attempting to target a ggplot2 layer with a non-identity statistic (e.g., geom_smooth(), stat_summary(), etc). In that case, one should consider linking views server-side, as covered in section 6. As Figure 5.18 demonstrates, you can still have a ggplot2 layer with a non-identity statistic serve as the source of a selection. In that case, ggplotly() will automatically attach all the input values of the querying variable into the creation of the relevant graphical object (e.g. the fitted line). That is why, in the example below, when a fitted line is hovered upon, all the points belonging to that particular group are highlighted, even when the querying variable is the row index. m &lt;- highlight_key(mpg) p &lt;- ggplot(m, aes(displ, hwy, colour = class)) + geom_point() + geom_smooth(se = FALSE, method = &quot;lm&quot;) ggplotly(p) %&gt;% highlight(&quot;plotly_hover&quot;) Figure 5.18: Engine displacement versus highway miles per gallon by class of car. The linear model for each class, as well as the individual observations, can be selected by hovering over the line of fitted values. An individual observation can also be selected by hovering over the relevant point. Figure 5.18 demonstrates highlighting in a single view when the querying variable is the row index, but the linking could also be done by matching the querying variable with the ggplot2 group of interest, as is done in Figure 5.19. This way, when a user highlights an individual point, it highlights the entire group instead of just that point. m &lt;- highlight_key(mpg, ~class) p1 &lt;- ggplot(m, aes(displ, fill = class)) + geom_density() p2 &lt;- ggplot(m, aes(displ, hwy, fill = class)) + geom_point() subplot(p1, p2) %&gt;% hide_legend() %&gt;% highlight(&quot;plotly_hover&quot;) Figure 5.19: Clicking on a density estimate to highlight all the raw observations that went into that estimate. In summary, we’ve learned numerous things about statistical queries: A statistical trace (e.g., add_histogram(), add_boxplot(), etc) can be used as both the source and target of a graphical query. When a statistical trace is the target of a graphical query, it’s often desirable to have the row index assigned as the querying variable. A ggplot2 layer can be used as the source of a graphical query, but when it is the target, non-trivial statistical functions can not be recomputed client-side. In that case, one should consider linking views server side, as covered in section 6. 5.3.4 Geo-spatial queries Section 2.2 covers several different approaches17 for rendering geo-spatial information, and each approach supports graphical querying. One clever approach is to render a 3D globe as a surface, then layer on geo-spatial data on top of that globe with a scatter3d trace. Not only is 3D a nice way to visualize geospatial data that has altitude (in addition to latitude and longitude), but it also grants the ability to interpolate color along a path. Figure 5.20 renders tropical storms paths on a 3D globe and uses color to encode the altitude of the storm at that point. Below the 3D view is a 2D view of altitude versus distance traveled. These views are linked by a graphical query where the querying variable is the storm ID. demo(&quot;sf-plotly-3D-globe&quot;, package = &quot;plotly&quot;) Figure 5.20: Linking a 3D globe with tropical storm paths to a 2D view of the storm altitude versus distance traveled. A more widely used approach to geo-spatial data visualization is to render lat/lon data on a basemap layer that updates in response to zoom events. The plot_mapbox() function from plotly does this via integration with mapbox. Figure 5.21 uses plot_mapbox() highlighting earthquakes west of Fiji to compare the relative frequency of their magnitude and number of reporting stations (to the overall relative frequency). eqs &lt;- highlight_key(quakes) # you need a mapbox API key to use plot_mapbox() # https://www.mapbox.com/signup/?route-to=https://www.mapbox.com/studio/account/tokens/ map &lt;- plot_mapbox(eqs, x = ~long, y = ~lat) %&gt;% add_markers(color = ~depth) %&gt;% layout( mapbox = list( zoom = 2, center = list(lon = ~mean(long), lat = ~mean(lat)) ) ) %&gt;% highlight(&quot;plotly_selected&quot;) # shared properties of the two histograms hist_base &lt;- plot_ly(eqs, color = I(&quot;black&quot;), histnorm = &quot;probability density&quot;) %&gt;% layout(barmode = &quot;overlay&quot;, showlegend = FALSE) %&gt;% highlight(selected = attrs_selected(opacity = 0.5)) histograms &lt;- subplot( add_histogram(hist_base, x = ~mag), add_histogram(hist_base, x = ~stations), nrows = 2, titleX = TRUE ) crosstalk::bscols(histograms, map) Figure 5.21: Querying earthquakes by location and displaying their a histogram of their magnitude and number of stations. Every 2D mapping approach in plotly (e.g., plot_mapbox(), plot_ly(), geom_sf()) has a special understanding of the simple features data structure provided by the sf package. Sievert (2018a) and Sievert (2018b) goes more in depth about simple features support in plotly and provides more examples of graphical queries and animation with simple features, but Figure 5.22 demonstrates a clever ‘trick’ to get bi-directional brushing between polygon centroids and a histogram showing a numerical summary of the polygons. The main idea is to leverage the st_centroid() function from sf to get the polygons centroids, then link those points to the histogram via highlight_key(). library(sf) nc &lt;- st_read(system.file(&quot;shape/nc.shp&quot;, package = &quot;sf&quot;), quiet = TRUE) nc_query &lt;- highlight_key(nc, group = &quot;sf-rocks&quot;) nc_centroid &lt;- highlight_key(st_centroid(nc), group = &quot;sf-rocks&quot;) map &lt;- plot_mapbox(color = I(&quot;black&quot;)) %&gt;% add_sf(data = nc) %&gt;% add_sf(data = nc_centroid) %&gt;% layout(showlegend = FALSE) %&gt;% highlight(&quot;plotly_selected&quot;, dynamic = TRUE) hist &lt;- plot_ly(color = I(&quot;black&quot;)) %&gt;% add_histogram( data = nc_query, x = ~AREA, xbins = list(start = 0, end = 0.3, size = 0.01) ) %&gt;% layout(barmode = &quot;overlay&quot;) %&gt;% highlight(&quot;plotly_selected&quot;) crosstalk::bscols(widths = 12, map, hist) Figure 5.22: Graphically querying North Carolina by location and area 5.3.5 Linking with other htmlwidgets The plotly package is able to share graphical queries with a limited set of other R packages that build upon the htmlwidgets standard. At the moment, graphical queries work best with leaflet and DT. Figure 5.23 links plotly with DT, and since the data set linked bewteen the two is an sf data frame, each row of the table is linked to a polygon on the map through the row index of the same dataset. demo(&quot;sf-dt&quot;, package = &quot;plotly&quot;) Figure 5.23: Linking a plot_ly()-based map with a datatable() from the DT package. As already shown in section 5.2, plotly can share graphical queries with leaflet. Some of the more advanced features (e.g., persistent selection with dynamic color brush) are not yet officially supported, but you can still leverage these experimental features by installing the experimental versions of leaflet referenced in the code below. For example, in Figure 5.24, persistent selection with dynamic colors allows one to first highlight earthquakes with a magnitude of 5 or higher in red, then earthquakes with a magnitude of 4.5 or lower, and the corresponding earthquakes are highlighted in the leaflet map. This reveals an interesting relationship in magnitude and geographic location, and leaflet provides the ability to zoom and pan on the map to investigate regions that have a high density of quakes. # requires an experimental version of leaflet # devtools::install_github(&quot;rstudio/leaflet#346&quot;) library(leaflet) qquery &lt;- highlight_key(quakes) p &lt;- plot_ly(qquery, x = ~depth, y = ~mag) %&gt;% add_markers(alpha = 0.5) %&gt;% highlight(&quot;plotly_selected&quot;, dynamic = TRUE) map &lt;- leaflet(qquery) %&gt;% addTiles() %&gt;% addCircles() # persistent selection can be specified via options() withr::with_options( list(persistent = TRUE), crosstalk::bscols(widths = c(6, 6), p, map) ) Figure 5.24: Linking views between plotly and leaflet to explore the relation between magnitude and geographic location of earthquakes around Fiji. The video may be accessed here Figure 5.25 uses another experimental feature of querying leaflet polygons in response to direct manipulation of a plotly graph. # requires an experimental version of leaflet # devtools::install_github(&quot;rstudio/leaflet#391&quot;) library(leaflet) library(sf) nc &lt;- system.file(&quot;shape/nc.shp&quot;, package = &quot;sf&quot;) %&gt;% st_read() %&gt;% st_transform(4326) %&gt;% highlight_key() map &lt;- leaflet(nc) %&gt;% addTiles() %&gt;% addPolygons( opacity = 1, color = &#39;white&#39;, weight = .25, fillOpacity = .5, fillColor = &#39;blue&#39;, smoothFactor = 0 ) p &lt;- plot_ly(nc) %&gt;% add_markers(x = ~BIR74, y = ~SID79) %&gt;% layout(dragmode = &quot;lasso&quot;) %&gt;% highlight(&quot;plotly_selected&quot;) crosstalk::bscols(map, p) Figure 5.25: Querying polygons on a leaflet map in response to direct manipulation of a plotly graph. 5.3.6 Generalized pairs plots Section 2.1.1.2 introduced the generalized pairs plot made via GGally::ggpairs() which, like ggplot(), partially supports graphical queries. The brushing in Figure 5.26 demonstrates how the scatterplots can respond to a graphical queries (allowing us to see how these relationships behave in specific subsections of the data space), but for the same reasons outlined in 5.3.3, the statistical summaries (e.g., the density plots and correlations) don’t respond to the graphical query. highlight_key(iris) %&gt;% GGally::ggpairs(aes(color = Species), columns = 1:4) %&gt;% ggplotly() %&gt;% highlight(&quot;plotly_selected&quot;) Figure 5.26: Brushing a scatterplot matrix via the ggpairs() function in the GGally package. A video demonstrating the graphical queries can be viewed here 5.3.7 Querying diagnostic plots In addition to the ggpairs() function for generalized pairs plots, the GGally packages also has a ggnostic() function which generates a matrix of diagnostic plots from a model object using ggplot2. Each column of this matrix represents a different explanatory variable and each row represents a different diagnostic measure. Figure 5.27 shows the default display for a linear model, which includes residuals (resid), estimates of residual standard deviation when a particular observation is excluded (sigma), diagonals from the projection matrix (hat), and cooks distance (cooksd). library(dplyr) library(GGally) mtcars %&gt;% # for better tick labels mutate(am = recode(am, `0` = &quot;automatic&quot;, `1` = &quot;manual&quot;)) %&gt;% lm(mpg ~ wt + qsec + am, data = .) %&gt;% ggnostic(mapping = aes(color = am)) %&gt;% ggplotly() Figure 5.27: Graphical queries applied to multiple diagnostic plots of a linear model. The ggplotly() function has a special method for ggnostic() that adds graphical queries automatically with support for both individual observations (e.g. points) as well as meaningful groups (e.g., automatic vs manual). Injecting interactivity into ggnostic() via ggplotly() enhances the diagnostic plot in at least two ways. Coloring by a factor variable in the model allows us to highlight that region of the design matrix by selecting a relevant statistical summary, which can help avoid overplotting when dealing with numerous factor levels. For example, in Figure 5.27, the user first highlights diagnostics for cars with manual transmission (in blue), then cars with automatic transmission (in red). Perhaps more widely useful is the ability to highlight individual observations since most of these diagnostics are designed to identify highly influential or unusual observations. In Figure 5.27, there is one observation with a noticeably high value of cooksd, which suggests the observation has a large influence on the fitted model. Clicking on that point highlights its corresponding diagnostic measures, plotted against each explanatory variable. Doing so makes it obvious that this observation is influential since it has a unusually high response/residual in a fairly sparse region of the design space (i.e., it has a pretty high value of wt) and removing it would significantly reduce the estimated standard deviation (sigma). By comparison, the other two observations with similar values of wt have a response value very close to the overall mean, so even though their value of hat is high, their value of sigma is low. 5.3.7.1 Subset queries via list-columns All the graphical querying examples thus far use highlight_key() to attach values from atomic vector of a data frame to graphical marker(s), but what non-atomic vectors (i.e., list-columns)? When it comes to emitting events, there is no real difference – plotly will “inform the world” of a set of selection values, which is the union of all data values in the graphical query. However, as Figure 5.28 demonstrates, when plotly receives a list-column query, it will highlight graphical markers with data value(s) that are a subset of the selected values. For example, when the point [3, 3] is queried, plotly will highlight all markers that represent a subset of {A, B, C}, which is why both [1, 1] (representing the set {A}) and (2, 2) (representing the set {A, B}) are highlighted. d &lt;- tibble::tibble( x = 1:4, y = 1:4, key = lapply(1:4, function(x) LETTERS[seq_len(x)]), txt = sapply(key, function(x) sprintf(&quot;{%s}&quot;, paste(x, collapse = &quot;, &quot;))) ) highlight_key(d, ~key) %&gt;% plot_ly(x = ~x, y = ~y, text = ~txt, hoverinfo = &quot;text&quot;) %&gt;% highlight(&quot;plotly_selected&quot;) %&gt;% layout(dragmode = &quot;lasso&quot;) Figure 5.28: A simple example of subset queries via a list-column One compelling use case for subset queries is dendograms. In fact, plotly provides a plot_dendro() function for making dendrograms with support for subset queries. Figure 5.29 gives an example of brushing a branch of a dendrogram to query leafs that are similar in some sense. Any dendrogram object can be provided to plot_dendro(), but this particular example visualizes the similarity of US states in terms of their arrest statistics via a hierarchical clustering model on the USArrests dataset. hc &lt;- hclust(dist(USArrests), &quot;ave&quot;) dend1 &lt;- as.dendrogram(hc) plot_dendro(dend1, height = 600) %&gt;% hide_legend() %&gt;% highlight(&quot;plotly_selected&quot;, persistent = TRUE, dynamic = TRUE) Figure 5.29: Leveraging hierarchical selection and persistent brushing to paint branches of a dendrogram. Figure 5.30 links the dendrogram from Figure 5.29 to a map of the US and a grand tour of the arrest statistics to better understand and diagnose a hierarchical clustering methodology. By highlighting branches of the dendrogram, we can effectively choose a partitioning of the states into similar groups, and see how that model choice projects to the data space18 through a grand tour. The grand tour is a special kind of animation that interpolates between random 2D projections of numeric data allowing the viewer to perceive the shape of a high-dimensional point cloud (Asimov 1985). Note how the grouping portrayed in Figure 5.30 does a fairly good job of staying separated in the grand tour. demo(&quot;animation-tour-USArrests&quot;, package = &quot;plotly&quot;) Figure 5.30: Linking a dendrogram to a grand tour and map of the USArrests data to visualize a classification in 5 dimensions. References "],
["limitations.html", "5.4 Limitations", " 5.4 Limitations Linking of data views, as defined in Section 3, has a much larger scope than the graphical querying framework covered in this chapter. For serious statistical analysis, one often needs to link views in a way that can not be easily compiled down to client-side web technologies. For these use cases, the R package shiny makes it very easy to build on concepts we’ve already covered to build more powerful client-server applications entirely in R, without having to learn any HTML, CSS, or JavaScript. The next chapter 6 gives a brief introduction to shiny, then dives right into concepts related to linking plotly graphics to other arbitrary views. "],
["linking-server-side.html", "6 Linking views server-side", " 6 Linking views server-side Section 5.1 covers an approach to linking views client-side with graphical database queries, but not every linked data view can be reasonably framed as a database query. If you need more control, you have at least two more options: add custom JavaScript (covered in section 8.1) and/or link views server-side via a web application. Some concepts useful for the former approach are covered in 8.1, but this chapter is all about the latter approach. There are several different frameworks for creating web applications via R, but we’ll focus our attention on linking plotly graphs with shiny – an R package for creating reactive web applications entirely in R. Shiny’s reactive programming model allows R programmers to build upon their existing R knowledge and create data-driven web applications without any prior web programming experience. Shiny itself is largely agnostic to the engine used to render data views (that is, you can incorporate any sort of R output), but shiny itself also adds some special support for interacting with static R graphics and images (Chang 2017). When linking graphics in a web application, there are tradeoffs to consider when using static R plots over web-based graphics. As it turns out, those tradeoffs complement nicely with the relative strengths and weaknesses of linking views with plotly, making their combination a powerful toolkit for linking views on the web from R. Shiny itself provides a way to access events with static graphics made with any of the following R packages: graphics, ggplot2, and lattice. These pac are very mature, fully-featured, well-tested, and support a incredibly wide range of graphics. Comparatively speaking, plotly does not have the same range and history. However, interacting with static graphics can lead to a poor user experience because everytime a static graphic needs to be updated, shiny must make a round-trip to the server and regenerate an entirely new image. On the other hand, since plotly is inherently web-based, it allows for more control over how the graphics update in response to user input (e.g., change the color of a few points instead of redrawing the entire image). This idea is explored in more depth in section 6.3. This chapter teaches you how to link both static R and plotly graphics inside shiny, how to get those graphics communicating with other types of data views, and how to do it all efficiently. Section 6.1 provides an introduction to shiny it’s reactive programming model, Section 6.2 shows how to access user input to both plotly and static graphics in shiny, Section 6.3 shows how to update views based on these user input events, Section 6.4 shows how to target specific views, and Section ?? demonstrates some advanced applications. References "],
["hello-shiny.html", "6.1 Embedding plotly in shiny", " 6.1 Embedding plotly in shiny Before linking views with plotly inside shiny, let’s first talk about how to embed plotly inside a basic shiny app! Through a couple basic examples, you’ll learn the basic components of a shiny and get a feel for shiny’s reactive programming model, as well as pointers to more learning materials. 6.1.1 Your first shiny app The most common plotly+shiny pattern uses a shiny input to control a plotly output. Figure 6.1 gives a simple example of using shiny’s selectizeInput() function to create a dropdown that controls a plotly graph. This example, as well as every other shiny app, has two main parts: The user interface, ui, defines how inputs and output widgets are displayed on the page. The fluidPage() function offers a nice and quick way get a grid-based responsive layout19, but it’s also worth noting the UI is completely customizable20, and packages such as shinydashboard make it easy to leverage more sophisticated layout frameworks (Chang and Borges Ribeiro 2018). The server function, server, defines a mapping from input values to output widgets. More specifically, the shiny server is an R function() between input values on the client and outputs generated on the web server. Every input widget, including the selectizeInput() in Figure 6.1, is tied to a input value that can be accesssed on the server inside a reactive expression. Shiny’s reactive expressions build a dependency graph between outputs (aka, reactive endpoints) and inputs (aka, reactive sources). The true power of reactive expressions lies in their ability to chain together and cache computations, but let’s first focus on generating outputs. In order to generate an output, you have to choose a suitable function for rendering the result of a reactive expression. Figure 6.1 uses the renderPlotly() function to render a reactive expression that generates a plotly graph. This expression depends in the input value input$cities (i.e., the input value tied to the input widget with an inputId of &quot;cities&quot;) and stores the output as output$p. This instructs shiny to insert the reactive graph into the plotlyOutput(outputId = &quot;p&quot;) container defined in the user interface. library(shiny) library(plotly) ui &lt;- fluidPage( selectizeInput( inputId = &quot;cities&quot;, label = &quot;Select a city&quot;, choices = unique(txhousing$city), selected = &quot;Abilene&quot;, multiple = TRUE ), plotlyOutput(outputId = &quot;p&quot;) ) server &lt;- function(input, output, ...) { output$p &lt;- renderPlotly({ plot_ly(txhousing, x = ~date, y = ~median) %&gt;% filter(city %in% input$cities) %&gt;% group_by(city) %&gt;% add_lines() }) } shinyApp(ui, server) Figure 6.1: Using a shiny input widget to control which time series are shown on a plotly graph. If, instead of a plotly graph, a reactive expression generates a static R graphic, simply use renderPlot() (instead of renderPlotly()) to render it and plotOutput() (instead of plotlyOutput()) to position it. Other shiny output widgets also use this naming convention: renderDataTable()/datatableOutput(), renderPrint()/verbatimTextOutput(), renderText()/textOutput(), renderImage()/imageOutput(), etc. Packages that are built on the htmlwidgets standard (e.g. plotly and leaflet) are, in some sense, also shiny output widgets that are encouraged to follow this same naming convention (e.g. renderPlotly()/plotlyOutput() and renderLeaflet()/leafletOutput()). Shiny also comes pre-packaged with a handful of other useful input widgets. Although many shiny apps use them straight “out-of-the-box”, input widgets can easily be stylized with CSS and/or SASS, and even custom input widgets can be integrated (Mastny 2018, @shiny-custom-inputs). selectInput()/selectizeInput() for dropdown menus. numericInput() for a single number. sliderInput() for a numeric range. textInput() for a character string. dateInput() for a single date. dateRangeInput() for a range of dates. fileInput() for uploading files. checkboxInput()/checkboxGroupInput()/radioButtons() for choosing a list of options. Going forward our focus is to link multiple graphs in shiny through direct manipulation, so we focus less on using these input widgets, and more on using plotly and static R graphics as inputs to other output widgets. Section 6.2 provides an introduction to this idea, but before we learn how to access these input events, you may want to know a bit more about rendering plotly inside shiny. 6.1.2 Hiding and redrawing on resize The renderPlotly() function renders anything that the plotly_build() function understands, including plot_ly(), ggplotly(), and ggplot2 objects.21 It also renders NULL as an empty HTML div, which is handy for certain cases where it doesn’t make sense to render a graph. Figure 6.2 leverages these features to render an empty div while selectizeInput()’s placeholder is shown, but then render a plotly graph via ggplotly() once cities have been selected. Figure 6.2 also shows how to make the plotly output depend on the size of the container that holds the plotly graph. By default, when a browser is resized, the graph size is changed purely client-side, but this reactive expression will re-execute when the browser window is resized. Due to technical reasons this can improve ggplotly() resizing behavior22, but should be used with caution when handling large data and long render times. library(shiny) library(plotly) cities &lt;- unique(txhousing$city) ui &lt;- fluidPage( selectizeInput( inputId = &quot;cities&quot;, label = NULL, # placeholder prompt is triggered when first choice is an empty string choices = c(&quot;Please choose a city&quot; = &quot;&quot;, cities), multiple = TRUE ), plotlyOutput(outputId = &quot;p&quot;) ) server &lt;- function(input, output, session, ...) { output$p &lt;- renderPlotly({ req(input$cities) if (identical(input$cities, &quot;&quot;)) return(NULL) p &lt;- ggplot(data = filter(txhousing, city %in% input$cities)) + geom_line(aes(date, median, group = city)) ggplotly(p, height = session$clientData$output_p_height, width = session$clientData$output_p_width) }) } shinyApp(ui, server) Figure 6.2: Rendering a plotly graph in shiny if and only if the selectizeInput()’s dropdown is non-empty. When the graph is present, and the window is resized, then the reactive expression is re-evaluated. When a reactive expression inside renderPlotly() is re-executes, it triggers a full redraw of the plotly graph on the client. Generally speaking, this makes your shiny app logic easy to reason about, but it’s not always performant enough. For example, say you have a scatterplot with 10s of thousands of points, and you just want to add a fitted line to those points (in respond to input event)? Instead of redrawing the whole plot from scratch, it can be way more performant to partially modify/add/remove things from the plot. Techniques for this use case are covered in section ??. References "],
["shiny-inputs.html", "6.2 Using graphical output as a shiny input", " 6.2 Using graphical output as a shiny input Section 6.1 covered how to render shiny output widgets (e.g., plotlyOutput()) that depend on a input widget, but what if we want an output widget to server as an input to another output (i.e., link multiple graphs)? Generally speaking, it doesn’t always make sense to have a shiny output function like an input to another output, but there are handful of output widgets that do make this possible, including but no limited to: shiny::plotOutput(), plotly::plotlyOutput(), leaflet::leafletOutput(), and DT::dataTableOutput(). Section 6.2.1 outlines the approach for plotlyOutput() and section ?? outlines the approach for plotOutput(). 6.2.1 Accessing plotly input events The event_data() function is the most straight-forward way to access a plotly input events in shiny. Just like any other shiny input, this function needs to be used inside a reactive context and should reference a particular type of plotly input event. Most of these available events are data-specific traces (e.g., &quot;plotly_hover&quot;, &quot;plotly_click&quot;, &quot;plotly_selected&quot;, etc), but there are also some that are layout-specific (e.g., &quot;plotly_relayout&quot;). The shiny app in Figure 6.3 shows you how to access common trace events and print verbatim the corresponding data via renderPrint(). When using this event data to inform (i.e., update) another related data view, it’s often necessary to know exactly what row(s) of data were queried in the event (i.e., the x/y positions alone may not be enough to uniquely identify a piece of information). For this reason, if a key attribute is supplied through to plot_ly(), or a key aesthetic to ggplot2, that information will be relayed along with the input event. There are currently four different modes for click+drag interactions in plotly.js, but only two will trigger a &quot;plotly_selected&quot; event: rectangular and lasso selection. The other two drag modes, zoom and pan, both emit a &quot;plotly_relayout&quot; event which could be useful for, say, recomputing a model based on new x/y limits. Figure 6.3 uses dragmode attribute to set the default click+drag mode rectangular selection, but the mode can also be changed interactively via the mode bar at the top of the graph. library(shiny) library(plotly) ui &lt;- fluidPage( radioButtons(&quot;plotType&quot;, &quot;Plot Type:&quot;, choices = c(&quot;ggplotly&quot;, &quot;plotly&quot;)), plotlyOutput(&quot;plot&quot;), verbatimTextOutput(&quot;hover&quot;), verbatimTextOutput(&quot;click&quot;), verbatimTextOutput(&quot;brush&quot;) ) server &lt;- function(input, output, session) { nms &lt;- row.names(mtcars) output$plot &lt;- renderPlotly({ p &lt;- if (identical(input$plotType, &quot;ggplotly&quot;)) { ggplotly( ggplot(mtcars, aes(x = mpg, y = wt, key = nms)) + geom_point() ) } else { plot_ly(mtcars, x = ~mpg, y = ~wt, key = nms) } layout(p, dragmode = &quot;select&quot;) }) output$hover &lt;- renderPrint({ d &lt;- event_data(&quot;plotly_hover&quot;) if (is.null(d)) &quot;Hover events appear here (unhover to clear)&quot; else d }) output$click &lt;- renderPrint({ d &lt;- event_data(&quot;plotly_click&quot;) if (is.null(d)) &quot;Click events appear here (double-click to clear)&quot; else d }) output$brush &lt;- renderPrint({ d &lt;- event_data(&quot;plotly_selected&quot;) if (is.null(d)) &quot;Click and drag events (i.e., select/lasso) appear here (double-click to clear)&quot; else d }) } shinyApp(ui, server, options = list(display.mode = &quot;showcase&quot;)) Figure 6.3: A video demonstration of plotly events in shiny. The video can be accessed here The &quot;plotly_click&quot; and &quot;plotly_hover&quot; events are supported for nearly every trace type (there are currently 35 types!), but plotly_selected is generally only available for 2D charts (i.e., it won’t work for scatter3d, surface, mesh, etc.). One 2D trace type that does not support any of these events is parcoords – it’s overall design is quite different from the others in that it natively supports brushing lines along an axis dimension. However, as Figure 6.4 demonstrates, these brush events emit a plotly_restyle event with the range(s) of the highlighted dimension.23 library(plotly) library(shiny) ui &lt;- fluidPage( plotlyOutput(&quot;parcoords&quot;), verbatimTextOutput(&quot;info&quot;) ) server &lt;- function(input, output, session) { output$parcoords &lt;- renderPlotly({ plot_ly(iris) %&gt;% add_parcoords() }) output$info &lt;- renderPrint({ d &lt;- event_data(&quot;plotly_restyle&quot;) if (is.null(d)) &quot;Brush along a dimension&quot; else d }) } shinyApp(ui, server) Figure 6.4: Using the plotly_restyle event to access brushed dimensions of a parallel coordinates plot. Beyond the parcoords edge case, the plotly_restyle and plotly_relayout events can also be used to detect any changes to plotly.js traces (restyle) and layout (relayout). More specifically, these events are emitted whenever the plotly.js functions Plotly.restyle() or Plotly.relayout() are called. As shown in section ??, these functions are handy for partially modifying an existing plot (i.e., avoid performing a full redraw), and we can leverage them from R in a shiny app. As it turns out, sometimes these events are fired as a part of another, higher-order task, like dragging shapes. Figure 6.5 demonstrates dragging a circle shape and accessing the new positions of the circle though the plotly_relayout event. The ability to drag shapes can be enabled through the config() function through the edits attribute. This attribute allows you enable direct manipulation of certain aspects of the layout (note that traces can not be edited). In this case, we only want to drag shapes, but one could use config(p, editable = TRUE) to make everything in the layout editable (e.g. the plot and axis titles). library(shiny) library(plotly) ui &lt;- fluidPage( plotlyOutput(&quot;p&quot;), verbatimTextOutput(&quot;event&quot;) ) server &lt;- function(input, output, session) { output$p &lt;- renderPlotly({ plot_ly() %&gt;% layout( xaxis = list(range = c(-10, 10)), yaxis = list(range = c(-10, 10)), shapes = list( type = &quot;circle&quot;, fillcolor = &quot;gray&quot;, line = list(color = &quot;gray&quot;), x0 = -10, x1 = 10, y0 = -10, y1 = 10, xsizemode = &quot;pixel&quot;, ysizemode = &quot;pixel&quot;, xanchor = 0, yanchor = 0 ) ) %&gt;% config(edits = list(shapePosition = TRUE)) }) output$event &lt;- renderPrint({ event_data(&quot;plotly_relayout&quot;) }) } shinyApp(ui, server) Figure 6.5: Dragging a circle shape and accessing the positions in shiny via event_data('plotly_relayout') Figure 6.6 uses the ability to react to the dragging of shapes to snap a vertical line shape to the closest point in a sequence of x values. It also places on a marker at the intersection of this vertical line shape and a line chart of random y values. Notice how, by accessing event_data() in this way (i.e., the source and target view of the event is the same), the chart is actually fully redrawn every time the line shape moves. If performance were an issue (i.e., we were dealing with lots of lines), this type of interaction likely won’t be very responsive. In that case, you can use event_data() to trigger side-effects (i.e., partially modify the plot) which is covered in ??. library(shiny) library(plotly) ui &lt;- fluidPage( plotlyOutput(&quot;p&quot;), verbatimTextOutput(&quot;event&quot;) ) x &lt;- seq(-10, 10) y &lt;- rnorm(length(x)) server &lt;- function(input, output, session) { output$p &lt;- renderPlotly({ d &lt;- event_data(&quot;plotly_relayout&quot;) selected_point &lt;- if (!is.null(d[[&quot;shapes[0].x0&quot;]])) { # &#39;snap&#39; the x-position from the event to the closest `x` value xint &lt;- d[[&quot;shapes[0].x0&quot;]] xpt &lt;- x[which.min(abs(x - xint))] list(x = xpt, y = y[which(x == xpt)]) } else { # default to list(x = 1, y = y[which(x == 1)]) } plot_ly(color = I(&quot;red&quot;)) %&gt;% add_lines(x = x, y = y) %&gt;% add_markers(x = selected_point$x, y = selected_point$y) %&gt;% layout( shapes = list( type = &quot;line&quot;, line = list(color = &quot;gray&quot;, dash = &quot;dot&quot;), x0 = selected_point$x, x1 = selected_point$x, y0 = 0, y1 = 1, yref = &quot;paper&quot; ) ) %&gt;% config(editable = TRUE) }) } shinyApp(ui, server) Figure 6.6: Dragging a vertical line shape and ‘snapping’ the line to match the closest provided x value. In summary, it’s possible to access information about and react to direct manipulation events with a plotly graph through referencing event_data() in a shiny reactive expression. Section 6.3 covers how to route this sort of information from these events to other views in a shiny application. Section ?? discusses how to scope these events to specific views and section ?? and discusses helpful techniques for ensuring your shiny application is responsive as possible. For sake of comparison and to enhance the discussion, the next section discusses accessing similar events using shiny::plotOutput(). To see how to map these ranges back to the highlighted observations, see the example plotly_example(&quot;shiny&quot;, &quot;event_data_parcoords&quot;)↩ "],
["updating-views.html", "6.3 Updating views", " 6.3 Updating views TODO: rewrite and perhaps incorporate https://github.com/cpsievert/apps/blob/master/shiny/apps/plotlyAg/app.R Obtaining data from a plotly event is easy, but updating view(s) based on the result of an event can be difficult. To start with something fairly easy, consider two scatterplots showing the same observations, but on different axes (i.e., a subset of a scatterplot matrix). Figure 6.7 shows a linked lasso brush between two scatterplots. The main idea is that we first plot all the observations in black, then highlight the selection by adding an additional layer of selected points in red using the data returned by event_data(). In order to guarantee that we can uniquely identify observations in the event data, it is also crucial that we attach a key attribute to each observation (here the rownames of the data), which we can then use to filter the original data down to the selected observations. Figure 6.7 consciously updates the source of the selection (the top plot) to match the visual characteristics of the target (the bottom plot). In general, whenever linking views to display graphical selection(s), matching the visual characteristics of the selection both the source and target(s) can aide interpretation, especially when using interactive graphics to present results to others. Although the update rule in Figure 6.7 is to simply layer on additional points, a full redraw is performed during the update, which can impact performance when dealing with a large amount of graphical elements. Figure 6.7 could be made slightly more efficient by just changing the color of selected points, or dimming the non-selected points, rather than plotting an extra layer of points. However, this technique does not work for chart types that display aggregate values (e.g., how do you dim non-selected values in a box plot?). For this reason, in Linking views without shiny, selections are implemented as an additional layer, but avoid the full redraw required when updating plot via shiny reactive framework.24 Figure 6.7: A video demonstration of linked brushing in a shiny app. The video can be accessed here and the code to run the example is here Since the update rule is the same for each view in Figure 6.7, we end up with a lot of redundant code that can be made more modular, as shown here. Making code more modular not only makes for less reading, but it leaves you less prone to making mistakes. Since the only difference between the two plots is the x/y variables, we can write a function that accepts x/y variables as input, and output a plotly object. Since this function outputs a plotly object, and is dependent upon event_data(), which can only be called within a reactive expression, this function can only be called within the renderPlotly() function in the plotly package. To my knowledge, the leaflet package is the only R package which provides a way to update a plot in a shiny app without a full redraw.↩ "],
["targeting-views.html", "6.4 Targeting views", " 6.4 Targeting views The linked brushing example in Figure 6.7 has bi-directional communication – a &quot;plotly_selected&quot; event deriving from either view impacts the other view. In other words, each view can be either the source or target of the selection. Often times, we want one view to be the source of a selection, and related view(s) to be the target. Figure 6.8 shows a heatmap of a correlation matrix (the source of a selection) linked to a scatterplot (the target of a selection). By clicking on a cell in the correlation matrix, a scatterplot of the two variables is displayed below the matrix. To update the scatterplot view, Figure 6.8 accesses &quot;plotly_click&quot; events via the event_data() function, but it also careful to not access click events triggered from the scatterplot. By strategically matching the value of the source argument in the plot_ly() and event_data() functions, Figure 6.8 effectively restricts the scope of events to a specific plot (the heatmap). Figure 6.8: A video demonstration of clicking on a cell in a correlation matrix to view the corresponding scatterplot. The video can be accessed here and the code to run the example is here Another aspect of Figure 6.8 that makes it an interesting example is that the key attribute is a matrix, matching the same dimensions of z (i.e, the values displayed in each cell). For good reason, most linked views paradigms (including the paradigm discussed in Linking views without shiny) restrict linkage definitions to relational database schema. In this case, it is more efficient to implement the relation with a key matrix, rather than a column. "],
["shiny-performance.html", "6.5 Improving performance", " 6.5 Improving performance Multiple linked views are known to help facilitate data exploration, but latency in the user interface is also known to reduce exploratory findings (Heer 2014). In addition to the advice and techniques offered in section ?? for improving plotly’s performance in general, there are also techniques specifically for shiny apps that you can leverage to help improve the user experience. When trying to speed-up any slow code, the first step is always to identify the main contributor(s) to the poor performance. In some cases, your intuition may serve as a helpful guide, but in order to really see what’s going on, consider using a code profiling tool like profvis (Chang and Luraschi 2018). The profvis package provides a really nice way to visualize and isolate slow running R code in general, but it also works well for profiling shiny apps (RStudio 2014b). A lot of different factors can contribute to poor performance in a shiny app, but thankfully, the shiny ecosystem provides an extensive toolbox for diagnosing and improving performance. The profvis package is great for identifying “universal” performance issues, but when deploying shiny apps into production, there may be other potential bottlenecks that surface. This is largely due to R’s single-threaded nature – a single R server has difficulty scaling to many users because, by default, it can only handle one job at a time. The shinyloadtest package helps to identify those bottlenecks and shiny’s support for asynchronous programming with promises is one way to address them without increasing computational infrastructure (e.g. multiple servers) (Dipert, Schloerke, and Borges 2018, @promises). To reiterate the section on “Improving performance and scalability” in shiny from Cheng (2018a), you have a number of tools available to address performance: The profvis package for profiling code. Cache computations ahead-of-time. Cache computations at run time. Cache computations through chaining reactive expressions. Leverage multiple R processes and/or servers. Async programming with promises We won’t directly cover these topics, but it’s worth noting that all these tools are primarily designed for improving server-side performance of a shiny app. It could be that sluggish plots in your shiny app are due to sluggish server-side code, but it could also be that some of the sluggishness is due to redundant work being done client-side by plotly. Avoiding this redundancy, as covered in section 6.5.1, can be difficult, and it doesn’t always lead to noticable improvements. However, when you need to put lots of graphical elements on a plot, then update just a portion of the plot in response to user event(s), the added complexity can be worth the effort. 6.5.1 Partial plotly updates By default, when renderPlotly() renders a new plotly graph it’s essentially equivalent to executing a block of R code from your R prompt and generating a new plotly graph from scratch. That means, not only does the R code need to re-execute to generate a new R object, but it also has to re-serialize that object as JSON, and your browser has to re-render the graph from the new JSON object (more on this in section ??). In cases where your plotly graph does not need to serialize a lot data and/or render lots of graphical elements, as in Figure 6.1, you can likely perform a full redraw without noticable glitches, especially if you use canvas-based rendering rather than SVG (i.e., toWebGL()). Generally speaking, you should try very hard to make your app responsive before adopting partial plotly updates in shiny. It makes your app logic easy to reason about because you don’t have to worry about maintaining the state of the graph, but sometimes you have no other choice. On initial page load, plotly graphs must be drawn from stratch, but when responding to certain user events, often times a partial update to an existing plot is sufficient and more responsive. Take, for instance, the difference between Figure 6.9, which does a full redraw on every update, and Figure 6.10, which does a partial update after initial load. Both of these shiny apps display a scatterplot with 100,000 points and allow a user to overlay a fitted line through a checkbox. The key difference is that in Figure 6.9, the plotly graph is regenerated from scratch everytime the value of input$smooth changes, whereas in Figure 6.10 only the fitted line is added/removed from the plotly. Since the main bottleneck lies in redrawing the points, Figure 6.10 can add/remove the fitted line is a much more responsive fashion. library(shiny) library(plotly) # Generate 100,000 observations from 2 correlated random variables d &lt;- MASS::mvrnorm(1e6, mu = c(0, 0), Sigma = matrix(c(1, 0.5, 0.5, 1), 2, 2)) d &lt;- setNames(as.data.frame(d), c(&quot;x&quot;, &quot;y&quot;)) # fit a simple linear model m &lt;- lm(y ~ x, data = d) # generate y predictions over a grid of 10 x values dpred &lt;- data.frame( x = seq(min(d$x), max(d$x), length.out = 10) ) dpred$yhat &lt;- predict(m, newdata = dpred) ui &lt;- fluidPage( plotlyOutput(&quot;scatterplot&quot;), checkboxInput(&quot;smooth&quot;, label = &quot;Overlay fitted line?&quot;, value = FALSE) ) server &lt;- function(input, output, session) { output$scatterplot &lt;- renderPlotly({ p &lt;- plot_ly(d, x = ~x, y = ~y) %&gt;% add_markers(color = I(&quot;black&quot;), alpha = 0.05) %&gt;% toWebGL() %&gt;% layout(showlegend = FALSE) if (!input$smooth) return(p) add_lines(p, data = dpred, x = ~x, y = ~yhat, color = I(&quot;red&quot;)) }) } shinyApp(ui, server) Figure 6.9: Naive implementation of a shiny app that optionally overlays a fitted line to a scatterplot. In terms of the implementation behind Figure 6.9 and 6.10, the only difference resides in the server definition. In Figure ??, the renderPlotly() statement no longer has a dependency on input values, so that code is only executed once (on page load) to generate the initial view of the scatterplot. The logic behind adding and removing the fitted line is handled through an observe() block – this reactive expression watches the input$smooth input value and modifies the output$scatterplot widget whenever it changes. To trigger a modification of a plotly output widget, you must create a proxy object with plotlyProxy() that references the relevant output ID. Once a proxy object is created, you can invoke any sequence of plotly.js function(s) on it with plotlyProxyInvoke(). Invoking a method with the correct arguments can be tricky and requires knowledge of plotly.js because plotlyProxyInvoke() will send these arguments directly to the plotly.js method and therefore doesn’t support the same ‘high-level’ semantics that plot_ly() does. server &lt;- function(input, output, session) { output$scatterplot &lt;- renderPlotly({ plot_ly(d, x = ~x, y = ~y) %&gt;% add_markers(color = I(&quot;black&quot;), alpha = 0.05) %&gt;% toWebGL() }) observe({ if (input$smooth) { # this is essentially the plotly.js way of doing # `p %&gt;% add_lines(x = ~x, y = ~yhat) %&gt;% toWebGL()` # without having to redraw the entire plot plotlyProxy(&quot;scatterplot&quot;, session) %&gt;% plotlyProxyInvoke( &quot;addTraces&quot;, list( x = dpred$x, y = dpred$yhat, type = &quot;scattergl&quot;, mode = &quot;lines&quot;, line = list(color = &quot;red&quot;) ) ) } else { # JavaScript index starts at 0, so the &#39;1&#39; here really means # &quot;delete the second traces (i.e., the fitted line)&quot; plotlyProxy(&quot;scatterplot&quot;, session) %&gt;% plotlyProxyInvoke(&quot;deleteTraces&quot;, 1) } }) } Figure 6.10: A more responsive version of Figure 6.9. Figure 6.9 demonstrates a common use case where partial updates can be helpful, but there are other not-so-obvious cases. The next section covers a range of examples where you’ll see how to leverage partial updates to implement smooth ‘streaming’ visuals, avoid resetting axis ranges, avoid flickering basemap layers, and more. 6.5.2 Partial update examples The last section explains why you may want to leverage partial plotly updates in shiny to get more responsive updates through an example. That example leveraged the plotly.js functions Plotly.addTraces() and Plotly.deleteTraces() to add/remove a layer to a plot after it’s initial draw. There are numerous other plotly.js functions that can be handy for a variety of use cases, some of the most widely used ones are: Plotly.restyle() for updating data visuals (section 6.5.2.1), Plotly.relayout() for updating the layout (section 6.5.2.2), and Plotly.extendTraces() for streaming data (section 6.5.2.3). 6.5.2.1 Updating data visuals All plotly figures have two main components: traces (i.e., mapping from data to visuals) and layout. The plotly.js function Plotly.restyle() is for modifying any existing traces. In addition to being a performant way to modify existing data and/or visual properties, it also has the added benefit of not affecting the current layout of the graph. Notice how, in Figure 6.11 for example, when the size of the marker/path changes, it doesn’t change the camera’s view of the 3D plot that the user altered after initial draw. If these input widgets triggered a full redraw of the plot, the camera would be reset to it’s initial state. library(shiny) library(plotly) ui &lt;- fluidPage( sliderInput(&quot;marker&quot;, &quot;Marker size&quot;, min = 0, max = 20, value = 8), sliderInput(&quot;path&quot;, &quot;Path size&quot;, min = 0, max = 30, value = 2), plotlyOutput(&quot;p&quot;) ) server &lt;- function(input, output, session) { output$p &lt;- renderPlotly({ plot_ly( economics, x = ~pce, y = ~psavert, z = ~unemploy, color = ~as.numeric(date), mode = &quot;markers+lines&quot; ) }) observeEvent(input$marker, { plotlyProxy(&quot;p&quot;, session) %&gt;% plotlyProxyInvoke( &quot;restyle&quot;, # could also do list(marker = list(size = input$marker)) # but that overwrites the existing marker definition # https://github.com/plotly/plotly.js/issues/1866#issuecomment-314115744 list(marker.size = input$marker) ) }) observeEvent(input$path, { plotlyProxy(&quot;p&quot;, session) %&gt;% plotlyProxyInvoke( &quot;restyle&quot;, list(line.width = input$path) ) }) } shinyApp(ui, server) Figure 6.11: Using Plotly.restyle() to change just the width of a path and markers along that path in response to changes to shiny input sliders. One un-intuitive thing about Plotly.restyle() is that it fully replaces object (i.e., attributes that contain attributes) definitions like marker by default. To modify just a particular attribute of an object, like the size of a marker, you must replace that attribute directly (hence marker.size). As mentioned in the official documentation, by default, modifications are applied to all traces, but specific traces can be targeted through their trace index (which starts at 0, because JavaScript!) 6.5.2.2 Updating the layout All plotly figures have two main components: traces (i.e., mapping from data to visuals) and layout. The plotly.js function Plotly.relayout() is for modifying the layout. library(shiny) library(plotly) ui &lt;- fluidPage( plotlyOutput(&quot;plot&quot;) ) server &lt;- function(input, output, session) { p &lt;- ggplot(txhousing) + geom_line(aes(date, median, group = city)) output$plot &lt;- renderPlotly({ ggplotly(p, dynamicTicks = TRUE) %&gt;% rangeslider() }) observeEvent(event_data(&quot;plotly_relayout&quot;), { d &lt;- event_data(&quot;plotly_relayout&quot;) xmin &lt;- if (length(d[[&quot;xaxis.range[0]&quot;]])) d[[&quot;xaxis.range[0]&quot;]] else d[[&quot;xaxis.range&quot;]][1] xmax &lt;- if (length(d[[&quot;xaxis.range[1]&quot;]])) d[[&quot;xaxis.range[1]&quot;]] else d[[&quot;xaxis.range&quot;]][2] if (is.null(xmin) || is.null(xmax)) return(NULL) # compute the y-range based on the new x-range idx &lt;- with(txhousing, xmin &lt;= date &amp; date &lt;= xmax) yrng &lt;- extendrange(txhousing$median[idx]) plotlyProxy(&quot;plot&quot;, session) %&gt;% plotlyProxyInvoke(&quot;relayout&quot;, list(yaxis = list(range = yrng))) }) yRange &lt;- range(txhousing$median, na.rm = TRUE) observeEvent(event_data(&quot;plotly_doubleclick&quot;), { plotlyProxy(&quot;plot&quot;, session) %&gt;% plotlyProxyInvoke(&quot;relayout&quot;, list(yaxis = list(range = yRange))) }) } shinyApp(ui, server) 6.5.2.3 Streaming library(shiny) library(plotly) ui &lt;- fluidPage( actionButton(&quot;stream&quot;, &quot;Turn stream on/off&quot;), plotlyOutput(&quot;plot&quot;) ) server &lt;- function(input, output, session) { # initial values yint &lt;- c(0, 1) # initiate graph with initial values output$plot &lt;- renderPlotly({ plot_ly(y = yint, x = seq_along(yint)) %&gt;% add_lines() }) # reactiveValues() act very much like input values, but may be used to # maintain state (e.g., are we currently streaming?) rv &lt;- reactiveValues( stream = FALSE, yend = sum(yint), n = length(yint) ) # turn streaming on/off when the button is pressed observeEvent(input$stream, { rv$stream &lt;- if (rv$stream) FALSE else TRUE }) observe({ # if we&#39;re not streaming, don&#39;t do anything if (!rv$stream) return() # re-execute this code block to every 100 milliseconds invalidateLater(100, session) # changing a reactive value &quot;invalidates&quot; it, so isolate() is needed # to avoid recursion isolate({ rv$n &lt;- rv$n + 1 rv$yend &lt;- rv$yend + sample(c(-1, 1), 1) }) # add the new value to the plot plotlyProxy(&quot;plot&quot;, session) %&gt;% plotlyProxyInvoke( &quot;extendTraces&quot;, list( y = list(list(rv$yend)), x = list(list(rv$n)) ), list(0) ) }) } shinyApp(ui, server) 6.5.3 Other considerations Typically the Careful what you send over the wire! Tradeoffs between shiny caching and partial updates? References "],
["animating-views.html", "7 Animating views ", " 7 Animating views "],
["key-frame-animations.html", "7.1 Key frame animations", " 7.1 Key frame animations Both plot_ly() and ggplotly() support key frame animations through the frame attribute/aesthetic. They also support an ids attribute/aesthetic to ensure smooth transitions between objects with the same id (which helps facilitate object constancy). Figure 6.12 recreates the famous gapminder animation of the evolution in the relationship between GDP per capita and life expectancy evolved over time (Bryan 2015). The data is recorded on a yearly basis, so the year is assigned to frame, and each point in the scatterplot represents a country, so the country is assigned to ids, ensuring a smooth transition from year to year for a given country. data(gapminder, package = &quot;gapminder&quot;) gg &lt;- ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent)) + geom_point(aes(size = pop, frame = year, ids = country)) + scale_x_log10() ggplotly(gg) Figure 6.12: Animation of the evolution in the relationship between GDP per capita and life expectancy in numerous countries. As long as a frame variable is provided, an animation is produced with play/pause button(s) and a slider component for controlling the animation. These components can be removed or customized via the animation_button() and animation_slider() functions. Moreover, various animation options, like the amount of time between frames, the smooth transition duration, and the type of transition easing may be altered via the animation_opts() function. Figure 6.13 shows the same data as Figure 6.12, but doubles the amount of time between frames, uses linear transition easing, places the animation buttons closer to the slider, and modifies the default currentvalue.prefix settings for the slider. base &lt;- gapminder %&gt;% plot_ly(x = ~gdpPercap, y = ~lifeExp, size = ~pop, text = ~country, hoverinfo = &quot;text&quot;) %&gt;% layout(xaxis = list(type = &quot;log&quot;)) base %&gt;% add_markers(color = ~continent, frame = ~year, ids = ~country) %&gt;% animation_opts(1000, easing = &quot;elastic&quot;, redraw = FALSE) %&gt;% animation_button( x = 1, xanchor = &quot;right&quot;, y = 0, yanchor = &quot;bottom&quot; ) %&gt;% animation_slider( currentvalue = list(prefix = &quot;YEAR &quot;, font = list(color=&quot;red&quot;)) ) Figure 6.13: Modifying animation defaults with animation_opts(), animation_button(), and animation_slider(). If frame is a numeric variable (or a character string), frames are always ordered in increasing (alphabetical) order; but for factors, the ordering reflects the ordering of the levels. Consequently, factors provide the most control over the ordering of frames. In Figure 6.14, the continents (i.e., frames) are ordered according their average life expectancy across countries within the continent. Furthermore, since there is no meaningful relationship between objects in different frames of Figure 6.14, the smooth transition duration is set to 0. This helps avoid any confusion that there is a meaningful connection between the smooth transitions. Note that these options control both animations triggered by the play button or via the slider. meanLife &lt;- with(gapminder, tapply(lifeExp, INDEX = continent, mean)) gapminder$continent &lt;- factor( gapminder$continent, levels = names(sort(meanLife)) ) base %&gt;% add_markers(data = gapminder, frame = ~continent) %&gt;% hide_legend() %&gt;% animation_opts(frame = 1000, transition = 0, redraw = FALSE) Figure 6.14: Animation of GDP per capita versus life expectancy by continent. The ordering of the contintents goes from lowest average (across countries) life expectancy to highest. Both the frame and ids attributes operate on the trace level – meaning that we can target specific layers of the graph to be animated. One obvious use case for this is to provide a background which displays every possible frame (which is not animated) and overlay the animated frames onto that background. Figure 6.15 shows the same information as Figure 6.13, but layers animated frames on top of a background of all the frames. As a result, it is easier to put a specific year into a global context. base %&gt;% add_markers(color = ~continent, alpha = 0.2, showlegend = F) %&gt;% add_markers(color = ~continent, frame = ~year, ids = ~country) %&gt;% animation_opts(1000, redraw = FALSE) Figure 6.15: Overlaying animated frames on top of a background of all possible frames. References "],
["linking-animated-views.html", "7.2 Linking animated views", " 7.2 Linking animated views The section linking views without shiny details a framework for linking views through direct manipulation. This same framework can be leveraged to highlight objects as they progress through an animation, or even link objects between animations. Figure 6.16 extends Figure 6.12 by layering on linear models specific to each frame and specifying continent as a key variable. As a result, one may interactively highlight any continent they wish, and track the relationship through the animation. In the animated version of Figure 6.12, the user highlights the Americas, which makes it much easier to see that the relationship between GDP per capita and life expectancy was very strong starting in the 1950s, but progressively weakened throughout the years. Figure 6.16: Highlighting the relationship between GDP per capita and life expectancy in the Americas and tracking that relationship through several decades. g &lt;- crosstalk::SharedData$new(gapminder, ~continent) gg &lt;- ggplot(g, aes(gdpPercap, lifeExp, color = continent, frame = year)) + geom_point(aes(size = pop, ids = country)) + geom_smooth(se = FALSE, method = &quot;lm&quot;) + scale_x_log10() ggplotly(gg) %&gt;% highlight(&quot;plotly_hover&quot;) In addition to highlighting objects within an animation, objects may also be linked between animations. Figure 6.17 links two animated views: on the left-hand side is population density by country and on the right-hand side is GDP per capita versus life expectancy. By default, all of the years are shown in black and the current year is shown in red. By pressing play to animate through the years, we can see that all three of these variables have increased (on average) fairly consistently over time. By linking the animated layers, we may condition on an interesting region of this data space to make comparisons in the overall relationship over time. For example, in Figure 6.17, countries below the 50th percentile in terms of population density are highlighted in blue, then the animation is played again to reveal a fairly interesting difference in these groups. From 1952 to 1977, countries with a low population density seem to enjoy large increases in GDP per capita and moderate increases in life expectancy, then in the early 80s, their GPD seems to decrease while the life expectancy greatly increases. In comparison, the high density countries seems to enjoy a more consistent and steady increase in both GDP and life expectancy. Of course, there are a handful of exceptions to the overall trend, such as the noticeable drop in life expectancy for a handful of countries during the nineties, which are mostly African countries feeling the affects of war. Figure 6.17: Comparing the evolution in the relationship between per capita GDP and life expectancy in countries with large populations (red) and small populations (blue). The gapminder data used thus far does not include surface area information, so Figure 6.17 leverages a list of countries by area on Wikipedia. The R script used to obtain and clean that list is here, but the cleaned version is directly available, plus add the areas to the gapminder data with the following code: countryByArea &lt;- read.table( &quot;https://bit.ly/2h6vscu&quot;, header = TRUE, stringsAsFactors = FALSE ) gap &lt;- gapminder %&gt;% dplyr::left_join(countryByArea, by = &quot;country&quot;) %&gt;% transform(popDen = pop / area) %&gt;% transform(country = forcats::fct_reorder(country, popDen)) The enhanced version of the gapminder data, gap, includes population density (population per square kilometer) and is used for the background layer (i.e., black points) in Figure 6.17. In order to link the animated layers (i.e., red points), we need another version of gap that marks the country variable as the link between the plots (gapKey). The new() method for the SharedData class from the crosstalk package provides one way to define this link.25 gapKey &lt;- crosstalk::SharedData$new(gap, ~country) p1 &lt;- plot_ly(gap, y = ~country, x = ~popDen, hoverinfo = &quot;x&quot;) %&gt;% add_markers(alpha = 0.1, color = I(&quot;black&quot;)) %&gt;% add_markers(data = gapKey, frame = ~year, ids = ~country, color = I(&quot;red&quot;)) %&gt;% layout(xaxis = list(type = &quot;log&quot;)) p2 &lt;- plot_ly(gap, x = ~gdpPercap, y = ~lifeExp, size = ~popDen, text = ~country, hoverinfo = &quot;text&quot;) %&gt;% add_markers(color = I(&quot;black&quot;), alpha = 0.1) %&gt;% add_markers(data = gapKey, frame = ~year, ids = ~country, color = I(&quot;red&quot;)) %&gt;% layout(xaxis = list(type = &quot;log&quot;)) subplot(p1, p2, nrows = 1, widths = c(0.3, 0.7), titleX = TRUE) %&gt;% hide_legend() %&gt;% animation_opts(1000, redraw = FALSE) %&gt;% layout(hovermode = &quot;y&quot;, margin = list(l = 100)) %&gt;% highlight(&quot;plotly_selected&quot;, color = &quot;blue&quot;, opacityDim = 1, hoverinfo = &quot;none&quot;) You can also use the key/set attributes when linking views within plotly. The set attribute is equivalent to the group argument in the SharedData$new() function.↩ "],
["advanced-topics.html", "8 Advanced topics", " 8 Advanced topics This section describes some advanced topics regarding the plotly package. Some of the content found here may be useful for the following people: R users that know some JavaScript and want to enable custom features that plotly and plotly.js does not natively support. R developers that have authored a custom ggplot2 geom and want to inform ggplotly() about the rendering rules of their geom. R developers that want to build a similar interface to another JavaScript graphing library. "],
["javascript.html", "8.1 Custom behavior via JavaScript", " 8.1 Custom behavior via JavaScript The section on linking views with shiny shows how to acquire data tied to plotly.js events from a shiny app. Since shiny adds a lot of additional infrastructure, plotly also provides a way to link views without shiny, but this definitely does not encompass every type of interactivity. Thankfully the htmlwidgets package provides a way to invoke a JavaScript function on the widget element (after it is done rendering) from R via the onRender() function (Vaidyanathan et al. 2016). The JavaScript function should have at least two arguments: (1) the DOM element containing the htmlwidget (el) and (2) the data passed from R (x). This enables, for instance, the ability to author custom behavior tied to a particular plotly.js event. Figure 8.1 uses onRender() to open a relevant Google search upon clicking a point. library(plotly) library(htmlwidgets) mtcars$url &lt;- paste0(&quot;http://google.com/#q=&quot;, rownames(mtcars)) plot_ly(mtcars, x = ~wt, y = ~mpg) %&gt;% add_markers(text = rownames(mtcars), customdata = ~url) %&gt;% onRender(&quot; function(el, x) { el.on(&#39;plotly_click&#39;, function(d) { var url = d.points[0].customdata; window.open(url); }); } &quot;) Figure 8.1: Using onRender() to register a JavaScript callback that opens a google search upon a ‘plotly_click’ event. library(plotly) library(htmlwidgets) library(tidyr) nagents &lt;- 1000 d &lt;- tibble::tibble( id = seq_len(nagents), first = runif(nagents, Sys.time() - 1e5, Sys.time()), second = runif(nagents, first, first + 1e5), third = runif(nagents, second, second + 1e5), meta = paste(&quot;Some metainfo about case ID:&quot;, id) ) # how the selected markers should appear marker_selected &lt;- list( size = 10, line = list( color = &quot;black&quot;, width = 1 ) ) gather(d, variable, value, -id, -meta) %&gt;% mutate(value = anytime(value)) %&gt;% highlight_key(~id) %&gt;% plot_ly(x = ~value, y = ~factor(variable, levels = lvls)) %&gt;% group_by(id) %&gt;% add_trace( type = &quot;scatter&quot;, mode = &quot;markers+lines&quot;, alpha = 0.4, text = ~paste(&quot;Case id:&quot;, id), hoverinfo = &quot;x+text&quot;, customdata = ~meta ) %&gt;% toWebGL() %&gt;% layout( xaxis = list( title = &quot;&quot;, type = &quot;date&quot;), yaxis = list(title = &quot;&quot;) ) %&gt;% highlight( on = &quot;plotly_hover&quot;, off = &quot;plotly_doubleclick&quot;, selected = attrs_selected(marker = marker_selected, line = list(color = &quot;black&quot;)) ) %&gt;% htmlwidgets::onRender(&quot; function(el, x) { var gd = document.getElementById(el.id); gd.on(&#39;plotly_hover&#39;, function(ed) { var ann = { text: ed.points[0].customdata, x: 0.5, y: 1, xref: &#39;paper&#39;, yref: &#39;paper&#39;, xanchor: &#39;middle&#39;, showarrow: false }; Plotly.relayout(gd, {annotations: [ann]}); }); gd.on(&#39;plotly_doubleclick&#39;, function(ed) { Plotly.relayout(gd, {annotations: []}); }); } &quot;) References "],
["translating-custom-ggplot2-geoms.html", "8.2 Translating custom ggplot2 geoms", " 8.2 Translating custom ggplot2 geoms Version 2.0.0 of ggplot2 introduced a way for other R packages to implement custom geoms. Some great examples include: ggrepel, ggalt, ggraph, geomnet, ggmosaic and ggtern (Rudis 2016); (Pedersen 2016); (Tyner and Hofmann 2016); (Jeppson, Hofmann, and Cook 2016); (Hamilton 2016).26 Although the ggplotly() function translates most of the geoms bundled with the ggplot2 package, it has no way of knowing about the rendering rules for custom geoms. The plotly package does, however, provide 2 generic functions based on the S3 scheme that can leveraged to inform ggplotly() about these rules (Chambers 1992).27 To date, the ggmosaic and ggalt packages have taken advantage of this infrastructure to provide translations of their custom geoms to plotly. In ggplot2, many geoms are special cases of other geoms. For example, geom_line() is equivalent to geom_path() once the data is sorted by the x variable. For cases like this, when a geom can be reduced to another lower-level (i.e., basic) geom, authors just have to write a method for the to_basic() generic function in plotly. In fact, within the package itself, the to_basic() function has a GeomLine method which simply sorts the data by the x variable then returns it with a class of GeomPath prefixed. getS3method(&quot;to_basic&quot;, &quot;GeomLine&quot;) #&gt; function (data, prestats_data, layout, params, p, ...) #&gt; { #&gt; data &lt;- data[order(data[[&quot;x&quot;]]), ] #&gt; prefix_class(data, &quot;GeomPath&quot;) #&gt; } #&gt; &lt;bytecode: 0x7ffb714e6fd0&gt; #&gt; &lt;environment: namespace:plotly&gt; If you have implemented a custom geom, say GeomCustom, rest assured that the data passed to to_basic() will be of class GeomCustom when ggplotly() is called on a plot with your geom. And assuming GeomCustom may be reduced to another lower-level geom support by plotly, a to_basic.GeomCustom() method that transforms the data into a form suitable for that lower-level geom is sufficient for adding support. Moreover, note that the data passed to to_basic() is essentially the last form of the data before the render stage and after statistics have been performed. This makes it trivial to add support for geoms like GeomXspline from the ggalt package. # devtools::install_github(&quot;hrbrmstr/ggalt&quot;) library(ggalt) getS3method(&quot;to_basic&quot;, &quot;GeomXspline&quot;) #&gt; function (data, prestats_data, layout, params, p, ...) #&gt; { #&gt; data &lt;- data[order(data[[&quot;x&quot;]]), ] #&gt; prefix_class(data, &quot;GeomPath&quot;) #&gt; } #&gt; &lt;bytecode: 0x7ffb6afe4080&gt; #&gt; &lt;environment: namespace:plotly&gt; As shown in Figure 8.2, once the conversion has been provided. Users can call ggplotly() on the ggplot object containing the custom geom just like any other ggplot object. # example from `help(geom_xspline)` set.seed(1492) dat &lt;- data.frame( x = c(1:10, 1:10, 1:10), y = c(sample(15:30, 10), 2 * sample(15:30, 10), 3 * sample(15:30, 10)), group = factor(c(rep(1, 10), rep(2, 10), rep(3, 10))) ) p &lt;- ggplot(dat, aes(x, y, group = group, color = factor(group))) + geom_point(color = &quot;black&quot;) + geom_smooth(se = FALSE, linetype = &quot;dashed&quot;, size = 0.5) + geom_xspline(spline_shape = 1, size = 0.5) ggplotly(p) %&gt;% hide_legend() Figure 8.2: Converting GeomXspline from the ggalt package to plotly.js via ggplotly(). In more complicated cases, where your custom geom can not be converted to a lower level geom, a custom method for the geom2trace() generic is required (methods(geom2trace) lists all the basic geoms that we natively support). This method should involve a conversion from a data frame to a list-like object conforming to the plotly.js figure reference. References "],
["designing-an-htmlwidget-interface.html", "8.3 Designing an htmlwidget interface", " 8.3 Designing an htmlwidget interface The plotly.js library, as with many other JavaScript graphing libraries, strives to describe any plot through a plot specification defined via JavaScript Object Notation (JSON). JSON is a language independent data-interchange format that was originally designed for JavaScript, but parsers for many different languages now exist, including R (Temple Lang 2014); (Ooms 2014). JSON is a recursive key-value data structure (similar to a list in R), and essentially any valid JavaScript value has a natural R equivalent (e.g., NULL/null). As a result, any JSON object can be created from an appropriate R list, meaning that theoretically any plotly.js plot can be described via an R list. However, simply providing a bridge between R lists and JSON does not guarantee a powerful or usable interface, especially for a general purpose graphing library. Although it can be complicated to implement, R interfaces to JavaScript graphing libraries should leverage R’s strong resources for computing on the language to design a more expressive interface (Wickham 2014). It should also look and feel like (and work well with!) other commonly used interfaces in R. A good way to do this is to embrace (pure and predictable) functional programming. Most importantly, this implies that every function modifies a central type of object – meaning that every function input and output the same type of object (predictable). Furthermore, if the output of a function can be determined completely by the input (i.e., pure), it removes any need to search for other code that may be affecting the output. In the case of providing an interface to a JavaScript graphing library, there are a number of reasons why the central object should inherit from the central object provided by the htmlwidgets package. The idea of interfacing R with JavaScript libraries via JSON data transfer has been popular approach for quite some time (Vaidyanathan 2013); (Hocking, VanderPlas, and Sievert 2015); (Sievert and Shirley 2014). The R package htmlwidgets standardized this bridge, and provides some additional infrastructure for making sure the HTML output works as expected in multiple contexts (in the R console or RStudio, within rmarkdown documents, and even embedded inside shiny apps). The htmlwidgets package itself is opinionated about the data structure used to represent the widget in R since it needs to retain meta-information about the widget, such as the sizing policy. To avoid surprise, widget authors should strive to have all functions in their interface modify this data structure.28 JavaScript graphing libraries usually have strong requirements about the JSON structure used to create a plot. In some cases, the R interface needs to know about these requirements in order to faithfully translate R objects to JSON. For example, in plotly.js some attributes must always be an array (e.g. x/y), even if they are length 1, while other attributes cannot be an array must be a literal constant (e.g. name). This leads to a situation where the translation rules from R to JSON cannot be simply “box all vectors of length 1 into an array (or not)”: list(x = 1, y = 1, name = &quot;A point&quot;) =&gt; {x: [1], y: [1], name: &quot;A point&quot;} Thankfully plotly.js provides a plot schema which declares types for each attribute that plotly leverages internally. If necessary, plotly tries to coerce each attribute to its expected type at print time, and also searches for any unsupported attributes that may have been specified by the user (and throws a warning that the attribute will be ignored). This helps References "],
["references.html", "References", " References "]
]
