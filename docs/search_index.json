[
["index.html", "plotly for R Overview", " plotly for R Carson Sievert Overview This website explains and partially documents the R package plotly, a high-level interface to the open source JavaScript graphing library plotly.js (which powers plot.ly). The R package already has numerous examples and documentation on https://plot.ly/r and https://plot.ly/ggplot2, but this website provides more of a cohesive narrative to help explain fundamental concepts and recent developments. By reading from start to finish, readers new to R and plotly should be able to get up and running fairly quickly. That being said, advanced R and plotly users should still find the majority of this material useful and informative. I highly recommend copying/pasting examples into your R console, and modifying them as you read along, to aid the learning process. This work is licensed under the Creative Commons Attribution-NonCommercial-NoDerivs 3.0 United States License. "],
["installation.html", "Installation", " Installation If you have R installed, you can install the stable release of plotly by typing this in your R console: install.packages(&quot;plotly&quot;) Or you can install the development release via the devtools package: if (!require(&quot;devtools&quot;)) install.packages(&quot;devtools&quot;) devtools::install_github(&quot;ropensci/plotly&quot;) The version of the R package used to build this site is: packageVersion(&quot;plotly&quot;) #&gt; [1] &#39;4.5.5.9000&#39; "],
["get-started.html", "Get started", " Get started To ensure plotly is installed correctly, try loading the package and creating this example by pasting the code inside your R console. library(plotly) plot_ly(z = ~volcano) plotly uses the htmlwidget framework, which allows plots to work seamlessly and consistently in various contexts (e.g., R Markdown documents, shiny apps, inside RStudio, or any other R command prompt) without an internet connection. IPython/Jupyter notebook users should wrap plots with the embed_notebook() function to embed them inline inside a notebook. "],
["plot-ly-for-collaboration.html", "plot.ly for collaboration", " plot.ly for collaboration plot.ly subscribers can use the plotly_POST() function to publish plots from R onto plotly’s web platform. This platform makes it very easy to host/share your graphs, collaborate with others, and is free to use for public graphs.1 Once a plot is hosted on your account, others may copy/fork your graph to their account (with the right permissions) using a friendly user-interface. Here is a quick demonstration of that workflow from inside RStudio: As long as you can view a plot hosted on http://plot.ly, you can bring the data behind with plot into R via the get_figure() function. This makes it easy to access and modify plots created with any plotly.js interface (e.g., Python, MATLAB, Julia, Scala, etc) from your R console. Not only is this web-based user-interface to plotly.js useful for collaborating with others, but it is also useful for completing tasks that are cumbersome to do at the command-line. For instance, annotations can be added to any plot via a point-and-click interface: --> If you need privacy or customer support, pricing options↩ "],
["two-approaches-one-object.html", "1 Two approaches, one object", " 1 Two approaches, one object There are two main ways to initiate a plotly object in R. The plot_ly() function transforms data into a plotly object, while the ggplotly() function transforms a ggplot object into a plotly object (Wickham 2009); (Sievert et al. 2016). Regardless of how a plotly object is created, printing it results in an interactive web-based visualization with tooltips, zooming, and panning enabled by default. The R package also has special semantics for arranging, linking, and animating plotly objects. This chapter discusses some of the philosophy behind each approach, explores some of their similarities, and explains why understanding both approaches is extremely powerful. The initial inspiration for the plot_ly() function was to support plotly.js chart types that ggplot2 doesn’t support, such as 3D surface and mesh plots. Over time, this effort snowballed into an interface to the entire plotly.js graphing library with additional abstractions inspired by the grammar of graphics (Wilkinson 2005). This newer “non-ggplot2” interface to plotly.js is currently not, and may never be, as fully featured as ggplot2. Since we can already translate a fairly large amount of ggplot objects to plotly objects, I’d rather not reinvent those same abstractions, and advance our ability to link multiple views. The next section uses a case study to introduce some of the similarities between ggplotly()/plot_ly(), introduces the concept of a data-plot-pipeline, and also demonstrates how to extend ggplotly() with functions that can modify plotly objects. References "],
["a-case-study-of-housing-sales-in-texas.html", "1.1 A case study of housing sales in Texas", " 1.1 A case study of housing sales in Texas The plotly package depends on ggplot2 which bundles a data set on monthly housing sales in Texan cities acquired from the TAMU real estate center. After the loading the package, the data is “lazily loaded” into your session, so you may reference it by name: library(plotly) txhousing #&gt; # A tibble: 8,602 × 9 #&gt; city year month sales volume median listings inventory date #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Abilene 2000 1 72 5380000 71400 701 6.3 2000 #&gt; 2 Abilene 2000 2 98 6505000 58700 746 6.6 2000 #&gt; 3 Abilene 2000 3 130 9285000 58100 784 6.8 2000 #&gt; 4 Abilene 2000 4 98 9730000 68600 785 6.9 2000 #&gt; 5 Abilene 2000 5 141 10590000 67300 794 6.8 2000 #&gt; 6 Abilene 2000 6 156 13910000 66900 780 6.6 2000 #&gt; # ... with 8,596 more rows In attempt to understand house price behavior over time, we could plot date on x, median on y, and group the lines connecting these x/y pairs by city. Using ggplot2, we can initiate a ggplot object with the ggplot() function which accepts a data frame and a mapping from data variables to visual aesthetics. By just initiating the object, ggplot2 won’t know how to geometrically represent the mapping until we add a layer to the plot via one of geom_*() (or stat_*()) functions (in this case, we want geom_line()). In this case, it is also a good idea to specify alpha transparency so that 5 lines plotted on top of each other appear as solid black, to help avoid overplotting. If you’re new to ggplot2, the ggplot2 cheatsheet provides a nice quick overview. The online docs or R graphics cookbook are helpful for learning by example, and the ggplot2 book provides a nice overview of the conceptual underpinnings. p &lt;- ggplot(txhousing, aes(date, median)) + geom_line(aes(group = city), alpha = 0.2) 1.1.1 The ggplotly() function Now that we have a valid ggplot2 object, p, the plotly package provides the ggplotly() function which converts a ggplot object to a plotly object. By default, it supplies the entire aesthetic mapping to the tooltip, but the tooltip argument provides a way to restrict tooltip info to a subset of that mapping. Furthermore, in cases where the statistic of a layer is something other than the identity function (e.g., geom_bin2d() and geom_hex()), relevant “intermediate” variables generated in the process are also supplied to the tooltip. This provides a nice mechanism for decoding visual aesthetics (e.g., color) used to represent a measure of interest (e.g, count/value). Figure 1.1 demonstrates tooltip functionality for a number of scenarios, and uses subplot() function from the plotly package (discussed in more detail in Arranging multiple views) to concisely display numerous interactive versions of ggplot objects. subplot( p, ggplotly(p, tooltip = &quot;city&quot;), ggplot(txhousing, aes(date, median)) + geom_bin2d(), ggplot(txhousing, aes(date, median)) + geom_hex(), nrows = 2, shareX = TRUE, shareY = TRUE, titleY = FALSE, titleX = FALSE ) Figure 1.1: Monthly median house price in the state of Texas. The top row displays the raw data (by city) and the bottom row shows 2D binning on the raw data. The binning is helpful for showing the overall trend, but hovering on the lines in the top row helps reveal more detailed information about each city. Although ggplot2 does not have a text aesthetic, the ggplotly() function recognizes this aesthetic and displays it in the tooltip by default. In addition to providing a way to supply “meta” information, it also provides a way to customize your tooltips (do this by restricting the tooltip to the text aesthetic – ggplotly(p, tooltip = “text”)) The ggplotly() function translates most things that you can do in ggplot2, but not quite everything. To help demonstrate the coverage, I’ve built a plotly version of the ggplot2 docs. This version of the docs displays the ggplotly() version of each plot in a static form (to reduce page loading time), but you can click any plot to view its interactive version. The next section deomnstrates how to create plotly.js visualizations via the R package, without ggplot2, via the plot_ly() function. We’ll then leverage those concepts to extend ggplotly(). 1.1.2 The plot_ly() interface 1.1.2.1 The Layered Grammar of Graphics The cognitive framework underlying the plot_ly() interface draws inspiration from the layered grammar of graphics (Wickham 2010), but in contrast to ggplotly(), it provides a more flexible and direct interface to plotly.js. It is more direct in the sense that it doesn’t call ggplot2’s sometimes expensive plot building routines, and it is more flexible in the sense that data frames are not required, which is useful for visualizing matrices, as shown in Get Started. Although data frames are not required, using them is highly recommended, especially when constructing a plot with multiple layers or groups. When a data frame is associated with a plotly object, it allows us to manipulate the data underlying that object in the same way we would directly manipulate the data. Currently, plot_ly() borrows semantics from and provides special plotly methods for generic functions in the dplyr and tidyr packages (Wickham and Francois 2016); (Wickham 2016). Most importantly, plot_ly() recognizes and preserves groupings created with dplyr’s group_by() function. library(dplyr) tx &lt;- group_by(txhousing, city) # initiate a plotly object with date on x and median on y p &lt;- plot_ly(tx, x = ~date, y = ~median) # plotly_data() returns data associated with a plotly object, note the group attribute! plotly_data(p) #&gt; Source: local data frame [8,602 x 9] #&gt; Groups: city [46] #&gt; #&gt; city year month sales volume median listings inventory date #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Abilene 2000 1 72 5380000 71400 701 6.3 2000 #&gt; 2 Abilene 2000 2 98 6505000 58700 746 6.6 2000 #&gt; 3 Abilene 2000 3 130 9285000 58100 784 6.8 2000 #&gt; 4 Abilene 2000 4 98 9730000 68600 785 6.9 2000 #&gt; 5 Abilene 2000 5 141 10590000 67300 794 6.8 2000 #&gt; 6 Abilene 2000 6 156 13910000 66900 780 6.6 2000 #&gt; # ... with 8,596 more rows Defining groups in this fashion ensures plot_ly() will produce at least one graphical mark per group.2 So far we’ve specified x/y attributes in the plotly object p, but we have not yet specified the geometric relation between these x/y pairs. Similar to geom_line() in ggplot2, the add_lines() function connects (a group of) x/y pairs with lines in the order of their x values, which is useful when plotting time series as shown in Figure 1.2. # add a line highlighting houston add_lines( # plots one line per city since p knows city is a grouping variable add_lines(p, alpha = 0.2, name = &quot;Texan Cities&quot;, hoverinfo = &quot;none&quot;), name = &quot;Houston&quot;, data = filter(txhousing, city == &quot;Houston&quot;) ) Figure 1.2: Monthly median house price in Houston in comparison to other Texan cities. The plotly package has a collection of add_*() functions, all of which inherit attributes defined in plot_ly(). These functions also inherit the data associated with the plotly object provided as input, unless otherwise specified with the data argument. I prefer to think about add_*() functions like a layer in ggplot2, which is slightly different, but related to a plotly.js trace. In Figure 1.2, there is a 1-to-1 correspondence between layers and traces, but add_*() functions do generate numerous traces whenever mapping a discrete variable to a visual aesthetic (e.g., color). In this case, since each call to add_lines() generates a single trace, it makes sense to name the trace, so a sensible legend entry is created. In the first layer of Figure 1.2, there is one line per city, but all these lines belong a single trace. We could have produced one trace for each line, but this is way more computationally expensive because, among other things, each trace produces a legend entry and tries to display meaningful hover information. It is much more efficient to render this layer as a single trace with missing values to differentiate groups. In fact, this is exactly how the group aesthetic is translated in ggplotly(); otherwise, layers with many groups (e.g., geom_map()) would be slow to render. 1.1.2.2 The data-plot-pipeline Since every plotly function modifies a plotly object (or the data underlying that object), we can express complex multi-layer plots as a sequence (or, more specifically, a directed acyclic graph) of data manipulations and mappings to the visual space. Moreover, plotly functions are designed to take a plotly object as input, and return a modified plotly object, making it easy to chain together operations via the pipe operator (%&gt;%) from the magrittr package (Bache and Wickham 2014). Consequently, we can re-express Figure 1.2 in a much more readable and understandable fashion. allCities &lt;- txhousing %&gt;% group_by(city) %&gt;% plot_ly(x = ~date, y = ~median) %&gt;% add_lines(alpha = 0.2, name = &quot;Texan Cities&quot;, hoverinfo = &quot;none&quot;) allCities %&gt;% filter(city == &quot;Houston&quot;) %&gt;% add_lines(name = &quot;Houston&quot;) Sometimes the directed acyclic graph property of a pipeline can be too restrictive for certain types of plots. In this example, after filtering the data down to Houston, there is no way to recover the original data inside the pipeline. The add_fun() function helps to work-around this restriction3 – it works by applying a function to the plotly object, but does not affect the data associated with the plotly object. This effectively provides a way to isolate data transformations within the pipeline4. Figure 1.3 uses this idea to highlight both Houston and San Antonio. allCities %&gt;% add_fun(function(plot) { plot %&gt;% filter(city == &quot;Houston&quot;) %&gt;% add_lines(name = &quot;Houston&quot;) }) %&gt;% add_fun(function(plot) { plot %&gt;% filter(city == &quot;San Antonio&quot;) %&gt;% add_lines(name = &quot;San Antonio&quot;) }) Figure 1.3: Monthly median house price in Houston and San Antonio in comparison to other Texan cities. It is useful to think of the function supplied to add_fun() as a “layer” function – a function that accepts a plot object as input, possibly applies a transformation to the data, and maps that data to visual objects. To make layering functions more modular, flexible, and expressive, the add_fun() allows you to pass additional arguments to a layer function. Figure 1.4 makes use of this pattern, by creating a reusable function for layering both a particular city as well as the first, second, and third quartile of median monthly house sales (by city). # reusable function for highlighting a particular city layer_city &lt;- function(plot, name) { plot %&gt;% filter(city == name) %&gt;% add_lines(name = name) } # reusable function for plotting overall median &amp; IQR layer_iqr &lt;- function(plot) { plot %&gt;% group_by(date) %&gt;% summarise( q1 = quantile(median, 0.25, na.rm = TRUE), m = median(median, na.rm = TRUE), q3 = quantile(median, 0.75, na.rm = TRUE) ) %&gt;% add_lines(y = ~m, name = &quot;median&quot;, color = I(&quot;black&quot;)) %&gt;% add_ribbons(ymin = ~q1, ymax = ~q3, name = &quot;IQR&quot;, color = I(&quot;black&quot;)) } allCities %&gt;% add_fun(layer_iqr) %&gt;% add_fun(layer_city, &quot;Houston&quot;) %&gt;% add_fun(layer_city, &quot;San Antonio&quot;) Figure 1.4: First, second, and third quartile of median monthly house pirce in Texas. A layering function does not have to be a data-plot-pipeline itself. Its only requirement on a layering function is that the first argument is a plot object and it returns a plot object. This provides an opportunity to say, fit a model to the plot data, extract the model components you desire, and map those components to visuals. Furthermore, since plotly’s add_*() functions don’t require a data.frame, you can supply those components directly to attributes (as long as they are well-defined), as done in Figure 1.5 via the forecast package (Hyndman, n.d.). library(forecast) layer_forecast &lt;- function(plot) { d &lt;- plotly_data(plot) series &lt;- with(d, ts(median, frequency = 12, start = c(2000, 1), end = c(2015, 7)) ) fore &lt;- forecast(ets(series), h = 48, level = c(80, 95)) plot %&gt;% add_ribbons(x = time(fore$mean), ymin = fore$lower[, 2], ymax = fore$upper[, 2], color = I(&quot;gray95&quot;), name = &quot;95% confidence&quot;, inherit = FALSE) %&gt;% add_ribbons(x = time(fore$mean), ymin = fore$lower[, 1], ymax = fore$upper[, 1], color = I(&quot;gray80&quot;), name = &quot;80% confidence&quot;, inherit = FALSE) %&gt;% add_lines(x = time(fore$mean), y = fore$mean, color = I(&quot;blue&quot;), name = &quot;prediction&quot;) } txhousing %&gt;% group_by(city) %&gt;% plot_ly(x = ~date, y = ~median) %&gt;% add_lines(alpha = 0.2, name = &quot;Texan Cities&quot;, hoverinfo = &quot;none&quot;) %&gt;% add_fun(layer_iqr) %&gt;% add_fun(layer_forecast) Figure 1.5: Layering on a 4-year forecast from a exponential smoothing state space model. In summary, the “data-plot-pipeline” is desirable for a number of reasons: (1) makes your code easier to read and understand, (2) encourages you to think of both your data and plots using a single, uniform data structure, which (3) makes it easy to combine and reuse transformations. As it turns out, we can even use these ideas when creating a plotly object via ggplotly(), as discused in the next section Extending ggplotly()(extending-ggplotly. References "],
["extending-ggplotly.html", "1.2 Extending ggplotly()", " 1.2 Extending ggplotly() 1.2.1 Customizing the layout Since the ggplotly() function returns a plotly object, we can manipulate that object in the same way that we would manipulate any other plotly object. A simple and useful application of this is to specify interaction modes, like plotly.js’ layout.dragmode for specifying the mode of click+drag events. Figure 1.6 demonstrates how the default for this attribute can be modified via the layout() function. p &lt;- ggplot(fortify(gold), aes(x, y)) + geom_line() gg &lt;- ggplotly(p) layout(gg, dragmode = &quot;pan&quot;) Figure 1.6: Customizing the dragmode of an interactive ggplot2 graph. Perhaps a more useful application is to add a range slider to the x-axis, which allows you to zoom on the x-axis, without losing the global context. This is quite useful for quickly altering the limits of your plot to achieve an optimal aspect ratio for your data (William S. Cleveland 1988), without losing the global perspective. Figure 1.7 uses the rangeslider() function to add a rangeslider to the plot. rangeslider(gg) Figure 1.7: Adding a rangeslider to an interactive ggplot2 graph. Since a single plotly object can only have one layout, modifying the layout of ggplotly() is fairly easy, but it’s trickier to add and modify layers. 1.2.2 Adding layers Since ggplotly() returns a plotly object, and plotly objects have data associated with them, we can effectively associate data from a ggplot object with a plotly object, before or after summary statistics have been applied. Since each ggplot layer owns a data frame, it is useful to have some way to specify the particular layer of data of interest, which is the point of the layerData argument in ggplotly(). Also, when a particular layer applies a summary statistic (e.g., geom_bin()), or applies a model (e.g., geom_smooth()) to the data, it might be useful to access the output of that transformation, which is the point of the originalData argument in ggplotly(). p &lt;- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point() + geom_smooth() p %&gt;% ggplotly(layerData = 2, originalData = FALSE) %&gt;% plotly_data() #&gt; # A tibble: 80 × 13 #&gt; x y ymin ymax se PANEL group colour fill size linetype #&gt; * &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1.51 32.1 28.1 36.0 1.92 1 -1 #3366FF grey60 1 1 #&gt; 2 1.56 31.7 28.2 35.2 1.72 1 -1 #3366FF grey60 1 1 #&gt; 3 1.61 31.3 28.1 34.5 1.54 1 -1 #3366FF grey60 1 1 #&gt; 4 1.66 30.9 28.0 33.7 1.39 1 -1 #3366FF grey60 1 1 #&gt; 5 1.71 30.5 27.9 33.0 1.26 1 -1 #3366FF grey60 1 1 #&gt; 6 1.76 30.0 27.7 32.4 1.16 1 -1 #3366FF grey60 1 1 #&gt; # ... with 74 more rows, and 2 more variables: weight &lt;dbl&gt;, alpha &lt;dbl&gt; This is the dataset ggplot2 uses to actually draw the fitted values (as a line) and standard error bounds (as a ribbon). Figure 1.8 uses this data to add additional information about the model fit; in particular, it adds a vertical lines and annotations at the x-values that are associated with the highest and lowest amount uncertainty in y. p %&gt;% ggplotly(layerData = 2, originalData = F) %&gt;% add_fun(function(p) { p %&gt;% slice(which.max(se)) %&gt;% add_segments(x = ~x, xend = ~x, y = ~ymin, yend = ~ymax) %&gt;% add_annotations(&quot;Maximum uncertainty&quot;, ax = 60) }) %&gt;% add_fun(function(p) { p %&gt;% slice(which.min(se)) %&gt;% add_segments(x = ~x, xend = ~x, y = ~ymin, yend = ~ymax) %&gt;% add_annotations(&quot;Minimum uncertainty&quot;) }) Figure 1.8: Leveraging data associated with a geom_smooth() layer to display additional information about the model fit. Although it is not used in this example, it worth noting that when adding plotly layers to the output of ggplotly(), it will inherit mappings from the ggplot aesthetic mapping, which may or may not be desired, but the inherit argument in any of the add_*() functions may be set to FALSE to avoid this behavoir. 1.2.3 Modifying layers As mentioned previously, ggplotly() translates each ggplot2 layer into one or more plotly.js traces. In this translation, it is forced to make a number of assumptions about trace attribute values that may or may not be appropriate for the use case. The style() function is useful in this scenario, as it provides a way to modify trace attribute values in a plotly object. Before using it, you may want to inspect the actual traces in a given plotly object using the plotly_json() function. This function uses the listviewer package to display a convenient interactive view of the JSON object sent to plotly.js (de Jong and Russell 2016). By clicking on the arrow next to the data element, you can see the traces (data) behind the plot. In this case, we have three traces: one for the geom_point() layer and two for the geom_smooth() layer. plotly_json(p) Figure 1.9: Using listviewer to inspect a plotly object. Say, for example, we’d like to display information when hovering over points, but not when hovering over the fitted values or error bounds. The ggplot2 API has no semantics for making this distinction, but this is easily done in plotly.js by setting the hoverinfo attribute to &quot;none&quot;. Since the fitted values or error bounds are contained in the second and third traces, we can hide the information on just these traces using the traces attribute in the style() function: style(p, hoverinfo = &quot;none&quot;, traces = 2:3) --> References "],
["the-plotly-cookbook.html", "2 The plotly cookbook", " 2 The plotly cookbook This chapter demonstrates the rendering capabilities of plot_ly() through a series of examples. The plot_ly() function provides a direct interface to plotly.js, so anything in the figure reference can be specified via plot_ly(), but this chapter will focus more on the special semantics unique to the R package that can’t be found on the figure reference. Along the way, we will touch on some best practices in visualization. "],
["scatter-traces.html", "2.1 Scatter traces", " 2.1 Scatter traces A plotly visualization is composed of one (or more) trace(s), and every trace has a type. The default trace type, “scatter”, can be used to draw a large amount of geometries, and actually powers many of the add_*() functions such as add_markers(), add_lines(), add_paths(), add_segments(), add_ribbons(), and add_polygons(). Among other things, these functions make assumptions about the mode of the scatter trace, but any valid attribute(s) listed under the scatter section of the figure reference may be used to override defaults. The plot_ly() function has a number of arguments that make it easier to scale data values to visual aesthetics (e.g., color/colors, symbol/symbols, linetype/linetypes, size/sizes). These arguments are unique to the R package and dynamically determine what objects in the figure reference to populate (e.g., marker.color vs line.color). Generally speaking, the singular form of the argument defines the domain of the scale (data) and the plural form defines the range of the scale (visuals). To make it easier to alter default visual aesthetics (e.g., change all points from blue to black), “AsIs” values (values wrapped with the I() function) are interpreted as values that already live in visual space, and thus do not need to be scaled. The next section on scatterplots explores detailed use of the color/colors, symbol/symbols, &amp; size/sizes arguments. The section on lineplots explores detailed use of the linetype/linetypes. 2.1.1 Scatterplots The scatterplot is useful for visualizing the correlation between two quantitative variables. If you supply a numeric vector for x and y in plot_ly(), it defaults to a scatterplot, but you can also be explicit about adding a layer of markers/points via the add_markers() function. A common problem with scatterplots is overplotting, meaning that there are multiple observations occupying the same (or similar) x/y locations. There are a few ways to combat overplotting including: alpha transparency, hollow symbols, and 2D density estimation. Figure 2.1 shows how alpha transparency and hollow symbols can provide an improvement over the default. subplot( plot_ly(mpg, x = ~cty, y = ~hwy, name = &quot;default&quot;), plot_ly(mpg, x = ~cty, y = ~hwy) %&gt;% add_markers(alpha = 0.2, name = &quot;alpha&quot;), plot_ly(mpg, x = ~cty, y = ~hwy) %&gt;% add_markers(symbol = I(1), name = &quot;hollow&quot;) ) Figure 2.1: Three versions of a basic scatterplot In Figure 2.1, hollow circles are specified via symbol = I(1). By default, the symbol argument (as well as the color/size/linetype arguments) assumes value(s) are “data”, which need to be mapped to a visual palette (provided by symbols). Wrapping values with the I() function notifies plot_ly() that these values should be taken “AsIs”. If you compare the result of plot(1:25, 1:25, pch = 1:25) to Figure 2.2, you’ll see that plot_ly() can translate R’s plotting characters (pch), but you can also use plotly.js’ symbol syntax, if you desire. subplot( plot_ly(x = 1:25, y = 1:25, symbol = I(1:25), name = &quot;pch&quot;), plot_ly(mpg, x = ~cty, y = ~hwy, symbol = ~cyl, symbols = 1:3, name = &quot;cyl&quot;) ) Figure 2.2: Specifying symbol in a scatterplot When mapping a numeric variable to symbol, it creates only one trace, so no legend is generated. If you do want one trace per symbol, make sure the variable you’re mapping is a factor, as Figure 2.3 demonstrates. When plotting multiple traces, the default plotly.js color scale will apply, but you can set the color of every trace generated from this layer with color = I(&quot;black&quot;), or similar. p &lt;- plot_ly(mpg, x = ~cty, y = ~hwy, alpha = 0.3) subplot( add_markers(p, symbol = ~cyl, name = &quot;A single trace&quot;), add_markers(p, symbol = ~factor(cyl), color = I(&quot;black&quot;)) ) Figure 2.3: Mapping symbol to a factor The color argument adheres to similar rules as symbol: If numeric, color produces one trace, but colorbar is also generated to aide the decoding of colors back to data values. The colorbar() function can be used to customize the appearance of this automatically generated guide. The default colorscale is viridis, a perceptually-uniform colorscale (even when converted to black-and-white), and perceivable even to those with common forms of color blindness (Data Science 2016). If discrete, color produces one trace per value, meaning a legend is generated. If an ordered factor, the default colorscale is viridis (Garnier 2016); otherwise, it is the “Set2” palette from the RColorBrewer package (Neuwirth 2014) p &lt;- plot_ly(mpg, x = ~cty, y = ~hwy, alpha = 0.5) subplot( add_markers(p, color = ~cyl, showlegend = FALSE) %&gt;% colorbar(title = &quot;Viridis&quot;, len = 1/2, y = 1), add_markers(p, color = ~factor(cyl)) ) %&gt;% layout(showlegend = TRUE) Figure 2.4: Variations on a numeric color mapping. There are a number of ways to alter the default colorscale via the colors argument. This argument excepts: (1) a color brewer palette name (see the row names of RColorBrewer::brewer.pal.info for valid names), (2) a vector of colors to interpolate, or (3) a color interpolation function like colorRamp() or scales::colour_ramp(). Although this grants a lot of flexibility, one should be concious of using a sequential colorscale for numeric variables (&amp; ordered factors) as shown in 2.5, and a qualitative colorscale for discrete variables as shown in 2.6. (TODO: touch on lurking variables?) subplot( add_markers(p, color = ~cyl, colors = c(&quot;#132B43&quot;, &quot;#56B1F7&quot;)) %&gt;% colorbar(title = &quot;ggplot2 default&quot;, len = 1/3, y = 1), add_markers(p, color = ~cyl, colors = viridisLite::inferno(10)) %&gt;% colorbar(title = &quot;Inferno&quot;, len = 1/3, y = 2/3), add_markers(p, color = ~cyl, colors = colorRamp(c(&quot;red&quot;, &quot;white&quot;, &quot;blue&quot;))) %&gt;% colorbar(title = &quot;colorRamp&quot;, len = 1/3, y = 1/3) ) Figure 2.5: Three variations on a numeric color mapping subplot( add_markers(p, color = ~factor(cyl), colors = &quot;Pastel1&quot;), add_markers(p, color = ~factor(cyl), colors = colorRamp(c(&quot;red&quot;, &quot;blue&quot;))), add_markers(p, color = ~factor(cyl), colors = c(`4` = &quot;red&quot;, `5` = &quot;black&quot;, `6` = &quot;blue&quot;, `8` = &quot;green&quot;)) ) %&gt;% layout(showlegend = FALSE) Figure 2.6: Three variations on a discrete color mapping For scatterplots, the size argument controls the area of markers (unless otherwise specified via sizemode), and must be a numeric variable. The sizes argument controls the minimum and maximum size of circles, in pixels: subplot( add_markers(p, size = ~cyl, name = &quot;default&quot;), add_markers(p, size = ~cyl, sizes = c(1, 500), name = &quot;custom&quot;) ) 2.1.1.1 3D scatterplots To make a 3D scatterplot, just add a z attribute: plot_ly(mpg, x = ~cty, y = ~hwy, z = ~cyl) %&gt;% add_markers(color = ~cyl) Figure 2.7: A 3D scatterplot 2.1.1.2 Scatterplot matrices Scatterplot matrices can be made via plot_ly() and subplot(), but ggplotly() has a special method for translating ggmatrix objects from the GGally package to plotly objects (Schloerke et al. 2016). These objects are essentially a matrix of ggplot objects and are the underlying data structure which powers higher level functions in GGally, such as ggpairs() – a function for creating a generalized pairs plot (Emerson et al. 2013). The generalized pairs plot can be motivated as a generalization of the scatterplot matrix with support for categorical variables and different visual representations of the data powered by the grammar of graphics. Figure 2.8 shows an interactive version of the generalized pairs plot made via ggpairs() and ggplotly(). In Linking views without shiny, we explore how this framework can be extended to enable linked brushing in the generalized pairs plot. pm &lt;- GGally::ggpairs(iris) ggplotly(pm) Figure 2.8: An interactive version of the generalized pairs plot made via the ggpairs() function from the GGally package 2.1.2 Dotplots &amp; error bars A dotplot is similar to a scatterplot, except instead of two numeric axes, one is categorical. The usual goal of a dotplot is to compare value(s) on a numerical scale over numerous categories. In this context, dotplots are preferrable to pie charts since comparing position along a common scale is much easier than comparing angle or area (Cleveland and McGill 1984); (Bostock 2010). Furthermore, dotplots can be preferrable to bar charts, especially when comparing values within a narrow range far away from 0 (Few 2006). Also, when presenting point estimates, and uncertainty associated with those estimates, bar charts tend to exaggerate the difference in point estimates, and lose focus on uncertainty (Messing 2012). A popular application for dotplots (with error bars) is the so-called “coefficient plot” for visualizing the point estimates of coefficients and their standard error. The coefplot() function in the coefplot package (Lander 2016) and the ggcoef() function in the GGally both produce coefficient plots for many types of model objects in R using ggplot2, which we can translate to plotly via ggplotly(). Since these packages use points and segments to draw the coefficient plots, the hover information is not the best, and it’d be better to use error objects. Figure 2.9 uses the tidy() function from the broom package (Robinson 2016) to obtain a data frame with one row per model coefficient, and produce a coefficient plot with error bars along the x-axis. m &lt;- lm(Sepal.Length ~ Sepal.Width * Petal.Length * Petal.Width, data = iris) # arrange by estimate, then make term a factor to order categories in the plot d &lt;- broom::tidy(m) %&gt;% arrange(desc(estimate)) %&gt;% mutate(term = factor(term, levels = term)) plot_ly(d, x = ~estimate, y = ~term) %&gt;% add_markers(error_x = ~list(value = std.error)) %&gt;% layout(margin = list(l = 200)) Figure 2.9: A coefficient plot 2.1.3 Line plots This section surveys useful applications of add_lines() and add_paths(). The only difference between these functions is that add_lines() connects x/y pairs from left to right, instead of the order in which the data appears. Both functions understand the color, linetype, and alpha attributes5, as well as groupings defined by group_by(). Figure 1.2 uses group_by() to plot one line per city in the txhousing dataset using a single trace. Since there can only be one tooltip per trace, hovering over that plot does not reveal useful information. Although plotting many traces can be computationally expensive, it is necessary in order to display better information on hover. Since the color argument produces one trace per value (if the variable (city) is discrete), hovering on Figure 2.10 reveals the top ~10 cities at a given x value. Since 46 colors is too many to perceive in a single plot, Figure 2.10 also restricts the set of possible colors to black. plot_ly(txhousing, x = ~date, y = ~median) %&gt;% add_lines(color = ~city, colors = &quot;black&quot;, alpha = 0.2) Figure 2.10: Median house sales with one trace per city. Generally speaking, it’s hard to perceive more than 8 different colors/linetypes/symbols in a given plot, so sometimes we have to filter data to use these effectively. Here we use the dplyr package to find the top 5 cities in terms of average monthly sales (top5), then effectively filter the original data to contain just these cities via semi_join(). Once we have the data is filtered, mapping city to color or linetype is trivial. The color palette can be altered via the colors argument, and follows the same rules as scatterplots. The linetype palette can be altered via the linetypes argument, and accepts R’s lty values or plotly.js dash values. library(dplyr) top5 &lt;- txhousing %&gt;% group_by(city) %&gt;% summarise(m = mean(sales, na.rm = TRUE)) %&gt;% arrange(desc(m)) %&gt;% top_n(5) p &lt;- semi_join(txhousing, top5, by = &quot;city&quot;) %&gt;% plot_ly(x = ~date, y = ~median) subplot( add_lines(p, color = ~city), add_lines(p, linetype = ~city), shareX = TRUE, nrows = 2 ) 2.1.3.1 Density plots In Bars &amp; histograms, we leveraged a number of algorithms in R for computing the “optimal” number of bins for a histogram, via hist(), and routing those results to add_bars(). We can leverage the density() function for computing kernel density estimates in a similar way, and routing the results to add_lines(), as is done in 2.11. kerns &lt;- c(&quot;gaussian&quot;, &quot;epanechnikov&quot;, &quot;rectangular&quot;, &quot;triangular&quot;, &quot;biweight&quot;, &quot;cosine&quot;, &quot;optcosine&quot;) p &lt;- plot_ly() for (k in kerns) { d &lt;- density(txhousing$median, kernel = k, na.rm = TRUE) p &lt;- add_lines(p, x = d$x, y = d$y, name = k) } layout(p, xaxis = list(title = &quot;Median monthly price&quot;)) Figure 2.11: Various kernel density estimates. 2.1.3.2 Parallel Coordinates One very useful, but often overlooked, visualization technique is the parallel coordinates plot. Parallel coordinates provide a way to compare values along a common (or non-aligned) positional scale(s) – the most basic of all perceptual tasks – in more than 3 dimensions (Cleveland and McGill 1984). Usually each line represents every measurement for a given row (or observation) in a data set. When measurements are on very different scales, some care must be taken, and variables must transformed to be put on a common scale. As Figure 2.12 shows, even when variables are measured on a similar scale, it can still be a informative to transform variables in different ways. iris$obs &lt;- seq_len(nrow(iris)) iris_pcp &lt;- function(transform = identity) { iris[] &lt;- purrr::map_if(iris, is.numeric, transform) tidyr::gather(iris, variable, value, -Species, -obs) %&gt;% group_by(obs) %&gt;% plot_ly(x = ~variable, y = ~value, color = ~Species) %&gt;% add_lines(alpha = 0.3) } subplot( iris_pcp(), iris_pcp(scale), iris_pcp(scales::rescale) ) %&gt;% hide_legend() Figure 2.12: Parallel coordinates plots of the Iris dataset. On the left is the raw measurements. In the middle, each variable is scaled to have mean of 0 and standard deviation of 1. On the right, each variable is scaled to have a minimum of 0 and a maximum of 1. It is also worth noting that the GGally offers a ggparcoord() function which creates parallel coordinate plots via ggplot2, which we can convert to plotly via ggplotly(). In linked highlighting, parallel coordinates are linked to lower dimensional (but sometimes higher resolution) graphics of related data to guide multi-variate data exploration. 2.1.3.3 3D paths To make a path in 3D, use add_paths() in the same way you would for a 2D path, but add a third variable z, as Figure 2.13 does. plot_ly(mpg, x = ~cty, y = ~hwy, z = ~cyl) %&gt;% add_paths(color = ~displ) Figure 2.13: A path in 3D Figure 2.14 uses add_lines() instead of add_paths() to ensure the points are connected by the x axis instead of the row ordering. plot_ly(mpg, x = ~cty, y = ~hwy, z = ~cyl) %&gt;% add_lines(color = ~displ) Figure 2.14: A 3D line plot 2.1.4 Segments The add_segments() function essentially provides a way to connect two points ((x, y) to (xend, yend)) with a line. Segments form the building blocks for many useful chart types, including candlestick charts, a popular way to visualize stock prices. Figure 2.15 uses the quantmod package (Ryan 2016) to obtain stock price data for Microsoft and plots two segments for each day: one to encode the opening/closing values, and one to encode the daily high/low. library(quantmod) msft &lt;- getSymbols(&quot;MSFT&quot;, auto.assign = F) dat &lt;- as.data.frame(msft) dat$date &lt;- index(msft) dat &lt;- subset(dat, date &gt;= &quot;2016-01-01&quot;) names(dat) &lt;- sub(&quot;^MSFT\\\\.&quot;, &quot;&quot;, names(dat)) plot_ly(dat, x = ~date, xend = ~date, color = ~Close &gt; Open, colors = c(&quot;red&quot;, &quot;forestgreen&quot;), hoverinfo = &quot;none&quot;) %&gt;% add_segments(y = ~Low, yend = ~High, size = I(1)) %&gt;% add_segments(y = ~Open, yend = ~Close, size = I(3)) %&gt;% layout(showlegend = FALSE, yaxis = list(title = &quot;Price&quot;)) %&gt;% rangeslider() Figure 2.15: A candelstick chart 2.1.5 Ribbons Ribbons are useful for showing uncertainy bounds as a function of x. The add_ribbons() function creates ribbons and requires the arguments: x, ymin, and ymax. The augment() function from the broom package appends observational-level model components (e.g., fitted values stored as a new column .fitted) which is useful for extracting those components in a convenient form for visualization. Figure 2.16 shows the fitted values and uncertainty bounds from a linear model object. m &lt;- lm(mpg ~ wt, data = mtcars) broom::augment(m) %&gt;% plot_ly(x = ~wt, showlegend = FALSE) %&gt;% add_markers(y = ~mpg, color = I(&quot;black&quot;)) %&gt;% add_ribbons(ymin = ~.fitted - 1.96 * .se.fit, ymax = ~.fitted + 1.96 * .se.fit, color = I(&quot;gray80&quot;)) %&gt;% add_lines(y = ~.fitted, color = I(&quot;steelblue&quot;)) Figure 2.16: Plotting fitted values and uncertainty bounds of a linear model via the broom package. 2.1.6 Polygons The add_polygons() function is essentially equivalent to add_paths() with the fill attribute set to “toself”. Polygons from the basis for other, higher-level, geometries such as add_ribbons(), but can be useful in their own right. map_data(&quot;world&quot;, &quot;canada&quot;) %&gt;% group_by(group) %&gt;% plot_ly(x = ~long, y = ~lat, alpha = 0.2) %&gt;% add_polygons(hoverinfo = &quot;none&quot;, color = I(&quot;black&quot;)) %&gt;% add_markers(text = ~paste(name, &quot;&lt;br /&gt;&quot;, pop), hoverinfo = &quot;text&quot;, color = I(&quot;red&quot;), data = maps::canada.cities) %&gt;% layout(showlegend = FALSE) Figure 2.17: A map of Canada using the default cartesian coordinate system. References "],
["maps.html", "2.2 Maps", " 2.2 Maps 2.2.1 Using scatter traces As shown in polygons, it is possible to create maps using plotly’s default (cartesian) coordinate system, but plotly.js also has support for plotting scatter traces on top of either a custom geo layout or a mapbox layout. Figure 2.18 compares the three different layout options in a single subplot. dat &lt;- map_data(&quot;world&quot;, &quot;canada&quot;) %&gt;% group_by(group) map1 &lt;- plot_ly(dat, x = ~long, y = ~lat) %&gt;% add_paths(size = I(1)) %&gt;% add_segments(x = -100, xend = -50, y = 50, 75) map2 &lt;- plot_mapbox(dat, x = ~long, y = ~lat) %&gt;% add_paths(size = I(2)) %&gt;% add_segments(x = -100, xend = -50, y = 50, 75) %&gt;% layout(mapbox = list(zoom = 0, center = list(lat = ~median(lat), lon = ~median(long)) )) # geo() is the only object type which supports different map projections map3 &lt;- plot_geo(dat, x = ~long, y = ~lat) %&gt;% add_markers(size = I(1)) %&gt;% add_segments(x = -100, xend = -50, y = 50, 75) %&gt;% layout(geo = list(projection = list(type = &quot;mercator&quot;))) subplot(map1, map2) %&gt;% subplot(map3, nrows = 2) %&gt;% hide_legend() Figure 2.18: Three different ways to render a map. On the top left is plotly’s default cartesian coordinate system, on the top right is plotly’s custom geographic layout, and on the bottom is mapbox. Any of the add_*() functions found under scatter traces should work as expected on plotly-geo (initialized via plot_geo()) or plotly-mapbox (initialized via plot_mapbox()) objects. You can think of plot_geo() and plot_mapbox() as special cases (or more opiniated versions) of plot_ly(). For one, they won’t allow you to mix scatter and non-scatter traces in a single plot object, which you probably don’t want to do anyway. In order to enable Figure 2.18, plotly.js can’t make this restriction, but since we have subplot() in R, we can make this restriction without sacrificing flexibility. 2.2.2 Choropleths In addition to scatter traces, plotly-geo objects can also create a choropleth trace/layer. Figure 2.19 shows the population density of the U.S. via a choropleth, and also layers on markers for the state center locations, using the U.S. state data from the datasets package (R Core Team 2016). By simply providing a z attribute, plotly-geo objects will try to create a choropleth, but you’ll also need to provide locations and a locationmode. density &lt;- state.x77[, &quot;Population&quot;] / state.x77[, &quot;Area&quot;] g &lt;- list( scope = &#39;usa&#39;, projection = list(type = &#39;albers usa&#39;), lakecolor = toRGB(&#39;white&#39;) ) plot_geo() %&gt;% add_trace( z = ~density, text = state.name, locations = state.abb, locationmode = &#39;USA-states&#39; ) %&gt;% add_markers( x = state.center[[&quot;x&quot;]], y = state.center[[&quot;y&quot;]], size = I(2), symbol = I(8), color = I(&quot;white&quot;), hoverinfo = &quot;none&quot; ) %&gt;% layout(geo = g) Figure 2.19: A map of U.S. population density using the state.x77 data from the datasets package. References "],
["bars-histograms.html", "2.3 Bars &amp; histograms", " 2.3 Bars &amp; histograms The add_bars() and add_histogram() functions wrap the bar and histogram plotly.js trace types. The main difference between them is that bar traces require bar heights (both x and y), whereas histogram traces require just a single variable, and plotly.js handles binning in the browser.6 And perhaps confusingly, both of these functions can be used to visualize the distribution of either a numeric or a discrete variable. So, essentially, the only difference between them is where the binning occurs. Figure 2.20 compares the default binning algorithm in plotly.js to a few different algorithms available in R via the hist() function. Although plotly.js has the ability to customize histogram bins via xbins/ybins, R has diverse facilities for estimating the optimal number of bins in a histogram that we can easily leverage.7 The hist() function alone allows us to reference 3 famous algorithms by name (Sturges 1926); (Freedman and Diaconis 1981); (Scott 1979), but there are also packages (e.g. the histogram package) which extend this interface to incorporate more methodology (Mildenberger, Rozenholc, and Zasada. 2009). The price_hist() function below wraps the hist() function to obtain the binning results, and map those bins to a plotly version of the histogram using add_bars(). p1 &lt;- plot_ly(diamonds, x = ~price) %&gt;% add_histogram(name = &quot;plotly.js&quot;) price_hist &lt;- function(method = &quot;FD&quot;) { h &lt;- hist(diamonds$price, breaks = method, plot = FALSE) plot_ly(x = h$mids, y = h$counts) %&gt;% add_bars(name = method) } subplot( p1, price_hist(), price_hist(&quot;Sturges&quot;), price_hist(&quot;Scott&quot;), nrows = 4, shareX = TRUE ) Figure 2.20: plotly.js’s default binning algorithm versus R’s hist() default Figure 2.21 demonstrates two ways of creating a basic bar chart. Although the visual results are the same, its worth noting the difference in implementation. The add_histogram() function sends all of the observed values to the browser and lets plotly.js perform the binning. It takes more human effort to perform the binning in R, but doing so has the benefit of sending less data, and requiring less computation work of the web browser. In this case, we have only about 50,000 records, so there is much of a difference in page load times or page size. However, with 1 Million records, page load time more than doubles and page size nearly doubles.8 p1 &lt;- plot_ly(diamonds, x = ~cut) %&gt;% add_histogram() p2 &lt;- diamonds %&gt;% dplyr::count(cut) %&gt;% plot_ly(x = ~cut, y = ~n) %&gt;% add_bars() subplot(p1, p2) %&gt;% hide_legend() Figure 2.21: Number of diamonds by cut. 2.3.1 Multiple numeric distributions It is often useful to see how the numeric distribution changes with respect to a discrete variable. When using bars to visualize multiple numeric distributions, I recommend plotting each distribution on its own axis, rather than trying to overlay them on a single axis.9. This is where the subplot() infrastructure, and its support for trellis displays, comes in handy. Figure 2.22 shows a trellis display of diamond price by diamond color. Note how the one_plot() function defines what to display on each panel, then a split-apply-recombine strategy is employed to generate the trellis display. one_plot &lt;- function(d) { plot_ly(d, x = ~price) %&gt;% add_annotations( ~unique(clarity), x = 0.5, y = 1, xref = &quot;paper&quot;, yref = &quot;paper&quot;, showarrow = FALSE ) } diamonds %&gt;% split(.$clarity) %&gt;% lapply(one_plot) %&gt;% subplot(nrows = 2, shareX = TRUE, titleX = FALSE) %&gt;% hide_legend() Figure 2.22: A trellis display of diamond price by diamond clarity. 2.3.2 Multiple discrete distributions Visualizing multiple discrete distributions is difficult. The subtle complexity is due to the fact that both counts and proportions are important for understanding multi-variate discrete distributions. Figure 2.23 presents diamond counts, divided by both their cut and clarity, using a grouped bar chart. plot_ly(diamonds, x = ~cut, color = ~clarity) %&gt;% add_histogram() Figure 2.23: A grouped bar chart Figure 2.23 is useful for comparing the number of diamonds by clarity, given a type of cut. For instance, within “Ideal” diamonds, a cut of “VS1” is most popular, “VS2” is second most popular, and “I1” the least popular. The distribution of clarity within “Ideal” diamonds seems to be fairly similar to other diamonds, but it’s hard to make this comparison using raw counts. Figure 2.24 makes this comparison easier by showing the relative frequency of diamonds by clarity, given a cut. # number of diamonds by cut and clarity (n) cc &lt;- count(diamonds, cut, clarity) # number of diamonds by cut (nn) cc2 &lt;- left_join(cc, count(cc, cut, wt = n)) cc2 %&gt;% mutate(prop = n / nn) %&gt;% plot_ly(x = ~cut, y = ~prop, color = ~clarity) %&gt;% add_bars() %&gt;% layout(barmode = &quot;stack&quot;) Figure 2.24: A stacked bar chart showing the proportion of clarity within This type of plot, also known as a spine plot, is a special case of a mosaic plot. In a mosaic plot, you can scale both bar widths and heights according to discrete distributions. For mosaic plots, I recommend using the ggmosaic package (Jeppson, Hofmann, and Cook, n.d.), which implements a custom ggplot2 geom designed for mosaic plots, which we can convert to plotly via ggplotly(). Figure 2.25 show a mosaic plot of cut by clarity. Notice how the bar widths are scaled proportional to the cut frequency. library(ggmosaic) p &lt;- ggplot(data = cc) + geom_mosaic(aes(weight = n, x = product(cut), fill = clarity)) #&gt; Error: GeomMosaic was built with an incompatible version of ggproto. #&gt; Please reinstall the package that provides this extension. ggplotly(p) Figure 2.25: Using ggmosaic and ggplotly() to create advanced interactive visualizations of categorical data References "],
["boxplots.html", "2.4 Boxplots", " 2.4 Boxplots Boxplots encode the five number summary of a numeric variable, and are more efficient than trellis displays of histograms for comparing many numeric distributions. The add_boxplot() function requires one numeric variable, and guarantees boxplots are oriented correctly, regardless of whether the numeric variable is placed on the x or y scale. As Figure 2.26 shows, on the axis orthogonal to the numeric axis, you can provide a discrete variable (for conditioning) or supply a single value (to name the axis category). p &lt;- plot_ly(diamonds, y = ~price, color = I(&quot;black&quot;), alpha = 0.1, boxpoints = &quot;suspectedoutliers&quot;) p1 &lt;- p %&gt;% add_boxplot(x = &quot;Overall&quot;) p2 &lt;- p %&gt;% add_boxplot(x = ~cut) subplot( p1, p2, shareY = TRUE, widths = c(0.2, 0.8), margin = 0 ) %&gt;% hide_legend() Figure 2.26: Overall diamond price and price by cut. If you want to partition by more than one discrete variable, I recommend mapping the interaction of those variables to the discrete axis, and coloring by the nested variable, as Figure 2.27 does with diamond clarity and cut. plot_ly(diamonds, x = ~price, y = ~interaction(clarity, cut)) %&gt;% add_boxplot(color = ~clarity) %&gt;% layout(yaxis = list(title = &quot;&quot;), margin = list(l = 100)) Figure 2.27: Diamond prices by cut and clarity. It is also helpful to sort the boxplots according to something meaningful, such as the median price. Figure 2.28 presents the same information as Figure 2.27, but sorts the boxplots by their median, and makes it immediately clear that diamonds with a cut of “SI2” have the highest diamond price, on average. d &lt;- diamonds %&gt;% mutate(cc = interaction(clarity, cut)) # interaction levels sorted by median price lvls &lt;- d %&gt;% group_by(cc) %&gt;% summarise(m = median(price)) %&gt;% arrange(m) %&gt;% .[[&quot;cc&quot;]] plot_ly(d, x = ~price, y = ~factor(cc, lvls)) %&gt;% add_boxplot(color = ~clarity) %&gt;% layout(yaxis = list(title = &quot;&quot;), margin = list(l = 100)) Figure 2.28: Diamond prices by cut and clarity, sorted by price median. Similar to add_histogram(), add_boxplot() sends the raw data to the browser, and lets plotly.js compute summary statistics. Unfortunately, plotly.js does not yet allow precomputed statistics for boxplots.10 Follow the issue here https://github.com/plotly/plotly.js/issues/242↩ "],
["d-frequencies.html", "2.5 2D frequencies", " 2.5 2D frequencies 2.5.1 Rectangular binning in plotly.js The plotly package provides two functions for displaying rectangular bins: add_heatmap() and add_histogram2d(). For numeric data, the add_heatmap() function is a 2D analog of add_bars() (bins must be pre-computed), and the add_histogram2d() function is a 2D analog of add_histogram() (bins can be computed in the browser). Thus, I recommend add_histogram2d() for exploratory purposes, since you don’t have to think about how to perform binning. It also provides a useful zsmooth attribute for effectively increasing the number of bins (currently, “best” performs a bi-linear interpolation, a type of nearest neighbors algorithm), and nbinsx/nbinsy attributes to set the number of bins in the x and/or y directions. Figure 2.29 compares three different uses of add_histogram(): (1) plotly.js’ default binning algorithm, (2) the default plus smoothing, (3) setting the number of bins in the x and y directions. Its also worth noting that filled contours, instead of bins, can be used in any of these cases by using histogram2dcontour() instead of histogram2d(). p &lt;- plot_ly(diamonds, x = ~log(carat), y = ~log(price)) subplot( add_histogram2d(p) %&gt;% colorbar(title = &quot;default&quot;, len = 1/3, y = 1) %&gt;% layout(xaxis = list(title = &quot;default&quot;)), add_histogram2d(p, zsmooth = &quot;best&quot;) %&gt;% colorbar(title = &quot;zsmooth&quot;, len = 1/3, y = 2/3 - 0.05) %&gt;% layout(xaxis = list(title = &quot;zsmooth&quot;)), add_histogram2d(p, nbinsx = 60, nbinsy = 60) %&gt;% colorbar(title = &quot;nbins&quot;, len = 1/3, y = 1/3 - 0.1) %&gt;% layout(xaxis = list(title = &quot;nbins&quot;)), shareY = TRUE, titleX = TRUE ) Figure 2.29: Three different uses of histogram2d() 2.5.2 Rectangular binning in R In Bars &amp; histograms, we leveraged a number of algorithms in R for computing the “optimal” number of bins for a histogram, via hist(), and routing those results to add_bars(). There is a surprising lack of research and computational tools for the 2D analog, and among the research that does exist, solutions usually depend on characteristics of the unknown underlying distribution, so the typical approach is to assume a Gaussian form (Scott 1992). Practically speaking, that assumption is not very useful, but 2D kernel density estimation provides a useful alternative that tends to be more robust to changes in distributional form. Although kernel density estimation requires choice of kernel and a bandwidth parameter, the kde2d() function from the MASS package provides a well-supported rule-of-thumb for estimating the bandwidth of a Gaussian kernel density (Venables and Ripley 2002). Figure 2.30 uses kde2d() to estimate a 2D density, scales the relative frequency to an absolute frequency, then uses the add_heatmap() function to display the results as a heatmap. kde_count &lt;- function(x, y, ...) { kde &lt;- MASS::kde2d(x, y, ...) df &lt;- with(kde, setNames(expand.grid(x, y), c(&quot;x&quot;, &quot;y&quot;))) # The &#39;z&#39; returned by kde2d() is a proportion, but we can scale it to a count df$count &lt;- with(kde, c(z) * length(x) * diff(x)[1] * diff(y)[1]) data.frame(df) } kd &lt;- with(diamonds, kde_count(log(carat), log(price), n = 30)) plot_ly(kd, x = ~x, y = ~y, z = ~count) %&gt;% add_heatmap() %&gt;% colorbar(title = &quot;Number of diamonds&quot;) Figure 2.30: 2D Density estimation via the kde2d() function 2.5.3 Categorical axes The functions add_histogram(), add_histogram2contour(), and add_heatmap() all support categorical axes. Thus, add_histogram() can be used to easily display 2-way contingency tables, but since its easier to compare values along a common scale rather than compare colors (Cleveland and McGill 1984), I recommend creating grouped bar charts instead. The add_heatmap() function can still be useful for categorical axes, however, as it allows us to display whatever quantity we want along the z axis (color). Figure 2.31 uses add_heatmap() to display a correlation matrix. Notice how the limits arguments in the colorbar() function can be used to expand the limits of the color scale to reflect the range of possible correlations (something that is not easily done in plotly.js). corr &lt;- cor(diamonds[vapply(diamonds, is.numeric, logical(1))]) plot_ly(x = rownames(corr), y = colnames(corr), z = corr) %&gt;% add_heatmap() %&gt;% colorbar(limits = c(-1, 1)) Figure 2.31: Displaying a correlation matrix with add_heatmap() and controling the scale limits with colorbar(). References "],
["other-3d-plots.html", "2.6 Other 3D plots", " 2.6 Other 3D plots In scatter traces, we saw how to make 3D scatter plots and 3D paths/lines, but plotly.js also supports 3D surface and triangular mesh surfaces (aka trisurf plots). For a nice tutorial on creating trisurf plots in R via plot_ly(), I recommend visiting this tutorial. Creating 3D surfaces with add_surface() is a lot like creating heatmaps with add_heatmap(). In fact, you can even create 3D surfaces over categorical x/y (try changing add_heatmap() to add_surface() in Figure 2.31)! That being said, there should be a sensible ordering to the x/y axes in a surface plot since plotly.js interpolates z values. Usually the 3D surface is over a continous region, as is done in Figure 2.32 to display the height of a volcano. If a numeric matrix is provided to z as in Figure 2.32, the x and y attributes do not have to be provided, but if they are, the length of x should match the number of rows in the matrix and y should match the number of columns. x &lt;- seq_len(nrow(volcano)) + 100 y &lt;- seq_len(ncol(volcano)) + 500 plot_ly() %&gt;% add_surface(x = ~x, y = ~y, z = ~volcano) Figure 2.32: A 3D surface of volcano height. -->"],
["arranging-multiple-views.html", "3 Arranging multiple views", " 3 Arranging multiple views One technique essential to high-dimensional data analysis is the ability to arrange multiple views. Ideally, these views are linked in some way to foster comparisons (the next chapter discusses linking techniques). The next section, Arranging htmlwidgets describes techniques for arranging htmlwidget objects, which many R packages for creating web-based data visualizations build upon, including plotly. Typically interactivity is isolated within an htmlwidget object, but Linking views without shiny explores some more recent work on enabling interactivity across htmlwidget objects. The following section, Subplots describes the subplot() function, which is useful for merging multiple plotly objects into a single htmlwidget object. The main benefit of merging (rather than arranging) plotly objects is that it gives us the ability to synchronize zoom and pan events across multiple axes. The last section, Navigating many views discusses some useful tools for restricting focus on interesting views when there are more views than you can possibly digest visually. "],
["arranging-htmlwidgets.html", "3.1 Arranging htmlwidgets", " 3.1 Arranging htmlwidgets Since plotly objects inherit properties from an htmlwidget object, any method that works for arranging htmlwidgets also works for plotly objects. In some sense, an htmlwidget object is just a collection of HTML tags, and the htmltools package provides some useful functions for working with HTML tags (RStudio and Inc. 2016). The tagList() function gathers multiple HTML tags into a tag list, and when printing a tag list inside of a knitr/rmarkdown document (Xie 2016); (Allaire et al. 2016), it knows to render as HTML. When printing outside of this context (e.g., at the command line), a tag list prints as a character string by default. In order to view the rendered HTML, provide the tag list to the browsable() function. library(htmltools) library(plotly) p &lt;- plot_ly(x = rnorm(100)) tagList(p, p) Figure 3.1: Printing multiple htmlwidget objects with tagList(). To render tag lists at the command line, wrap them in browsable() Figure 3.1 renders two plots, each in its own row spanning the width of the page, because each htmlwidget object is an HTML &lt;div&gt; tag. More often than not, it is desirable to arrange multiple plots in a given row, and there are a few ways to do that. A very flexible approach is to wrap all of your plots in a flexbox (i.e., an HTML &lt;div&gt; with display: flex Cascading Style Sheets (CSS) property). The tags$div() function from htmltools provides a way to wrap a &lt;div&gt; around both tag lists and htmlwidget objects, and set attributes, such as style. As Figure 3.2 demonstrates, this approach also provides a nice way to add custom styling to the page, such as borders around each panel. tags$div( style = &quot;display: flex; flex-wrap: wrap&quot;, tags$div(p, style = &quot;width: 50%; padding: 1em; border: solid;&quot;), tags$div(p, style = &quot;width: 50%; padding: 1em; border: solid;&quot;), tags$div(p, style = &quot;width: 100%; padding: 1em; border: solid;&quot;) ) Figure 3.2: Arranging multiple htmlwidgets with flexbox Another way to arrange multiple htmlwidget objects on a single page is to leverage the fluidPage(), fluidRow(), and column() functions from the shiny package. library(shiny) fluidPage( fluidRow(p), fluidRow( column(6, p), column(6, p) ) ) Figure 3.3: Arranging multiple htmlwidgets with fluidPage() from the shiny package. All the arrangement approaches discussed thus far are agnostic to output format, meaning that they can be used to arrange htmlwidgets within any knitr/rmarkdown document.11 If the htmlwidgets do not need to be embedded within a larger document that requires an opininated output format, the flexdashboard package provides a rmarkdown template for generating dashboards, with a convenient syntax for arranging views (Allaire 2016). References "],
["merging-plotly-objects.html", "3.2 Merging plotly objects", " 3.2 Merging plotly objects The subplot() function provides a flexible interface for merging multiple plotly objects into a single object (i.e., view). It is more flexible than most trellis display frameworks (e.g., ggplot2’s facet_wrap()) as you don’t have to condition on a value of common variable in each display (Richard A. Becker 1996). Its capabilities and interface is similar to the grid.arrange() function from the gridExtra package, which allows you to arrange multiple grid grobs in a single view, effectively providing a way to arrange (possibly unrelated) ggplot2 and/or lattice plots in a single view (R Core Team 2016); (Auguie 2016); (Sarkar 2008). Figure 3.4 shows the most simple way to use subplot() which is to directly supply plotly objects. library(plotly) p1 &lt;- plot_ly(economics, x = ~date, y = ~unemploy) %&gt;% add_lines(name = &quot;unemploy&quot;) p2 &lt;- plot_ly(economics, x = ~date, y = ~uempmed) %&gt;% add_lines(name = &quot;uempmed&quot;) subplot(p1, p2) Figure 3.4: The most basic use of subplot() to merge multiple plotly objects into a single plotly object. Although subplot() accepts an arbitrary number of plot objects, passing a list of plots can save typing and redundant code when dealing with a large number of plots. Figure 3.5 shows one time series for each variable in the economics dataset and share the x-axis so that zoom/pan events are synchronized across each series: vars &lt;- setdiff(names(economics), &quot;date&quot;) plots &lt;- lapply(vars, function(var) { plot_ly(economics, x = ~date, y = as.formula(paste0(&quot;~&quot;, var)), name = var) %&gt;% add_lines() }) subplot(plots, nrows = length(plots), shareX = TRUE, titleX = FALSE) Figure 3.5: Five different economic variables on different y scales and a common x scale. Zoom and pan events in the x-direction are synchronized across plots. A plotly subplot is a single plotly graph with multiple traces anchored on different axes. If you pre-specify an axis ID for each trace, subplot() will respect that ID. Figure 3.6 uses this fact in correspondence with the fact that mapping a discrete variable to color creates one trace per value. In addition to providing more control over trace placement, this provides a convenient way to control coloring (we could have symbol/linetype to acheive the same effect). economics %&gt;% tidyr::gather(variable, value, -date) %&gt;% transform(id = as.integer(factor(variable))) %&gt;% plot_ly(x = ~date, y = ~value, color = ~variable, colors = &quot;Dark2&quot;, yaxis = ~paste0(&quot;y&quot;, id)) %&gt;% add_lines() %&gt;% subplot(nrows = 5, shareX = TRUE) Figure 3.6: Pre-populating y axis IDs. Conceptually, subplot() provides a way to place a collection of plots into a table with a given number of rows and columns. The number of rows (and, by consequence, the number of columns) is specified via the nrows argument. By default each row/column shares an equal proportion of the overall height/width, but as shown in Figure 3.7 the default can be changed via the heights and widths arguments. Figure 3.7: A visual diagram of controling the heights of rows and widths of columns. This flexibility is quite useful for a number of visualizations, for example, as shown in Figure 3.8, a joint density plot is really of subplot of joint and marginal densities. The heatmaply package is great example of leveraging subplot() in a similar way to create interactive dendograms (Galili 2016). x &lt;- rnorm(100) y &lt;- rnorm(100) s &lt;- subplot( plot_ly(x = x, color = I(&quot;black&quot;)), plotly_empty(), plot_ly(x = x, y = y, color = I(&quot;black&quot;)), plot_ly(y = y, color = I(&quot;black&quot;)), nrows = 2, heights = c(0.2, 0.8), widths = c(0.8, 0.2), shareX = TRUE, shareY = TRUE, titleX = FALSE, titleY = FALSE ) layout(s, showlegend = FALSE) Figure 3.8: A joint density plot with synchronized axes. 3.2.1 Recursive subplots The subplot() function returns a plotly object so it can be modified like any other plotly object. This effectively means that subplots work recursively (i.e., you can have subplots within subplots). This idea is useful when your desired layout doesn’t conform to the table structure described in the previous section. In fact, you can think of a subplot of subplots like a spreadsheet with merged cells. Figure 3.9 gives a basic example where each row of the outer-most subplot contains a different number of columns. plotList &lt;- function(nplots) { lapply(seq_len(nplots), function(x) plot_ly()) } s1 &lt;- subplot(plotList(6), nrows = 2, shareX = TRUE, shareY = TRUE) s2 &lt;- subplot(plotList(2), shareY = TRUE) subplot(s1, s2, plot_ly(), nrows = 3, margin = 0.04, heights = c(0.6, 0.3, 0.1)) Figure 3.9: Recursive subplots. The concept is particularly useful when you want plot(s) in a given row to have different widths from plot(s) in another row. Figure 3.10 uses this recursive behavior to place many bar charts in the first row, and a single choropleth in the second row. # specify some map projection/options g &lt;- list( scope = &#39;usa&#39;, projection = list(type = &#39;albers usa&#39;), lakecolor = toRGB(&#39;white&#39;) ) # create a map of population density density &lt;- state.x77[, &quot;Population&quot;] / state.x77[, &quot;Area&quot;] map &lt;- plot_geo(z = ~density, text = state.name, locations = state.abb, locationmode = &#39;USA-states&#39;) %&gt;% layout(geo = g) # create a bunch of horizontal bar charts vars &lt;- colnames(state.x77) barcharts &lt;- lapply(vars, function(var) { plot_ly(x = state.x77[, var], y = state.name) %&gt;% add_bars(orientation = &quot;h&quot;, name = var) %&gt;% layout(showlegend = FALSE, hovermode = &quot;y&quot;, yaxis = list(showticklabels = FALSE)) }) subplot( subplot(barcharts, margin = 0.01), map, nrows = 2, heights = c(0.3, 0.7), margin = 0.1 ) Figure 3.10: Multiple bar charts of US statistics by state in a subplot with a choropleth of population density 3.2.2 ggplot2 subplots Underneath the hood, ggplot2 facets are implemented as subplots, which enables the synchronized zoom events on shared axes. Since subplots work recursively, it is also possible to have a subplot of ggplot2 faceted plots, as Figure 3.11 shows. Moreover, subplot() can understand ggplot objects, so there is no need to translate them to plotly object via ggplotly() (unless you want to leverage some of the ggplotly() arguments, such as tooltip for customizing information displayed on hover). e &lt;- tidyr::gather(economics, variable, value, -date) gg1 &lt;- ggplot(e, aes(date, value)) + geom_line() + facet_wrap(~variable, scales = &quot;free_y&quot;, ncol = 1) gg2 &lt;- ggplot(e, aes(factor(1), value)) + geom_violin() + facet_wrap(~variable, scales = &quot;free_y&quot;, ncol = 1) + theme(axis.text = element_blank(), axis.ticks = element_blank()) subplot(gg1, gg2) %&gt;% layout(margin = list(l = 50)) Figure 3.11: Arranging multiple faceted ggplot2 plots into a plotly subplot. References "],
["navigating-many-views.html", "3.3 Navigating many views", " 3.3 Navigating many views Sometimes you have to consider way more views than you can possibly digest visually. In Multiple linked views, we explore some useful techniques for implementing the popular visualization mantra from Shneiderman (1996): “Overview first, zoom and filter, then details-on-demand.” In fact, Figure 4.3 from that section provides an example of this mantra put into practice. The correlation matrix provides an overview of the correlation structure between all the variables, and by clicking a cell, it populates a scatterplot between those two specific variables. This works fine with tens or hundreds or variables, but once you have thousands or tens-of-thousands of variables, this technique begins to fall apart. At that point, you may be better off defining a range of correlations that you’re interested in exploring, or better yet, incorporating another measure (e.g., a test statistic), then focusing on views that match a certain criteria. Tukey and Tukey (n.d.) first described the idea of using quantitative measurements of scatterplot characteristics (e.g. correlation) to help guide exploratory analysis of many variables. This idea, coined scagnostics (short for scatterplot diagnostics), has since been made explicit, and many measures have been explored, even measures specifically useful for time-series have been proposed (Wilkinson 2005); (Wilkinson and Wills 2008); (Dang and Wilkinson 2012). Probably the most universally useful scagnostic is the outlying measure which helps identify projections of the data space that contain outlying observations. Of course, the idea of associating quantitative measures with a graphical display of data can be generalized to include more that just scatterplots, and in this more general case, these measures are sometimes referred to as cognostics. The same problems and principles that inspired scagnostics has inspired work on more general divide &amp; recombine technique(s) for working with navigating through many statistical artifacts (Cleveland and Hafen 2014); (Saptarshi Guha and Cleveland 2012), including visualizations (Hafen et al. 2013). The trelliscope package provides a system for computing arbitrary cognostics on each panel of a trellis display as well as an interactive graphical user interface for defining (and navigating through) interesting panels based on those cognostics (Hafen 2016). This system also allows users to define the graphical method for displaying each panel, so plotly graphs can easily be embedded. The trelliscope package is currently built upon shiny, but as Figure 3.12 demonstrates, the trelliscopecore package provides lower-level tools that allow one to create trelliscope displays without shiny. library(trelliscopecore) library(dplyr) library(plotly) # cognostics data frame iris_cog_df &lt;- iris %&gt;% group_by(Species) %&gt;% summarise( mean_sl = cog(mean(Sepal.Length), desc = &quot;mean sepal length&quot;), mean_sw = cog(mean(Sepal.Width), desc = &quot;mean sepal length&quot;), mean_pl = cog(mean(Petal.Length), desc = &quot;mean sepal length&quot;), mean_pw = cog(mean(Petal.Width), desc = &quot;mean sepal length&quot;) ) iris_cog_df &lt;- as_cognostics(iris_cog_df, cond_cols = &quot;Species&quot;, key_col = &quot;Species&quot;) # list of panels panels &lt;- iris %&gt;% split(iris$Species) %&gt;% lapply(function(x) { plot_ly(x, x = ~Sepal.Length, y = ~Sepal.Width) %&gt;% config(collaborate = FALSE) }) base_path &lt;- tempdir() write_panels(panels, base_path = base_path, name = &quot;iris&quot;) write_display_obj( iris_cog_df, panel_example = panels[[1]], base_path = base_path, name = &quot;iris&quot; ) prepare_display(base_path) view_display(base_path) Figure 3.12: Using plotly within a trelliscope --> References "],
["multiple-linked-views.html", "4 Multiple linked views ", " 4 Multiple linked views "],
["linking-views-with-shiny.html", "4.1 Linking views with shiny", " 4.1 Linking views with shiny 4.1.1 Accessing events in shiny The plotly.js library emits custom events when a user interacts directly with a graph. The event_data() function provides a mechanism for accessing the data corresponding to those events within a shiny app. The shiny app in Figure 4.1 is designed to demonstrate the most useful plotly events one may access via event_data(): mouse hover (&quot;plotly_hover&quot;), click (&quot;plotly_click&quot;), and click+drag (&quot;plotly_selected&quot;). All of these events return selections on the data scale, not on a pixel scale, which is useful for updating views. There are currently four different modes for click+drag interactions in plotly.js, but only two will trigger a &quot;plotly_selected&quot; event: rectangular and lasso selection. The other two drag modes, zoom and pan, both emit a &quot;plotly_relayout&quot; event which could be useful for say, providing global context in relation to a zoom event and/or recomputing a model based on new x/y limits. In Figure 4.1, the default click+drag mode was set to rectangular selection set via the dragmode attribute, but the mode can also be changed interactively via the mode bar at the top of the graph. The video in Figure 4.1 helps demonstrate how different user events cause different blocks of code to be evaluated on the R server.12 Conceptually, you can think of events as different inputs that becomes invalidated when the event is triggered by plotly.js. Moreover, similar to restrictions placed on references to input value(s) in shiny, event_data() has to be called within a reactive expressions. As RStudio’s lesson on reactive expressions points out: “A reactive expression is an R expression that uses widget input [(e.g., event_data())] and returns a value.” Any of the render*() functions in shiny turn a regular R expression into a reactive expression. In Figure 4.1, every use of event_data() appears within renderPrint() since we only need to display the result of the event on the user interface with verbatimTextOutput(). In the next section, we use the return result of event_data() to display more interesting and informative views of user events. Figure 4.1: A video demonstration of plotly events in shiny. The video can be accessed here 4.1.2 Updating views Obtaining data from a plotly event is easy, but updating view(s) based on the result of an event can be difficult. To start with something fairly easy, consider two scatterplots showing the same observations, but on different axes (i.e.., a subset of a scatterplot matrix). Figure 4.2 shows a linked lasso brush between two scatterplots. The main idea is that we first plot all the observations in black, then highlight the selection by adding an additional layer of selected points in red using the data returned by event_data(). In order to guarantee that we can uniquely identify observations in the event data, it is also crucial that we attach a key attribute to each observation (here the rownames of the data), which we can then use to filter the original data down to the selected observations. Figure 4.2 consciously updates the source of the selection (the top plot) to match the visual characteristics of the target (the bottom plot). In general, whenever linking views to display graphical selection(s), matching the visual characteristics of the selection both the source and target(s) can aide interpretation, especially when using interactive graphics to present results to others. Although the update rule in Figure 4.2 is to simply layer on additional points, a full redraw is performed during the update, which can impact performance when dealing with a large amount of graphical elements. Figure 4.2 could be made slightly more efficient by just changing the color of selected points, or dimming the non-selected points, rather than plotting an extra layer of points. However, this technique does not work for chart types that display aggregate values (e.g., how do you dim non-selected values in a box plot?). For this reason, in Linking views without shiny, selections are implemented as an additional layer, but avoid the full redraw required when updating plot via shiny reactive framework.13 Figure 4.2: A video demonstration of linked brushing in a shiny app. The video can be accessed here and the code to run the example is here Since the update rule is the same for each view in Figure 4.2, we end up with a lot of redundant code that can be made more modular, as shown here. Making code more modular not only makes for less reading, but it leaves you less prone to making mistakes. Since the only difference between the two plots is the x/y variables, we can write a function that accepts x/y variables as input, and output a plotly object. Since this function outputs a plotly object, and is dependent upon event_data(), which can only be called within a reactive expression, this function can only be called within the renderPlotly() function in the plotly package. 4.1.3 Targeting views The linked brushing example in Figure 4.2 has bi-directional communication – a &quot;plotly_selected&quot; event deriving from either view impacts the other view. In other words, each view can be either the source or target of the selection. Often times, we want one view to be the source of a selection, and related view(s) to be the target. Figure 4.3 shows a heatmap of a correlation matrix (the source of a selection) linked to a scatterplot (the target of a selection). By clicking on a cell in the correlation matrix, a scatterplot of the two variables is displayed below the matrix. To update the scatterplot view, Figure 4.3 accesses &quot;plotly_click&quot; events via the event_data() function, but it also careful to not access click events triggered from the scatterplot. By strategically matching the value of the source argument in the plot_ly() and event_data() functions, Figure 4.3 effectively restricts the scope of events to a specific plot (the heatmap). Figure 4.3: A video demonstration of clicking on a cell in a correlation matrix to view the corresponding scatterplot. The video can be accessed here and the code to run the example is here Another aspect of Figure 4.3 that makes it an interesting example is that the key attribute is a matrix, matching the same dimensions of z (i.e, the values displayed in each cell). For good reason, most linked views paradigms (including the paradigm discussed in Linking views without shiny) restrict linkage definitions to relational database schema. In this case, it is more efficient to implement the relation with a key matrix, rather than a column. You can also run the example yourself using the following code – shiny::runApp(system.file(&quot;examples&quot;, &quot;plotlyEvents&quot;, package = &quot;plotly&quot;))↩ To my knowledge, the leaflet package is the only R package which provides a way to update a plot in a shiny app without a full redraw.↩ "],
["linking-views-without-shiny.html", "4.2 Linking views without shiny", " 4.2 Linking views without shiny The code is this section is still under development and is likely to change. To run any of the code you see in this section, you’ll need this developmental version of the package: devtools::install_github(“ropensci/plotly#554”) 4.2.1 Motivating examples As shown in Linking views with shiny, the key attribute provides a way to attach a key (i.e., ID) to graphical elements – an essential feature when making graphical queries. When linking views in plotly outside of shiny, the suggested way to attach a key to graphical elements is via the SharedData class from the crosstalk package (Cheng 2016). At the very least, the new() method for this class requires a data frame, and a key variable. Lets suppose we’re interested in making comparisons of housing sales across cities for a given year using the txhousing dataset. Given that interest, we may want to make graphical queries that condition on a year, so we start by creating a SharedData object with year as the shared key. # devtools::install_github(&quot;ropensci/crosstalk&quot;) library(crosstalk) sd &lt;- SharedData$new(txhousing, ~year) As far as ggplotly() and plot_ly() are concerned, SharedData object(s) act just like a data frame, but with a special key attribute attached to graphical elements. Since both interfaces are based on the layered grammar of graphics, key attributes can be attached at the layer level, and those attributes can also be shared across multiple views. Figure 4.4 leverages both of these features to link multiple views of median house sales in various Texan cities. As the video shows, hovering over a line in any panel selects that particular year, and all corresponding panels update to highlight that year. The result is an incredibly powerful tool for quickly comparing house sale prices, not only across cities for a given year, but also across years for a given city. p &lt;- ggplot(sd, aes(month, median)) + geom_line(aes(group = year)) + geom_smooth(data = txhousing, method = &quot;gam&quot;) + facet_wrap(~ city) ggplotly(p, tooltip = &quot;year&quot;) %&gt;% highlight(on = &quot;plotly_hover&quot;, defaultValues = 2015, color = &quot;red&quot;) Figure 4.4: Monthly median house sales by year and city. Each panel represents a city and panels are linked by year. A video demonstrating the graphical queries can be viewed here Figure 4.4 uses the highlight() function from the plotly package to specify the type of plotly event for triggering a selection (via the on argument), the color of the selection (via the color argument), and set a default selection (via the defaultValues argument). The off argument controls the type of event that clears selections, and by default, is set to a plotly_relayout event, which can be triggered by clicking the home icon in the mode bar (or via zoom/pan). The highlight() function can also be used to control Transient versus persistent selection modes, and dynamically control selection colors, which is very useful for making comparisons. Figure 4.5 shows another example of using SharedData objects to link multiple views, this time to enable linked brushing in a scatterplot matrix via the ggpairs() function from the GGally package. As discussed in Scatterplot matrices, the ggpairs() function implements the generalized pairs plot – a generalization of the scatterplot matrix – an incredibly useful tool for exploratory data analysis. Since the Species variable (as discrete variable) is mapped to color in Figure 4.5, we can inspect both correlations, and marginal densities, dependent upon Species type. By adding the brushing capabilities via ggplotly(), we add the ability to examine the dependence between a continuous conditional distribution and other variables. For this type of interaction, a unique key should be attached to each observation in the original data, which is the default behavior of the SharedData object’s new() method when no key is provided. d &lt;- SharedData$new(iris) p &lt;- GGally::ggpairs(d, aes(color = Species), columns = 1:4) layout(ggplotly(p), dragmode = &quot;select&quot;) Figure 4.5: Brushing a scatterplot matrix via the ggpairs() function in the GGally package. A video demonstrating the graphical queries can be viewed here When the graphical query is made is 4.5, the marginal densities do not update. This points out one of the weaknesses of implementing multiple linked views without shiny (or some other R backend). The browser knows nothing about the algorithm GGally (or ggplot2) uses to compute a density, so updating the densities in a consistent way is not realistic without being able to call R from the browser. It is true that we could try to precompute densities for every possible selection state, but this does not generally scale well when the number of selection states is large, even as large as Figure 4.5. As discussed briefly in bars &amp; histograms, Boxplots, and 2D distributions, plotly.js does have some statistical functionality that we can leverage to display Dynamic aggregates, but this currently covers only a few types of statistical displays. 4.2.2 Transient versus persistent selection The examples in the previous section use transient selection, meaning that when a value is selected, previous selection(s) are forgotten. Sometimes it is more useful to allow selections to accumulate – a type of selection known as persistent selection. To demonstrate the difference, Figure 4.6 presents two different takes a single view, one with transient selection (on the left) and one with persistent selection (on the right). Both selection modes can be used when linking multiple views, but as Figure 4.6 shows, highlighting graphical elements, even in a single view, can be useful tool to avoid overplotting. sd &lt;- SharedData$new(txhousing, ~city) p &lt;- ggplot(sd, aes(date, median)) + geom_line() gg &lt;- ggplotly(p, tooltip = &quot;city&quot;) highlight(gg, on = &quot;plotly_hover&quot;, dynamic = TRUE) highlight(gg, on = &quot;plotly_hover&quot;, dynamic = TRUE, persistent = TRUE) Figure 4.6: Highlighting lines with transient versus persistent selection. In the left hand panel, transient selection (the default); and in the right hand panel, persistent selection. The video may be accessed here Figure 4.6 also sets the dynamic argument to TRUE to populate a widget, powered by the colourpicker package (Attali 2016), for dynamically altering the selection color. When paired with persistent selection, this makes for a powerful tool for making comparisons between two selection sets. However, for Figure 4.6, transient selection is probably the better mode for an initial look at the data (to help reveal any structure in missingness or anomalies for a given city), whereas persistent selection is better for making comparisons once have a better idea of what cities might be interesting to compare. 4.2.3 Linking with other htmlwidgets Perhaps the most exciting thing about building a linked views framework on top of the crosstalk package is that it provides a standardized protocol for working with selections that other htmlwidget packages may build upon. If implemented carefully, this effectively provides a way to link views between two independent graphical systems – a fairly foreign technique within the realm of interactive statistical graphics. This grants a tremendous amount of power to the analyst since she/he may leverage the strengths of multiple systems in a single linked views analysis. Figure 4.7 shows an example of linked views between plotly and leaflet for exploring the relationship between the magnitude and geographic location of earthquakes. library(plotly) library(leaflet) sd &lt;- SharedData$new(quakes) p &lt;- plot_ly(sd, x = ~depth, y = ~mag) %&gt;% add_markers(alpha = 0.5) %&gt;% layout(dragmode = &quot;select&quot;) %&gt;% highlight(dynamic = TRUE, persistent = TRUE) map &lt;- leaflet(sd) %&gt;% addTiles() %&gt;% addCircles() htmltools::tagList(p, map) Figure 4.7: Linking views between plotly and leaflet to explore the relation between magnitude and geographic location of earthquakes around Fiji. The video may be accessed here In Figure 4.7, the user first highlights earthquakes with a magnitude of 5 or higher in red (via plotly), then earthquakes with a magnitude of 4.5 or lower, and the corresponding earthquakes are highlighted in the leaflet map. This immediately reveals an interesting relationship in magnitude and geographic location, and leaflet provides the ability to zoom and pan on the map to investigate regions that have a high density of quakes. It’s worth noting that the crosstalk package itself does not provide semantics for describing persistent/dynamic selections, but plotly does inform crosstalk about these semantics which other htmlwidget authors can access in their JavaScript rendering logic. 4.2.4 Selection via indirect manipulation The interactions described thus far in Linking views without shiny is what Cook and Swayne (2007) calls direct manipulation, where the user makes graphical queries by directly interacting with graphical elements. In Figure 4.8, cities are queried indirectly via a dropdown powered by the selectize.js library (B. R. &amp; Contributors 2016). Indirect manipulation is especially useful when you have unit(s) of interest (e.g. your favorite city), but can not easily find that unit in the graphical space. The combination of direct and indirect manipulation is powerful, especially when the interactive widgets for indirect manipulation are synced with direct manipulation events. As shown in Figure 4.8, when cities are queried indirectly, the graph updates accordingly, and when cities are queried directly, the select box updates accordingly. If the time series was linked to other view(s), as it is in the next section, selecting a city via the dropdown menu would highlight all of the relevant view(s). # The group name is currently used to populate a title for the selectize widget sd &lt;- SharedData$new(txhousing, ~city, &quot;Choose a city&quot;) plot_ly(sd, x = ~date, y = ~median) %&gt;% add_lines(text = ~city, hoverinfo = &quot;text&quot;) %&gt;% highlight(on = &quot;plotly_hover&quot;, persistent = TRUE, selectize = TRUE) Figure 4.8: Selecting cities by indirect manipulation. The video may be accessed here 4.2.5 The SharedData plot pipeline Sometimes it is useful to display a summary (i.e., overview) in one view and link that summary to more detailed views. Figure 4.9 is one such example that displays a bar chart of all Texan cities with one or more missing values (the summary) linked with their values over time (the details). By default, the bar chart allows us to quickly see which cities have the most missing values, and by clicking a specific bar, it reveals the relationship between missing values and time for a given city. In cities with the most missing values, data did not start appearing until somewhere around 2006-2010, but for most other cities (e.g., Harlingen, Galveston, Temple-Belton, etc), values started appearing in 2000, but for some reason go missing around 2002-2003. Figure 4.9: A bar chart of cities with one or more missing median house sales linked to a time series of those sales over time. The video may be accessed here When implementing linked views like Figure 4.9, it can be helpful to conceptualize a pipeline between a central data frame and the corresponding views. Figure 4.10 is a visual depiction of this conceptual model between the central data frame and the eventual linked views in Figure 4.9. In order to generate the bar chart on the left, the pipeline contains a function for computing summary statistics (the number of missing values per city). On the other hand, the time series does not require any summarization – implying the pipeline for this view is the identity function. Figure 4.10: A diagram of the pipeline between the data and graphics. Since the pipeline from data to graphic is either an identity function or a summarization of some kind, it is good idea to use the most granular form of the data for the SharedData object, and use the data-plot-pipeline to define a pipeline from the data to the plot. As Wickham et al. (2010) writes, a true interactive graphics system is aware of the both the function from the central data object to the graphic, as well as the inverse function (i.e., the function from the graphic back to the central data object). As it currently stands, plotly loses this information when the result is pushed to the web browser, but that does not matter for Figure 4.9 since pipelines do not have to re-execute upon user selections.14 sd &lt;- SharedData$new(txhousing, ~city) base &lt;- plot_ly(sd, color = I(&quot;black&quot;)) %&gt;% group_by(city) p1 &lt;- base %&gt;% summarise(has = sum(is.na(median))) %&gt;% filter(has &gt; 0) %&gt;% arrange(has) %&gt;% add_bars(x = ~has, y = ~factor(city, levels = city), hoverinfo = &quot;none&quot;) %&gt;% layout( barmode = &quot;overlay&quot;, xaxis = list(title = &quot;Number of months missing&quot;), yaxis = list(title = &quot;&quot;) ) p2 &lt;- base %&gt;% add_lines(x = ~date, y = ~median, alpha = 0.3) %&gt;% layout(xaxis = list(title = &quot;&quot;)) subplot(p1, p2, titleX = TRUE, widths = c(0.3, 0.7)) %&gt;% layout(margin = list(l = 120)) %&gt;% highlight(on = &quot;plotly_click&quot;, off = &quot;plotly_unhover&quot;, color = &quot;red&quot;) 4.2.6 Dynamic aggregates As discussed in the plotly cookbook, there are a number of way to compute statistical summaries in the browser via plotly.js (e.g., add_histogram(), add_boxplot(), add_histogram2d(), and add_histogram2dcontour()). When linking views with the plotly package, we can take advantage of this functionality to display aggregated views of selections. Figure 4.11 shows a basic example of brushing a scatterplot to select cars with 10-20 miles per gallon, then a 5 number summary of the corresponding engine displacement is dynamically computed and displayed as a boxplot. d &lt;- SharedData$new(mtcars) scatterplot &lt;- plot_ly(d, x = ~mpg, y = ~disp) %&gt;% add_markers(color = I(&quot;black&quot;)) %&gt;% layout(dragmode = &quot;select&quot;) subplot( plot_ly(d, y = ~disp, color = I(&quot;black&quot;)) %&gt;% add_boxplot(name = &quot;overall&quot;), scatterplot, shareY = TRUE ) %&gt;% layout(dragmode = &quot;select&quot;) Figure 4.11: Dynamically populating a boxplot reflecting brushed observations Figure 4.11 is very similar to Figure 4.12, but uses add_histogram() to link to a bar chart of the number of cylinders rather than a boxplot of engine displacement. By brushing to select cars with a low engine displacement, we can see that (obviously) displacement is related with to the number of cylinders. p &lt;- subplot( plot_ly(d, x = ~factor(vs)) %&gt;% add_histogram(color = I(&quot;black&quot;)), scatterplot ) # Selections are actually additional traces, and, by default, # plotly.js will try to dodge bars placed under the same category layout(p, barmode = &quot;overlay&quot;) Figure 4.12: Dynamically populating a bar chart reflecting brushed observations 4.2.7 Hierarchial categorical selection All of the sections under linking views without shiny thus far have attached a single value to a graphical mark or group of marks. However, there are also situations where it makes sense to attach multiple values to mark(s). Instead of using multiple keys to assign multiple values, it is actually more powerful to use a single nested key, since multiple keys can not support a different number of values for each mark. For example, suppose I have 4 (x, y) pairs, and each pair is associated with a different set of categorical values: # data frames do support list columns, # but tibble::tibble() provides a nicer API for this... d &lt;- data.frame(x = 1:4, y = 1:4) d$key &lt;- lapply(1:4, function(x) letters[seq_len(x)]) d #&gt; x y key #&gt; 1 1 1 a #&gt; 2 2 2 a, b #&gt; 3 3 3 a, b, c #&gt; 4 4 4 a, b, c, d Suppose point (3, 3) is selected – implying the set \\(\\{ a, b, c \\}\\) is of interest – what key sets should be considered a match? The most sensible approach is to match any subsets of the selected set, so for example, this key set would match the sets \\(\\{ a \\}\\), \\(\\{ b \\}\\), \\(\\{ c \\}\\), \\(\\{ a, b \\}\\), \\(\\{ a, c \\}\\), and \\(\\{ b, c \\}\\). This leads to a type of selection I’ll refer to as hierarchical categorical selection. Figure 4.13 provides a visual demo of this example in action: SharedData$new(d, ~key) %&gt;% plot_ly(x = ~x, y = ~y) Figure 4.13: A simple example of hierarchial selection More informally, hierarchical categorical selection provides a nice way to select all the “children” of a given “parent” selection. This type of selection is useful when their is a natural hierarchy to a dataset, such as for a dendrogram, and 4.14 demonstrates: Figure 4.14: Leveraging hierarchical selection and persistent brushing to paint branches of a dendrogram. 4.2.8 More examples The plotly package bundles a bunch of demos that illustrate all the options available when linking views without shiny via crosstalk’s SharedData class and plotly’s highlight() function. To list all the examples, enter demo(package = &quot;plotly&quot;) into your R prompt, and pick a topic (e.g., demo(&quot;highlight-intro&quot;, package = &quot;plotly&quot;)). --> References "],
["animating-views.html", "5 Animating views ", " 5 Animating views "],
["key-frame-animations.html", "5.1 Key frame animations", " 5.1 Key frame animations The code is this section is still under development and may change. To run any of the code you see in this section, you’ll need this developmental version of the package: devtools::install_github(“ropensci/plotly#554”) Both plot_ly() and ggplotly() support key frame animations through the frame attribute/aesthetic. They also support an ids attribute/aesthetic to ensure smooth transitions between objects with the same id (which helps facilitate object constancy). Figure 5.1 recreates the famous gapminder animation of the evolution in the relationship between GDP per capita and life expectancy evolved over time (Bryan 2015). The data is recorded on a yearly basis, so the year is assigned to frame, and each point in the scatterplot represents a country, so the country is assigned to ids, ensuring a smooth transition from year to year for a given country. data(gapminder, package = &quot;gapminder&quot;) gg &lt;- ggplot(gapminder, aes(gdpPercap, lifeExp)) + geom_point(aes(size = pop, color = continent, frame = year, ids = country)) + scale_x_log10() ggplotly(gg) Figure 5.1: Animation of the evolution in the relationship between GDP per capita and life expectancy in numerous countries. As long as a frame variable is provided, an animation is produced with play/pause button(s) and a slider component for controlling the animation. These components can be removed or customized via the animation_button() and animation_slider() functions. Moreover, various animation options, like the amount of time between frames, the smooth transition duration, and the type of transition easing may be altered via the animation_opts() function. Figure 5.2 shows the same data as Figure 5.1, but doubles the amount of time between frames, uses linear transition easing, places the animation buttons closer to the slider, and modifies the default currentvalue.prefix settings for the slider. base &lt;- gapminder %&gt;% plot_ly(x = ~gdpPercap, y = ~lifeExp, size = ~pop, text = ~country, hoverinfo = &quot;text&quot;) %&gt;% layout(xaxis = list(type = &quot;log&quot;)) base %&gt;% add_markers(color = ~continent, frame = ~year, ids = ~country) %&gt;% animation_opts(1000, easing = &quot;elastic&quot;) %&gt;% animation_button(y = -0.1, yanchor = &quot;top&quot;) %&gt;% animation_slider(currentvalue = list(prefix = &quot;YEAR &quot;)) Figure 5.2: Modifying animation defaults with animation_opts(), animation_button(), and animation_slider(). If frame is a numeric variable (or a character string), frames are always ordered in increasing (alphabetical) order; but for factors, the ordering reflects the ordering of the levels. Consequently, factors provide the most control over the ordering of frames. In Figure 5.3, the continents (i.e., frames) are ordered according their average life expectancy across countries within the continent. Furthermore, since there is no meaningful relationship between objects in different frames of Figure 5.3, the smooth transition duration is set to 0. This helps avoid any confusion that there is a meaningful connection between the smooth transitions. Note that these options control both animations triggered by the play button or via the slider. meanLife &lt;- with(gapminder, tapply(lifeExp, INDEX = continent, mean)) gapminder$continent &lt;- factor(gapminder$continent, levels = names(sort(meanLife))) base %&gt;% add_markers(data = gapminder, frame = ~continent) %&gt;% hide_legend() %&gt;% animation_opts(frame = 1000, transition = 0) Figure 5.3: Animation of GDP per capita versus life expectancy by continent. The ordering of the contintents goes from lowest average (across countries) life expectancy to highest. Both the frame and ids attributes operate on the trace level – meaning that we can target specific layers of the graph to be animated. One obvious use case for this is to provide a background which displays every possible frame (which is not animated) and overlay the animated frames onto that background. Figure 5.4 shows the same information as Figure 5.2, but layers animated frames on top of a background of all the frames. As a result, it is easier to put a specific year into a global context. base %&gt;% add_markers(color = ~continent, alpha = 0.2, showlegend = F) %&gt;% add_markers(color = ~continent, frame = ~year, ids = ~country) %&gt;% animation_opts(1000) Figure 5.4: Overlaying animated frames on top of a background of all possible frames. References "],
["linking-animated-views.html", "5.2 Linking animated views", " 5.2 Linking animated views The section linking views without shiny details a framework for linking views through direct manipulation. This same framework can be leveraged to link views between animations. Figure 5.5 links two animated views: on the left-hand side is population density by country and on the right-hand side is GDP per capita versus life expectancy. By default, all of the years are shown in black and the current year is shown in red. By pressing play to animate through the years, we can see that all three of these variables have increased (on average) fairly consistently over time. By linking the animated layers, we may condition on an interesting region of this data space to make comparisons in the overall relationship over time. For example, in Figure 5.5, countries below the 50th percentile in terms of population density are highlighted in blue, then the animation is played again to reveal a fairly interesting difference in these groups. From 1952 to 1977, countries with a low population density seem to enjoy large increases in GDP per capita and moderate increases in life expectancy, then in the early 80s, their GPD seems to decrease while the life expectancy greatly increases. In comparison, the high density countries seems to enjoy a more consistent and steady increase in both GDP and life expectancy. Of course, there are a handful of exceptions to the overall trend, such as the noticable drop in life expectancy for a handful of countries during the nineties, which are mostly African countries feeling the affects of war. Figure 5.5: Comparing the evolution in the relationship between per capita GDP and life expectancy in countries with large populations (red) and small populations (blue). The gapminder data used thus far does not include surface area information, so Figure 5.5 leverages a list of countries by area on Wikipedia. The R script used to obtain and clean that list is here, but the cleaned version is directly available, plus add the areas to the gapminder data with the following code: countryByArea &lt;- read.table( &quot;https://gist.githubusercontent.com/cpsievert/d4a4ccb7ce61e2cfaecf9736de4f67fa/raw/9b7d01c2c939d721bdf2f47a6596ac4c055205d3/countryByArea.txt&quot;, header = TRUE, stringsAsFactors = FALSE ) gap &lt;- gapminder %&gt;% dplyr::left_join(countryByArea, by = &quot;country&quot;) %&gt;% transform(popDen = pop / area) %&gt;% transform(country = forcats::fct_reorder(country, popDen)) The enhanced version of the gapminder data, gap, includes population density (population per square kilometer) and is used for the background layer (i.e., black points) in Figure 5.5. In order to link the animated layers (i.e., red points), we need another version of gap that marks the country variable as the link between the plots (gapKey). The new() method for the SharedData class from the crosstalk package provides one way to define this link.15 gapKey &lt;- crosstalk::SharedData$new(gap, ~country) p1 &lt;- plot_ly(gap, y = ~country, x = ~popDen, hoverinfo = &quot;x&quot;) %&gt;% add_markers(alpha = 0.1, color = I(&quot;black&quot;)) %&gt;% add_markers(data = gapKey, frame = ~year, ids = ~country, color = I(&quot;red&quot;)) %&gt;% layout(xaxis = list(type = &quot;log&quot;)) p2 &lt;- plot_ly(gap, x = ~gdpPercap, y = ~lifeExp, size = ~popDen, text = ~country, hoverinfo = &quot;text&quot;) %&gt;% add_markers(color = I(&quot;black&quot;), alpha = 0.1) %&gt;% add_markers(data = gapKey, frame = ~year, ids = ~country, color = I(&quot;red&quot;)) %&gt;% layout(xaxis = list(type = &quot;log&quot;)) subplot(p1, p2, nrows = 1, widths = c(0.3, 0.7), titleX = TRUE) %&gt;% hide_legend() %&gt;% animation_opts(1000) %&gt;% layout(dragmode = &quot;select&quot;, hovermode = &quot;y&quot;, margin = list(l = 100)) %&gt;% highlight(off = &quot;plotly_deselect&quot;, color = &quot;blue&quot;, opacityDim = 1, hoverinfo = &quot;none&quot;) Although Figure 5.5 links two animated layers, it is probably more common to link non-animated display(s) with an animation. A sophicated use within the statistical graphics literature is to link views with a grand tour to view model predictions projected onto a high-dimensional space (Wickham, Cook, and Hofmann 2015). The grand tour is a special kind of animation that interpolates between random 2D projections of numeric data allowing us, to perceive the shape of a high-dimensional point cloud (Asimov 1985). Figure 5.6 links a grand tour to a dendrogram displaying the results of a hierarchal clustering algorithm on the 50 US states with respect to Murder arrests (per 100,000), Assault arrests (per 100,000), Rape arrests (per 100,000), and percent urban population. Figure 5.6: Linking a dendrogram to a grand tour and map of the USArrests data to visualize a classification in 5 dimensions. Figure 5.6 makes use of hierarchial categorical selection to select all the states (as well as all the child nodes) under a given node in both the dendogram and the grand tour. This effectively provides a model selection tool in an unsupervised setting where one may choose a number of clusters by choosing relevant nodes in the dendrogram and viewing the model fit projected onto the data space. As shown in Figure 5.6, after picking the 3 most obvious clusters, it looks as though a straight line could be drawn to completely separate the groups in the initial projection of the tour – which suggests a split along this linear combination of these variables would provide a good classifier.16 The code to generate Figure 5.6, as well as a few other examples of the grand tour and linking brushing can be found in the package demos. To run the code for Figure 5.6, run demo(&quot;tour-USArrests&quot;, package = &quot;plotly&quot;). To see a list of the other available demos, run readLines(system.file(&quot;demo/00Index&quot;, package = &quot;plotly&quot;)). --> References "],
["references.html", "References", " References "]
]
