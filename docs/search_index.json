[
["index.html", "Interactive web-based data visualization with R, plotly, and shiny Welcome", " Interactive web-based data visualization with R, plotly, and shiny Carson Sievert 2019-02-07 Welcome This book teaches you how to create interactive and dynamic web graphics using the R packages plotly and shiny. The majority of the book uses R code examples to demonstrate features and functionality available in plotly.1 Along the way, you’ll also learn about other R tools (e.g., tidyverse packages) that help make plotly such a productive tool for both exploratory analysis and presentation of your data. In addition to data visualization principles, you’ll also learn some effective strategies for graphical exploration of high-dimensional data. By mastering these concepts and tools, you’ll impress your colleagues with your ability to generate more graphical insights faster via highly interactive graphics that you can share over email, export to pdf, and more. An online version of this book, available at https://plotly-book.cpsievert.me, is free to use and is licensed under the Creative Commons Attribution-NonCommercial-NoDerivs 3.0 United States License. Both the print and online versions of the book are written in rmarkdown with bookdown and those source files are available at https://github.com/cpsievert/plotly_book. The online version will continue to evolve in between reprints of the physical book. All the software tools in this book are 100% free and open source. Many people think the R package plotly is not free and open-source, but both the R package and the JavaScript library it depends on (plotly.js) are MIT-licensed.↩ "],
["introduction.html", "1 Introduction 1.1 What you will learn 1.2 How this book is organized 1.3 What you won’t learn 1.4 Prerequisites 1.5 Run code examples 1.6 Getting help and learning more 1.7 Acknowledgements 1.8 Colophon", " 1 Introduction 1.1 What you will learn This book provides the foundation necessary to create highly interactive and scalable 1.2 How this book is organized Chapter 1 designed to help ggplot2 users transfer knowledge to plot_ly(). 1.3 What you won’t learn 1.3.1 Web technologies Although this book is fundamentally about creating web graphics, it does not aim to teach you web technologies (e.g., HTML, SVG, CSS, JavaScript, etc). It’s true that becoming a competent web developer gives you the power and freedom to create more types of visuals, but the opporunities costs involved with learning all the relevant tools is not worth it for most data analysts. Moreover, most web programming tools are not well-suited for the exploratory phase of a data science workflow where iteration between data visualization, transformation, and modeling is a necessary task that often impedes hypothesis generation and sense-making (more on this in section 2). As a result, even if you do become web developer, you’ll find the cognitive burden required to create a web graphic will hamper your ability to derive new insights from data. 1.3.2 d3js The JavaScript library D3 is a great tool for data visualization assuming you’re familiar with web technologies and are primarily interested in expository (not exploratory) visualization. There are already lots of great resources for learning D3, including the numerous books (Murray 2013); (Murray 2017). 1.3.3 ggplot2 The book does contain some ggplot2 code examples (which are then converted to plotly via ggplotly()), but it’s not designed to teach you ggplot2. For those looking to learn ggplot2, I recommend using the learning materials listed at https://ggplot2.tidyverse.org. 1.3.4 Graphical data analysis How to perform data analysis via graphics (carefully, correctly, and creatively) is a large topic unto itself. Although this book does have hints and examples of graphical data analysis, it does not aim to provide a comprehensive foundation. For a nice resource on graphical data analysis topic, see (Unwin 2015). 1.3.5 Data visualization best practices Encoding information in a graphic (concisely and effectively) is a large topic unto itself. Although this book does have some ramblings related to best practices in data visualization, it does not aim to provide a comprehensive foundation. For some approachable and fun resources on the topic, see (Tufte 2001a); (Yau 2011); (Healey 2018); (Wilke 2018). 1.4 Prerequisites For those new to R and/or data visualization, R for Data Science provides a nice foundation for understanding concepts in this book (Wickham and Grolemund 2018). In particular, the chapter on data visualization is essentially assumed knowledge during some portions of this book. 1.5 Run code examples While reading this book, it can be helpful to run the code examples. A computing environment with all the required software to run these examples is available at http://bit.ly/plotly-book-cloud. This RStudio Cloud project provides a computing environment that you can use to follow along with the book. Most examples produce an interactive graphic, but the interactives themselves are not always included. Sometimes, instead of the interactive, a video is included to demonstrate the interactive capabilities. In those cases, you can copy/paste code in RStudio Cloud to get at the interactive plot. if (!require(remotes)) install.packages(&quot;remotes&quot;) remotes::install_github(&quot;cpsievert/plotly_book&quot;) 1.6 Getting help and learning more https://community.rstudio.com/tags/plotly 1.7 Acknowledgements This book wouldn’t be possible without the generous assistance and mentorship of many people: Toby Dylan Hocking for many helpful conversations, his mentorship in the R packages animint and plotly, and laying the original foundation behind ggplotly(). Heike Hofmann and Di Cook for many helpful conversations about interactive graphics. Joe Cheng for many helpful conversations and inspiring section 20.1. Étienne Tétreault-Pinard, Alex Johnson, and the other plotly.js core developers for responding to my feature requests and bug reports. Yihui Xie for his work on knitr, rmarkdown, bookdown, and responding to my feature requests. Without bookdown, this book would never have happened. Hadley Wickham and the ggplot2 team for maintaining ggplot2. Anthony Unwin for helpful feedback and suggestions. Hadley Wickham and Garret Grolemund for writing R for Data Science and allowing me to model this introduction after their introduction. 1.8 Colophon An online version of this book is available at https://plotly-book.cpsievert.me. It will continue to evolve in between reprints of the physical book. The source of the book is available at https://github.com/cpsievert/plotly_book. The book is powered by https://bookdown.org which makes it easy to turn R markdown files into HTML, PDF, and EPUB. This book was built with the following computing environment: devtools::session_info(&quot;plotly&quot;) #&gt; ─ Session info ────────────────────────────────────────────────────────── #&gt; setting value #&gt; version R version 3.5.2 (2018-12-20) #&gt; os macOS Mojave 10.14.2 #&gt; system x86_64, darwin15.6.0 #&gt; ui X11 #&gt; language (EN) #&gt; collate en_US.UTF-8 #&gt; ctype en_US.UTF-8 #&gt; tz America/Chicago #&gt; date 2019-01-23 #&gt; #&gt; ─ Packages ────────────────────────────────────────────────────────────── #&gt; package * version date lib #&gt; askpass 1.1 2019-01-13 [1] #&gt; assertthat 0.2.0 2017-04-11 [1] #&gt; base64enc 0.1-3 2015-07-28 [1] #&gt; BH 1.69.0-1 2019-01-07 [1] #&gt; bindr 0.1.1 2018-03-13 [1] #&gt; bindrcpp 0.2.2 2018-03-29 [1] #&gt; cli 1.0.1 2018-09-25 [1] #&gt; colorspace 1.4-0 2019-01-13 [1] #&gt; crayon 1.3.4 2017-09-16 [1] #&gt; crosstalk 1.0.1 2019-01-04 [1] #&gt; curl 3.3 2019-01-10 [1] #&gt; data.table 1.12.0 2019-01-13 [1] #&gt; digest 0.6.18 2018-10-10 [1] #&gt; dplyr 0.7.8 2018-11-10 [1] #&gt; fansi 0.4.0 2018-12-03 [1] #&gt; ggplot2 3.1.0 2018-10-25 [1] #&gt; glue 1.3.0 2018-07-17 [1] #&gt; gtable 0.2.0 2016-02-26 [1] #&gt; hexbin 1.27.2 2018-01-15 [1] #&gt; htmltools 0.3.6.9003 2018-12-05 [1] #&gt; htmlwidgets 1.3 2018-09-30 [1] #&gt; httpuv 1.4.5.1 2018-12-18 [1] #&gt; httr 1.4.0 2018-12-11 [1] #&gt; jsonlite 1.6 2018-12-07 [1] #&gt; labeling 0.3 2014-08-23 [1] #&gt; later 0.7.5 2018-09-18 [1] #&gt; lattice 0.20-38 2018-11-04 [1] #&gt; lazyeval 0.2.1 2017-10-29 [1] #&gt; magrittr 1.5 2014-11-22 [1] #&gt; MASS 7.3-51.1 2018-11-01 [1] #&gt; Matrix 1.2-15 2018-11-01 [1] #&gt; mgcv 1.8-26 2018-11-21 [1] #&gt; mime 0.6 2018-10-05 [1] #&gt; munsell 0.5.0 2018-06-12 [1] #&gt; nlme 3.1-137 2018-04-07 [1] #&gt; openssl 1.2.1 2019-01-17 [1] #&gt; pillar 1.3.1.9000 2018-12-21 [1] #&gt; pkgconfig 2.0.2 2018-08-16 [1] #&gt; plogr 0.2.0 2018-03-25 [1] #&gt; plotly 4.8.0.9000 2019-01-22 [1] #&gt; plyr 1.8.4 2016-06-08 [1] #&gt; promises 1.0.1 2018-04-13 [1] #&gt; purrr 0.2.5 2018-05-29 [1] #&gt; R6 2.3.0 2018-10-04 [1] #&gt; RColorBrewer 1.1-2 2014-12-07 [1] #&gt; Rcpp 1.0.0 2018-11-07 [1] #&gt; reshape2 1.4.3 2017-12-11 [1] #&gt; rlang 0.3.1 2019-01-08 [1] #&gt; scales 1.0.0.9000 2018-11-30 [1] #&gt; shiny 1.2.0 2018-11-02 [1] #&gt; sourcetools 0.1.7 2018-04-25 [1] #&gt; stringi 1.2.4 2018-07-20 [1] #&gt; stringr 1.3.1 2018-05-10 [1] #&gt; sys 2.1 2018-11-13 [1] #&gt; tibble 2.0.99.9000 2019-01-14 [1] #&gt; tidyr 0.8.2 2018-10-28 [1] #&gt; tidyselect 0.2.5 2018-10-11 [1] #&gt; utf8 1.1.4 2018-05-24 [1] #&gt; viridisLite 0.3.0 2018-02-01 [1] #&gt; withr 2.1.2 2018-03-15 [1] #&gt; xtable 1.8-3 2018-08-29 [1] #&gt; yaml 2.2.0 2018-07-25 [1] #&gt; source #&gt; CRAN (R 3.5.2) #&gt; CRAN (R 3.5.0) #&gt; CRAN (R 3.5.0) #&gt; CRAN (R 3.5.2) #&gt; CRAN (R 3.5.0) #&gt; CRAN (R 3.5.0) #&gt; CRAN (R 3.5.0) #&gt; CRAN (R 3.5.2) #&gt; CRAN (R 3.5.0) #&gt; Github (rstudio/crosstalk@feaf86b) #&gt; CRAN (R 3.5.2) #&gt; CRAN (R 3.5.2) #&gt; CRAN (R 3.5.1) #&gt; CRAN (R 3.5.0) #&gt; Github (brodieG/fansi@ab11e9c) #&gt; CRAN (R 3.5.1) #&gt; CRAN (R 3.5.0) #&gt; CRAN (R 3.5.0) #&gt; CRAN (R 3.5.0) #&gt; local #&gt; CRAN (R 3.5.0) #&gt; CRAN (R 3.5.0) #&gt; CRAN (R 3.5.1) #&gt; CRAN (R 3.5.1) #&gt; CRAN (R 3.5.0) #&gt; CRAN (R 3.5.1) #&gt; CRAN (R 3.5.2) #&gt; CRAN (R 3.5.0) #&gt; CRAN (R 3.5.0) #&gt; CRAN (R 3.5.2) #&gt; CRAN (R 3.5.2) #&gt; CRAN (R 3.5.2) #&gt; CRAN (R 3.5.1) #&gt; CRAN (R 3.5.0) #&gt; CRAN (R 3.5.2) #&gt; CRAN (R 3.5.2) #&gt; Github (r-lib/pillar@9cc3030) #&gt; CRAN (R 3.5.0) #&gt; CRAN (R 3.5.0) #&gt; local #&gt; CRAN (R 3.5.0) #&gt; CRAN (R 3.5.0) #&gt; CRAN (R 3.5.0) #&gt; CRAN (R 3.5.1) #&gt; CRAN (R 3.5.0) #&gt; CRAN (R 3.5.0) #&gt; CRAN (R 3.5.0) #&gt; CRAN (R 3.5.2) #&gt; Github (hadley/scales@7cd8121) #&gt; CRAN (R 3.5.0) #&gt; CRAN (R 3.5.0) #&gt; CRAN (R 3.5.0) #&gt; CRAN (R 3.5.0) #&gt; CRAN (R 3.5.1) #&gt; Github (tidyverse/tibble@5a6e727) #&gt; CRAN (R 3.5.1) #&gt; CRAN (R 3.5.1) #&gt; CRAN (R 3.5.0) #&gt; CRAN (R 3.5.0) #&gt; CRAN (R 3.5.0) #&gt; CRAN (R 3.5.0) #&gt; CRAN (R 3.5.0) #&gt; #&gt; [1] /Library/Frameworks/R.framework/Versions/3.5/Resources/library References "],
["why-web-graphics.html", "2 Why interactive web graphics in R?", " 2 Why interactive web graphics in R? Data science workflow Interactivity augments exploration Some historical context and examples (https://talks.cpsievert.me/20180202/#7) “Interactive graphics enable the analyst to pursue follow-up questions” – Cook &amp; Swayne, GGobi book, p15 A case study of US election data GUI and command-line - conflict or synergy? https://talks.cpsievert.me/20180305/#12 Web-based visualization New capabilites (e.g. easy sharing, portability) brings new set of concerns (e.g., client-server, security, etc) Great tools for expository vis (d3.js, vega, plotly.js) Lack of tools for exploratory vis (i.e. tools for iteration) Why plotly for R? MIT-licensed software built with plotly.js and htmlwidgets Perhaps mention the plotly.js development pace Users can opt into plotly cloud Mention orca? Built on sound visualization and programming principles: The Grammar of Graphics Pure functional programming Two approaches, one object Works well with the tidyverse "],
["introduction-1.html", "3 Introduction 3.1 Intro to plot_ly() 3.2 Intro to plotly.js 3.3 Intro to ggplotly() 3.4 plot_ly() vs ggplotly()", " 3 Introduction This part of the book teaches you how to leverage the plotly R package to create a variety of interactive graphics. There are two main ways to creating a plotly object: either by transforming a ggplot2 object (via ggplotly()) into a plotly object or by directly initializing a plotly object with plot_ly()/plot_geo()/plot_mapbox(). Both approaches have somewhat complementary strengths and weaknesses, so it can pay off to learn both approaches. Moreover, both approaches are an implementation of the Grammar of Graphics and both are powered by the JavaScript graphing library plotly.js, so many of the same concepts and tools you learn for one interface can be reused in the other. The subsequent chapters within this ‘Creating views’ part dive into specific examples and use cases, but this introductory chapter outlines some over-arching concepts related to plotly. It also provides definitions for terminology used throughout the book and introduces some concepts useful for understanding the infrastructure behind any plotly object. Most of these details aren’t necessarily required to get started with plotly, but it will envitably help you get ‘un-stuck’ and do more advanced things with plotly. 3.1 Intro to plot_ly() Any graph made with the plotly R package is powered by the JavaScript library plotly.js. The plot_ly() function provides a ‘direct’ interface to plotly.js with some additional abstractions to help reduce typing. These abstractions, inspired by the Grammar of Graphics and ggplot2, make it much faster to iterate from one graphic to another, making it easier to discover interesting features in the data (Wilkinson 2005); (Wickham 2009). To demonstrate, we’ll use plot_ly() to explore the diamonds dataset from ggplot2 and learn a bit how plotly and plotly.js work along the way. # load the plotly R package library(plotly) # load the diamonds dataset from the ggplot2 package data(diamonds, package = &quot;ggplot2&quot;) diamonds #&gt; # A tibble: 53,940 x 10 #&gt; carat cut color clarity depth table price x y z #&gt; &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0.23 Ideal E SI2 61.5 55 326 3.95 3.98 2.43 #&gt; 2 0.21 Premium E SI1 59.8 61 326 3.89 3.84 2.31 #&gt; 3 0.23 Good E VS1 56.9 65 327 4.05 4.07 2.31 #&gt; 4 0.290 Premium I VS2 62.4 58 334 4.2 4.23 2.63 #&gt; 5 0.31 Good J SI2 63.3 58 335 4.34 4.35 2.75 #&gt; 6 0.24 Very Good J VVS2 62.8 57 336 3.94 3.96 2.48 #&gt; # … with 5.393e+04 more rows If we assign variable names (e.g., cut, clarity, etc) to visual properties (e.g., x, y, color, etc) within plot_ly(), as done in Figure 3.1, it tries to find a sensible geometric representation of that information for us. In subsequent chapters, you’ll learn how to specify these geometric representations (as well as other visual encodings) to create different kinds of charts. # create three visualizations of the diamonds dataset plot_ly(diamonds, x = ~cut) plot_ly(diamonds, x = ~cut, y = ~clarity) plot_ly(diamonds, x = ~cut, color = ~clarity, colors = &quot;Accent&quot;) The ~ operator is only needed when refering to a column name in data (the first argument to plot_ly()). Moreover, the data argument is optional, meaning you can also provide column(s) directly to plot_ly(x = diamonds$cut) FIGURE 3.1: Three examples of visualizing categorical data with plot_ly(): (top) mapping cut to x yields a bar chart, (middle) mapping cut &amp; clarity to x &amp; y yields a heatmap, and (c) mapping cut &amp; clarity to x &amp; color yields a dodged bar chart. The plot_ly() function supports numerous arguments that are unique to the R package (e.g., color, stroke, span, symbol, linetype, etc) that make it easier to encode data as visual properties. By default, these arguments map the supplied values to a visual range defined by the plural form of the argument (e.g., colors, strokes, spans, symbols, linetypes, etc). Figure ?? depicts how this works for the last example in Figure 3.1 where clarity levels are mapped to color codes defined by the \"Accent\" color palette from the RColorBrewer package (Neuwirth 2014). Since these arguments anticipate a data value, you will obtain unexpected results if you try to specify the visual range directly: To specify the value range # doesn&#39;t produce black bars plot_ly(diamonds, x = ~cut, color = &quot;black&quot;) # produces red bars with black outline plot_ly(diamonds, x = ~cut, color = I(&quot;red&quot;), stroke = I(&quot;black&quot;), span = I(2)) Chapter 4 covers more of these “variable mapping” arguments that are unique to the R package and Chapter 39 goes more into depth on working with colors. TODO: get into pure functional programming? layered grammar of graphics? toWebGL(plot_ly(diamonds, x = ~carat, y = ~price)) diamonds %&gt;% plot_ly(x = ~carat, y = ~price) %&gt;% toWebGL() diamonds %&gt;% plot_ly(x = ~carat, y = ~price) %&gt;% toWebGL() 3.2 Intro to plotly.js To recreate the plots in Figure 3.1 using plotly.js directly, it would take significantly more code and knowledge of plotly.js. That being said, learning how plotly generates the underlying plotly.js figure is a useful introduction to plotly.js itself, and knowledge of plotly.js becomes useful when you need more flexible control over plotly. As Figure 3.2 illustrates, when you print any plotly object, the plotly_build() function is applied to that object, and that generates an R list which adheres to a syntax that plotly.js understands. This syntax is a JavaScript Object Notation (JSON) specification that plotly.js uses to represent, seralize, and render web graphics. A lot of documentation you’ll find online about plotly (e.g., the online figure reference) implictly refers to this JSON specification, so it can helpful to know how to “work backwards” from that documentation (i.e., translate JSON into to R code). If you’d like to learn details about mapping between R and JSON, section 27 provides an introduction aimed at R programmers, and Ooms (2014) provides a cohesive overview of the jsonlite package, which is what plotly uses to map between R and JSON. FIGURE 3.2: A diagram of what happens when you print a plotly graph. For illustration purposes, Figure 3.2 shows how this workflow applies to a simple bar graph (with values directly supplied instead of a data column name reference like Figure 3.1), but the same concept applies for any graph created via plotly. As the diagram suggests, both the plotly_build() and plotly_json() functions can be used to inspect the underlying data structure on both the R and JSON side of things. For example, Figure 3.3 shows the data portion of the JSON created for the last graph in Figure 3.3. p &lt;- plot_ly(diamonds, x = ~cut, color = ~clarity, colors = &quot;Accent&quot;) plotly_json(p) FIGURE 3.3: A portion of the JSON data behind the bottom plot of Figure 3.1. This dodged bar chart has 8 layers of data (i.e., 8 traces) – one for each level of clarity. In plotly.js terminology, a figure has two key components: data (aka, traces) and a layout. A trace defines a mapping from data and visuals. Every trace has a type (e.g., histogram, pie, scatter, etc) and the type determines what other attributes are allowed to define the mapping. That is, not every trace attribute (e.g. x, type, name) is available to every trace type, but many attributes (e.g., the name of the trace) are available in every trace type and serve a similar purpose. From Figure 3.3 we can see that it takes multiple traces to generate the dodged bar chart, but instead of clicking through JSON viewer, sometimes it’s easier to use plotly_build() and compute on the plotly.js figure definition to verify certain things exist. Since plotly uses the htmlwidgets standard2, the actual plotly.js figure definition appears under a list element named x (Vaidyanathan et al. 2016). # use plotly_build() to get at the plotly.js definition # behind *any* plotly object b &lt;- plotly_build(p) # Confirm there 8 traces length(b$x$data) #&gt; [1] 8 # Extract the `name` of each trace. plotly.js uses `name` to populate legend entries and tooltips purrr::map_chr(b$x$data, &quot;name&quot;) #&gt; [1] &quot;IF&quot; &quot;VVS1&quot; &quot;VVS2&quot; &quot;VS1&quot; &quot;VS2&quot; &quot;SI1&quot; &quot;SI2&quot; &quot;I1&quot; # Every trace has a type of histogram unique(purrr::map_chr(b$x$data, &quot;type&quot;)) #&gt; [1] &quot;histogram&quot; Here we’ve learned that plotly creates 8 histogram traces to generate the dodged bar chart: one trace for each level of clarity.3 Why one trace per category? As illustrated in Figure 3.4 there are two main reasons: to populate a tooltip and legend entry for each level of clarity level. FIGURE 3.4: Leveraging two interactive features that require one trace per level of clarity: (1) Using ‘Compare data on hover’ mode to get counts for every level of clarity for a given level of cut and (2) Using the ability to hide/show clarity levels via their legend entries. If we investigated further, we’d notice that color and colors are not officially part of the plotly.js figure definition – the plotly_build() function has effectively transformed that information into a sensible plotly.js figure definition (e.g., marker.color contains the actual bar color codes). In fact, the color argument in plot_ly() is just one example of an abstraction the R package has built on top of plotly.js to make it easier to map data values to visual attributes, and many of these are covered in Section 4. 3.3 Intro to ggplotly() 3.4 plot_ly() vs ggplotly() TODO: table of strengths and weaknesses References "],
["scatter-traces.html", "4 Scatter traces 4.1 Scatterplots 4.2 Line plots 4.3 Segments 4.4 Ribbons 4.5 Polygons", " 4 Scatter traces A plotly visualization is composed of one (or more) trace(s), and every trace has a type. The default trace type, “scatter”, can be used to draw a large amount of geometries, and actually powers many of the add_*() functions such as add_markers(), add_lines(), add_paths(), add_segments(), add_ribbons(), and add_polygons(). Among other things, these functions make assumptions about the mode of the scatter trace, but any valid attribute(s) listed under the scatter section of the figure reference may be used to override defaults. The plot_ly() function has a number of arguments that make it easier to scale data values to visual aesthetics (e.g., color/colors, symbol/symbols, linetype/linetypes, size/sizes). These arguments are unique to the R package and dynamically determine what objects in the figure reference to populate (e.g., marker.color vs line.color). Generally speaking, the singular form of the argument defines the domain of the scale (data) and the plural form defines the range of the scale (visuals). To make it easier to alter default visual aesthetics (e.g., change all points from blue to black), “AsIs” values (values wrapped with the I() function) are interpreted as values that already live in visual space, and thus do not need to be scaled. The next section on scatterplots explores detailed use of the color/colors, symbol/symbols, &amp; size/sizes arguments. The section on lineplots explores detailed use of the linetype/linetypes. 4.1 Scatterplots The scatterplot is commonly used to assess the association between two quantitative variables. In addition, as Unwin (2015) notes, scatterplots can be useful for exposing other important features including: casual relationships, outliers, clusters, gaps, barriers, and conditional relationships. If you supply a numeric vector for x and y in plot_ly(), it defaults to a scatterplot, but you can also be explicit about adding a layer of markers/points via the add_markers() function. A common problem with scatterplots is overplotting, meaning that there are multiple observations occupying the same (or similar) x/y locations. There are a few ways to combat overplotting including: alpha transparency, hollow symbols, and 2D density estimation. Figure 4.1 shows how alpha transparency and hollow symbols can provide an improvement over the default. subplot( plot_ly(mpg, x = ~cty, y = ~hwy, name = &quot;default&quot;), plot_ly(mpg, x = ~cty, y = ~hwy) %&gt;% add_markers(alpha = 0.2, name = &quot;alpha&quot;), plot_ly(mpg, x = ~cty, y = ~hwy) %&gt;% add_markers(symbol = I(1), name = &quot;hollow&quot;) ) FIGURE 4.1: Three versions of a basic scatterplot In Figure 4.1, hollow circles are specified via symbol = I(1). By default, the symbol argument (as well as the color/size/linetype arguments) assumes value(s) are “data”, which need to be mapped to a visual palette (provided by symbols). Wrapping values with the I() function notifies plot_ly() that these values should be taken “AsIs”. If you compare the result of plot(1:25, 1:25, pch = 1:25) to Figure 4.2, you’ll see that plot_ly() can translate R’s plotting characters (pch), but you can also use plotly.js’ symbol syntax, if you desire. subplot( plot_ly(x = 1:25, y = 1:25, symbol = I(1:25), name = &quot;pch&quot;), plot_ly(mpg, x = ~cty, y = ~hwy, symbol = ~cyl, symbols = 1:3, name = &quot;cyl&quot;) ) FIGURE 4.2: Specifying symbol in a scatterplot When mapping a numeric variable to symbol, it creates only one trace, so no legend is generated. If you do want one trace per symbol, make sure the variable you’re mapping is a factor, as Figure 4.3 demonstrates. When plotting multiple traces, the default plotly.js color scale will apply, but you can set the color of every trace generated from this layer with color = I(\"black\"), or similar. p &lt;- plot_ly(mpg, x = ~cty, y = ~hwy, alpha = 0.3) subplot( add_markers(p, symbol = ~cyl, name = &quot;A single trace&quot;), add_markers(p, symbol = ~factor(cyl), color = I(&quot;black&quot;)) ) FIGURE 4.3: Mapping symbol to a factor The color argument adheres to similar rules as symbol: If numeric, color produces one trace, but colorbar is also generated to aide the decoding of colors back to data values. The colorbar() function can be used to customize the appearance of this automatically generated guide. The default colorscale is viridis, a perceptually-uniform colorscale (even when converted to black-and-white), and perceivable even to those with common forms of color blindness (Data Science 2016). If discrete, color produces one trace per value, meaning a legend is generated. If an ordered factor, the default colorscale is viridis (Garnier 2016); otherwise, it is the “Set2” palette from the RColorBrewer package (Neuwirth 2014) p &lt;- plot_ly(mpg, x = ~cty, y = ~hwy, alpha = 0.5) subplot( add_markers(p, color = ~cyl, showlegend = FALSE) %&gt;% colorbar(title = &quot;Viridis&quot;), add_markers(p, color = ~factor(cyl)) ) FIGURE 4.4: Variations on a numeric color mapping. There are a number of ways to alter the default colorscale via the colors argument. This argument excepts: (1) a color brewer palette name (see the row names of RColorBrewer::brewer.pal.info for valid names), (2) a vector of colors to interpolate, or (3) a color interpolation function like colorRamp() or scales::colour_ramp(). Although this grants a lot of flexibility, one should be conscious of using a sequential colorscale for numeric variables (&amp; ordered factors) as shown in 4.5, and a qualitative colorscale for discrete variables as shown in 4.6. col1 &lt;- c(&quot;#132B43&quot;, &quot;#56B1F7&quot;) col2 &lt;- viridisLite::inferno(10) col3 &lt;- colorRamp(c(&quot;red&quot;, &quot;white&quot;, &quot;blue&quot;)) subplot( add_markers(p, color = ~cyl, colors = col1) %&gt;% colorbar(title = &quot;ggplot2 default&quot;), add_markers(p, color = ~cyl, colors = col2) %&gt;% colorbar(title = &quot;Inferno&quot;), add_markers(p, color = ~cyl, colors = col3) %&gt;% colorbar(title = &quot;colorRamp&quot;) ) %&gt;% hide_legend() FIGURE 4.5: Three variations on a numeric color mapping col1 &lt;- &quot;Pastel1&quot; col2 &lt;- colorRamp(c(&quot;red&quot;, &quot;blue&quot;)) col3 &lt;- c(`4` = &quot;red&quot;, `5` = &quot;black&quot;, `6` = &quot;blue&quot;, `8` = &quot;green&quot;) subplot( add_markers(p, color = ~factor(cyl), colors = col1), add_markers(p, color = ~factor(cyl), colors = col2), add_markers(p, color = ~factor(cyl), colors = col3) ) %&gt;% hide_legend() FIGURE 4.6: Three variations on a discrete color mapping For scatterplots, the size argument controls the area of markers (unless otherwise specified via sizemode), and must be a numeric variable. The sizes argument controls the minimum and maximum size of circles, in pixels: subplot( add_markers(p, size = ~cyl, name = &quot;default&quot;), add_markers(p, size = ~cyl, sizes = c(1, 500), name = &quot;custom&quot;) ) FIGURE 4.7: Controlling the size range via sizes (measured in pixels). 4.1.1 3D scatterplots To make a 3D scatterplot, just add a z attribute: plot_ly(mpg, x = ~cty, y = ~hwy, z = ~cyl) %&gt;% add_markers(color = ~cyl) FIGURE 4.8: A 3D scatterplot 4.1.2 Scatterplot matrices Scatterplot matrices can be made via plot_ly() and subplot(), but ggplotly() has a special method for translating ggmatrix objects from the GGally package to plotly objects (Schloerke et al. 2016). These objects are essentially a matrix of ggplot objects and are the underlying data structure which powers higher level functions in GGally, such as ggpairs() – a function for creating a generalized pairs plot (Emerson et al. 2013). The generalized pairs plot can be motivated as a generalization of the scatterplot matrix with support for categorical variables and different visual representations of the data powered by the grammar of graphics. Figure 4.9 shows an interactive version of the generalized pairs plot made via ggpairs() and ggplotly(). In Linking views without shiny, we explore how this framework can be extended to enable linked brushing in the generalized pairs plot. pm &lt;- GGally::ggpairs(iris) ggplotly(pm) FIGURE 4.9: An interactive version of the generalized pairs plot made via the ggpairs() function from the GGally package 4.1.3 Dotplots &amp; error bars A dotplot is similar to a scatterplot, except instead of two numeric axes, one is categorical. The usual goal of a dotplot is to compare value(s) on a numerical scale over numerous categories. In this context, dotplots are preferable to pie charts since comparing position along a common scale is much easier than comparing angle or area (Cleveland and McGill 1984); (Bostock 2010). Furthermore, dotplots can be preferable to bar charts, especially when comparing values within a narrow range far away from 0 (Few 2006). Also, when presenting point estimates, and uncertainty associated with those estimates, bar charts tend to exaggerate the difference in point estimates, and lose focus on uncertainty (Messing 2012). A popular application for dotplots (with error bars) is the so-called “coefficient plot” for visualizing the point estimates of coefficients and their standard error. The coefplot() function in the coefplot package (Lander 2016) and the ggcoef() function in the GGally both produce coefficient plots for many types of model objects in R using ggplot2, which we can translate to plotly via ggplotly(). Since these packages use points and segments to draw the coefficient plots, the hover information is not the best, and it’d be better to use error objects. Figure 4.10 uses the tidy() function from the broom package (Robinson 2016) to obtain a data frame with one row per model coefficient, and produce a coefficient plot with error bars along the x-axis. m &lt;- lm(Sepal.Length~Sepal.Width*Petal.Length*Petal.Width, data = iris) # to order categories sensibly arrange by estimate then coerce factor d &lt;- broom::tidy(m) %&gt;% arrange(desc(estimate)) %&gt;% mutate(term = factor(term, levels = term)) plot_ly(d, x = ~estimate, y = ~term) %&gt;% add_markers(error_x = ~list(value = std.error)) %&gt;% layout(margin = list(l = 200)) FIGURE 4.10: A coefficient plot 4.2 Line plots This section surveys useful applications of add_lines() and add_paths(). The only difference between these functions is that add_lines() connects x/y pairs from left to right, instead of the order in which the data appears. Both functions understand the color, linetype, and alpha attributes4, as well as groupings defined by group_by(). Figure ?? uses group_by() to plot one line per city in the txhousing dataset using a single trace. Since there can only be one tooltip per trace, hovering over that plot does not reveal useful information. Although plotting many traces can be computationally expensive, it is necessary in order to display better information on hover. Since the color argument produces one trace per value (if the variable (city) is discrete), hovering on Figure 4.11 reveals the top ~10 cities at a given x value. Since 46 colors is too many to perceive in a single plot, Figure 4.11 also restricts the set of possible colors to black. plot_ly(txhousing, x = ~date, y = ~median) %&gt;% add_lines(color = ~city, colors = &quot;black&quot;, alpha = 0.2) FIGURE 4.11: Median house sales with one trace per city. Generally speaking, it’s hard to perceive more than 8 different colors/linetypes/symbols in a given plot, so sometimes we have to filter data to use these effectively. Here we use the dplyr package to find the top 5 cities in terms of average monthly sales (top5), then effectively filter the original data to contain just these cities via semi_join(). As Figure 4.12 demonstrates, once we have the data filtered, mapping city to color or linetype is trivial. The color palette can be altered via the colors argument, and follows the same rules as scatterplots. The linetype palette can be altered via the linetypes argument, and accepts R’s lty values or plotly.js dash values. library(dplyr) top5 &lt;- txhousing %&gt;% group_by(city) %&gt;% summarise(m = mean(sales, na.rm = TRUE)) %&gt;% arrange(desc(m)) %&gt;% top_n(5) p &lt;- semi_join(txhousing, top5, by = &quot;city&quot;) %&gt;% plot_ly(x = ~date, y = ~median) subplot( add_lines(p, color = ~city), add_lines(p, linetype = ~city), shareX = TRUE, nrows = 2 ) FIGURE 4.12: Using color and/or linetype to differentiate groups of lines. 4.2.1 Density plots In Bars &amp; histograms, we leverage a number of algorithms in R for computing the “optimal” number of bins for a histogram, via hist(), and routing those results to add_bars(). We can leverage the density() function for computing kernel density estimates in a similar way, and route the results to add_lines(), as is done in 4.13. kerns &lt;- c(&quot;gaussian&quot;, &quot;epanechnikov&quot;, &quot;rectangular&quot;, &quot;triangular&quot;, &quot;biweight&quot;, &quot;cosine&quot;, &quot;optcosine&quot;) p &lt;- plot_ly() for (k in kerns) { d &lt;- density(txhousing$median, kernel = k, na.rm = TRUE) p &lt;- add_lines(p, x = d$x, y = d$y, name = k) } layout(p, xaxis = list(title = &quot;Median monthly price&quot;)) FIGURE 4.13: Various kernel density estimates. 4.2.2 Parallel Coordinates One very useful, but often overlooked, visualization technique is the parallel coordinates plot. Parallel coordinates provide a way to compare values along a common (or non-aligned) positional scale(s) – the most basic of all perceptual tasks – in more than 3 dimensions (Cleveland and McGill 1984). Usually each line represents every measurement for a given row (or observation) in a data set. When measurements are on very different scales, some care must be taken, and variables must transformed to be put on a common scale. As Figure 4.14 shows, even when variables are measured on a similar scale, it can still be informative to transform variables in different ways. iris$obs &lt;- seq_len(nrow(iris)) iris_pcp &lt;- function(transform = identity) { iris[] &lt;- purrr::map_if(iris, is.numeric, transform) tidyr::gather(iris, variable, value, -Species, -obs) %&gt;% group_by(obs) %&gt;% plot_ly(x = ~variable, y = ~value, color = ~Species) %&gt;% add_lines(alpha = 0.3) } subplot( iris_pcp(), iris_pcp(scale), iris_pcp(scales::rescale) ) %&gt;% hide_legend() FIGURE 4.14: Parallel coordinates plots of the Iris dataset. On the left is the raw measurements. In the middle, each variable is scaled to have mean of 0 and standard deviation of 1. On the right, each variable is scaled to have a minimum of 0 and a maximum of 1. It is also worth noting that the GGally offers a ggparcoord() function which creates parallel coordinate plots via ggplot2, which we can convert to plotly via ggplotly(). Thanks to the linked highlighting framework, parallel coordinates created in this way could be linked to lower dimensional (but sometimes higher resolution) graphics of related data to guide multi-variate data exploration. 4.2.3 3D paths To make a path in 3D, use add_paths() in the same way you would for a 2D path, but add a third variable z, as Figure 4.15 does. plot_ly(mpg, x = ~cty, y = ~hwy, z = ~cyl) %&gt;% add_paths(color = ~displ) FIGURE 4.15: A path in 3D Figure 4.16 uses add_lines() instead of add_paths() to ensure the points are connected by the x axis instead of the row ordering. plot_ly(mpg, x = ~cty, y = ~hwy, z = ~cyl) %&gt;% add_lines(color = ~displ) FIGURE 4.16: A 3D line plot 4.3 Segments The add_segments() function essentially provides a way to connect two points ((x, y) to (xend, yend)) with a line. Segments form the building blocks for many useful chart types, including candlestick charts, a popular way to visualize stock prices. Figure 4.17 uses the quantmod package (Ryan 2016) to obtain stock price data for Microsoft and plots two segments for each day: one to encode the opening/closing values, and one to encode the daily high/low. library(quantmod) msft &lt;- getSymbols(&quot;MSFT&quot;, auto.assign = F) dat &lt;- as.data.frame(msft) dat$date &lt;- index(msft) dat &lt;- subset(dat, date &gt;= &quot;2016-01-01&quot;) names(dat) &lt;- sub(&quot;^MSFT\\\\.&quot;, &quot;&quot;, names(dat)) plot_ly(dat, x = ~date, xend = ~date, color = ~Close &gt; Open, colors = c(&quot;red&quot;, &quot;forestgreen&quot;), hoverinfo = &quot;none&quot;) %&gt;% add_segments(y = ~Low, yend = ~High, size = I(1)) %&gt;% add_segments(y = ~Open, yend = ~Close, size = I(3)) %&gt;% layout(showlegend = FALSE, yaxis = list(title = &quot;Price&quot;)) %&gt;% rangeslider() FIGURE 4.17: A candlestick chart 4.4 Ribbons Ribbons are useful for showing uncertainty bounds as a function of x. The add_ribbons() function creates ribbons and requires the arguments: x, ymin, and ymax. The augment() function from the broom package appends observational-level model components (e.g., fitted values stored as a new column .fitted) which is useful for extracting those components in a convenient form for visualization. Figure 4.18 shows the fitted values and uncertainty bounds from a linear model object. m &lt;- lm(mpg ~ wt, data = mtcars) broom::augment(m) %&gt;% plot_ly(x = ~wt, showlegend = FALSE) %&gt;% add_markers(y = ~mpg, color = I(&quot;black&quot;)) %&gt;% add_ribbons(ymin = ~.fitted - 1.96 * .se.fit, ymax = ~.fitted + 1.96 * .se.fit, color = I(&quot;gray80&quot;)) %&gt;% add_lines(y = ~.fitted, color = I(&quot;steelblue&quot;)) FIGURE 4.18: Plotting fitted values and uncertainty bounds of a linear model via the broom package. 4.5 Polygons The add_polygons() function is essentially equivalent to add_paths() with the fill attribute set to “toself”. Polygons form the basis for other, higher-level, geometries such as add_ribbons(), but can be useful in their own right. map_data(&quot;world&quot;, &quot;canada&quot;) %&gt;% group_by(group) %&gt;% plot_ly(x = ~long, y = ~lat, alpha = 0.2) %&gt;% add_polygons(hoverinfo = &quot;none&quot;, color = I(&quot;black&quot;)) %&gt;% add_markers(text = ~paste(name, &quot;&lt;br /&gt;&quot;, pop), hoverinfo = &quot;text&quot;, color = I(&quot;red&quot;), data = maps::canada.cities) %&gt;% layout(showlegend = FALSE) FIGURE 4.19: A map of Canada using the default cartesian coordinate system. References "],
["maps.html", "5 Maps 5.1 Using scatter traces 5.2 Choropleths 5.3 Using geom_sf()", " 5 Maps 5.1 Using scatter traces As shown in polygons, it is possible to create maps using plotly’s default (Cartesian) coordinate system, but plotly.js also has support for plotting scatter traces on top of either a custom geo layout or a mapbox layout. Figure 5.1 compares the three different layout options in a single subplot. dat &lt;- map_data(&quot;world&quot;, &quot;canada&quot;) %&gt;% group_by(group) map1 &lt;- plot_mapbox(dat, x = ~long, y = ~lat) %&gt;% add_paths(size = I(2)) %&gt;% add_segments(x = -100, xend = -50, y = 50, 75) %&gt;% layout(mapbox = list( zoom = 0, center = list(lat = ~median(lat), lon = ~median(long)) )) # geo() is the only object type which supports different map projections map2 &lt;- plot_geo(dat, x = ~long, y = ~lat) %&gt;% add_markers(size = I(1)) %&gt;% add_segments(x = -100, xend = -50, y = 50, 75) %&gt;% layout(geo = list(projection = list(type = &quot;mercator&quot;))) map3 &lt;- plot_ly(dat, x = ~long, y = ~lat) %&gt;% add_paths(size = I(1)) %&gt;% add_segments(x = -100, xend = -50, y = 50, 75) %&gt;% layout( xaxis = list( scaleanchor = &quot;y&quot;, scaleratio = 1 ) ) htmltools::tagList(map1, map2, map3) FIGURE 5.1: Three different ways to render a map. On the top left is plotly’s default cartesian coordinate system, on the top right is plotly’s custom geographic layout, and on the bottom is mapbox. 5.2 Choropleths In addition to scatter traces, plotly-geo objects also support a “native” choropleth api (i.e., plotly.js manages the geo-spatial coordinates). Figure 5.2 shows the population density of the U.S. via a choropleth, and also layers on markers for the state center locations, using the U.S. state data from the datasets package (R Core Team 2016). By simply providing a z attribute, plotly-geo objects will try to create a choropleth, but you’ll also need to provide locations and a locationmode. density &lt;- state.x77[, &quot;Population&quot;] / state.x77[, &quot;Area&quot;] g &lt;- list( scope = &#39;usa&#39;, projection = list(type = &#39;albers usa&#39;), lakecolor = toRGB(&#39;white&#39;) ) plot_geo() %&gt;% add_trace( z = ~density, text = state.name, locations = state.abb, locationmode = &#39;USA-states&#39; ) %&gt;% add_markers( x = state.center[[&quot;x&quot;]], y = state.center[[&quot;y&quot;]], size = I(2), symbol = I(8), color = I(&quot;white&quot;), hoverinfo = &quot;none&quot; ) %&gt;% layout(geo = g) FIGURE 5.2: A map of U.S. population density using the state.x77 data from the datasets package. Any of the add_*() functions found under scatter traces should work as expected on plotly-geo (initialized via plot_geo()) or plotly-mapbox (initialized via plot_mapbox()) objects. You can think of plot_geo() and plot_mapbox() as special cases (or more opinionated versions) of plot_ly(). For one, they won’t allow you to mix scatter and non-scatter traces in a single plot object, which you probably don’t want to do anyway. In order to enable Figure 5.1, plotly.js can’t make this restriction, but since we have subplot() in R, we can make this restriction without sacrificing flexibility. 5.3 Using geom_sf() A more flexible and perhaps intuitive way to create maps is via ggplot2’s geom_sf() which makes it easy to visualize any geo-spatial object supported by the sf package (Pebesma 2018). library(ggplot2) nc &lt;- sf::st_read(system.file(&quot;shape/nc.shp&quot;, package = &quot;sf&quot;), quiet = TRUE) p &lt;- ggplot(nc) + geom_sf(aes(fill = AREA)) ggplotly(p) The most brilliant thing about sf is that it stores geo-spatial structures in a special list-column of a data frame. This allows each row to represent the real unit of observation/interest – a polygon, multi-polygon, point, line, or even a collection of these features – and as a result, supports workflows that leverage tidy-data principles. This is way more intuitive compared to older workflows based on, say using ggplot2::fortify() to obtain a data structure where a row to represents particular point along a feature and having another column track which point belongs to each feature (for example). References "],
["bars-histograms.html", "6 Bars &amp; histograms 6.1 Multiple numeric distributions 6.2 Multiple discrete distributions", " 6 Bars &amp; histograms The add_bars() and add_histogram() functions wrap the bar and histogram plotly.js trace types. The main difference between them is that bar traces require bar heights (both x and y), whereas histogram traces require just a single variable, and plotly.js handles binning in the browser.5 And perhaps confusingly, both of these functions can be used to visualize the distribution of either a numeric or a discrete variable. So, essentially, the only difference between them is where the binning occurs. Figure 6.1 compares the default binning algorithm in plotly.js to a few different algorithms available in R via the hist() function. Although plotly.js has the ability to customize histogram bins via xbins/ybins, R has diverse facilities for estimating the optimal number of bins in a histogram that we can easily leverage.6 The hist() function alone allows us to reference 3 famous algorithms by name (Sturges 1926); (Freedman and Diaconis 1981); (Scott 1979), but there are also packages (e.g. the histogram package) which extend this interface to incorporate more methodology (Mildenberger, Rozenholc, and Zasada. 2009). The price_hist() function below wraps the hist() function to obtain the binning results, and map those bins to a plotly version of the histogram using add_bars(). p1 &lt;- plot_ly(diamonds, x = ~price) %&gt;% add_histogram(name = &quot;plotly.js&quot;) price_hist &lt;- function(method = &quot;FD&quot;) { h &lt;- hist(diamonds$price, breaks = method, plot = FALSE) plot_ly(x = h$mids, y = h$counts) %&gt;% add_bars(name = method) } subplot( p1, price_hist(), price_hist(&quot;Sturges&quot;), price_hist(&quot;Scott&quot;), nrows = 4, shareX = TRUE ) FIGURE 6.1: plotly.js’s default binning algorithm versus R’s hist() default Figure 6.2 demonstrates two ways of creating a basic bar chart. Although the visual results are the same, its worth noting the difference in implementation. The add_histogram() function sends all of the observed values to the browser and lets plotly.js perform the binning. It takes more human effort to perform the binning in R, but doing so has the benefit of sending less data, and requiring less computation work of the web browser. In this case, we have only about 50,000 records, so there is not much of a difference in page load times or page size. However, with 1 Million records, page load time more than doubles and page size nearly doubles.7 p1 &lt;- plot_ly(diamonds, x = ~cut) %&gt;% add_histogram() p2 &lt;- diamonds %&gt;% dplyr::count(cut) %&gt;% plot_ly(x = ~cut, y = ~n) %&gt;% add_bars() subplot(p1, p2) %&gt;% hide_legend() FIGURE 6.2: Number of diamonds by cut. 6.1 Multiple numeric distributions It is often useful to see how the numeric distribution changes with respect to a discrete variable. When using bars to visualize multiple numeric distributions, I recommend plotting each distribution on its own axis, rather than trying to overlay them on a single axis.8. This is where the subplot() infrastructure, and its support for trellis displays, comes in handy. Figure 6.3 shows a trellis display of diamond price by diamond color. Note how the one_plot() function defines what to display on each panel, then a split-apply-recombine strategy is employed to generate the trellis display. one_plot &lt;- function(d) { plot_ly(d, x = ~price) %&gt;% add_annotations( ~unique(clarity), x = 0.5, y = 1, xref = &quot;paper&quot;, yref = &quot;paper&quot;, showarrow = FALSE ) } diamonds %&gt;% split(.$clarity) %&gt;% lapply(one_plot) %&gt;% subplot(nrows = 2, shareX = TRUE, titleX = FALSE) %&gt;% hide_legend() FIGURE 6.3: A trellis display of diamond price by diamond clarity. 6.2 Multiple discrete distributions Visualizing multiple discrete distributions is difficult. The subtle complexity is due to the fact that both counts and proportions are important for understanding multi-variate discrete distributions. Figure 6.4 presents diamond counts, divided by both their cut and clarity, using a grouped bar chart. plot_ly(diamonds, x = ~cut, color = ~clarity) %&gt;% add_histogram() FIGURE 6.4: A grouped bar chart Figure 6.4 is useful for comparing the number of diamonds by clarity, given a type of cut. For instance, within “Ideal” diamonds, a cut of “VS1” is most popular, “VS2” is second most popular, and “I1” the least popular. The distribution of clarity within “Ideal” diamonds seems to be fairly similar to other diamonds, but it’s hard to make this comparison using raw counts. Figure 6.5 makes this comparison easier by showing the relative frequency of diamonds by clarity, given a cut. # number of diamonds by cut and clarity (n) cc &lt;- count(diamonds, cut, clarity) # number of diamonds by cut (nn) cc2 &lt;- left_join(cc, count(cc, cut, wt = n)) cc2 %&gt;% mutate(prop = n / nn) %&gt;% plot_ly(x = ~cut, y = ~prop, color = ~clarity) %&gt;% add_bars() %&gt;% layout(barmode = &quot;stack&quot;) FIGURE 6.5: A stacked bar chart showing the proportion of diamond clarity within cut. This type of plot, also known as a spine plot, is a special case of a mosaic plot. In a mosaic plot, you can scale both bar widths and heights according to discrete distributions. For mosaic plots, I recommend using the ggmosaic package (Jeppson, Hofmann, and Cook 2016), which implements a custom ggplot2 geom designed for mosaic plots, which we can convert to plotly via ggplotly(). Figure 6.6 shows a mosaic plot of cut by clarity. Notice how the bar widths are scaled proportional to the cut frequency. library(ggmosaic) p &lt;- ggplot(data = cc) + geom_mosaic(aes(weight = n, x = product(cut), fill = clarity)) ggplotly(p) FIGURE 6.6: Using ggmosaic and ggplotly() to create advanced interactive visualizations of categorical data References "],
["boxplots.html", "7 Boxplots", " 7 Boxplots Boxplots encode the five number summary of a numeric variable, and are more efficient than trellis displays of histograms for comparing many numeric distributions. The add_boxplot() function requires one numeric variable, and guarantees boxplots are oriented correctly, regardless of whether the numeric variable is placed on the x or y scale. As Figure 7.1 shows, on the axis orthogonal to the numeric axis, you can provide a discrete variable (for conditioning) or supply a single value (to name the axis category). p &lt;- plot_ly(diamonds, y = ~price, color = I(&quot;black&quot;), alpha = 0.1, boxpoints = &quot;suspectedoutliers&quot;) p1 &lt;- p %&gt;% add_boxplot(x = &quot;Overall&quot;) p2 &lt;- p %&gt;% add_boxplot(x = ~cut) subplot( p1, p2, shareY = TRUE, widths = c(0.2, 0.8), margin = 0 ) %&gt;% hide_legend() FIGURE 7.1: Overall diamond price and price by cut. If you want to partition by more than one discrete variable, I recommend mapping the interaction of those variables to the discrete axis, and coloring by the nested variable, as Figure 7.2 does with diamond clarity and cut. plot_ly(diamonds, x = ~price, y = ~interaction(clarity, cut)) %&gt;% add_boxplot(color = ~clarity) %&gt;% layout(yaxis = list(title = &quot;&quot;), margin = list(l = 100)) FIGURE 7.2: Diamond prices by cut and clarity. It is also helpful to sort the boxplots according to something meaningful, such as the median price. Figure 7.3 presents the same information as Figure 7.2, but sorts the boxplots by their median, and makes it immediately clear that diamonds with a cut of “SI2” have the highest diamond price, on average. d &lt;- diamonds %&gt;% mutate(cc = interaction(clarity, cut)) # interaction levels sorted by median price lvls &lt;- d %&gt;% group_by(cc) %&gt;% summarise(m = median(price)) %&gt;% arrange(m) %&gt;% .[[&quot;cc&quot;]] plot_ly(d, x = ~price, y = ~factor(cc, lvls)) %&gt;% add_boxplot(color = ~clarity) %&gt;% layout(yaxis = list(title = &quot;&quot;), margin = list(l = 100)) FIGURE 7.3: Diamond prices by cut and clarity, sorted by price median. Similar to add_histogram(), add_boxplot() sends the raw data to the browser, and lets plotly.js compute summary statistics. Unfortunately, plotly.js does not yet allow precomputed statistics for boxplots.9 Follow the issue here https://github.com/plotly/plotly.js/issues/242↩ "],
["d-frequencies.html", "8 2D frequencies 8.1 Rectangular binning in plotly.js 8.2 Rectangular binning in R 8.3 Categorical axes", " 8 2D frequencies 8.1 Rectangular binning in plotly.js The plotly package provides two functions for displaying rectangular bins: add_heatmap() and add_histogram2d(). For numeric data, the add_heatmap() function is a 2D analog of add_bars() (bins must be pre-computed), and the add_histogram2d() function is a 2D analog of add_histogram() (bins can be computed in the browser). Thus, I recommend add_histogram2d() for exploratory purposes, since you don’t have to think about how to perform binning. It also provides a useful zsmooth attribute for effectively increasing the number of bins (currently, “best” performs a bi-linear interpolation, a type of nearest neighbors algorithm), and nbinsx/nbinsy attributes to set the number of bins in the x and/or y directions. Figure 8.1 compares three different uses of add_histogram(): (1) plotly.js’ default binning algorithm, (2) the default plus smoothing, (3) setting the number of bins in the x and y directions. Its also worth noting that filled contours, instead of bins, can be used in any of these cases by using histogram2dcontour() instead of histogram2d(). p &lt;- plot_ly(diamonds, x = ~log(carat), y = ~log(price)) subplot( add_histogram2d(p) %&gt;% colorbar(title = &quot;default&quot;) %&gt;% layout(xaxis = list(title = &quot;default&quot;)), add_histogram2d(p, zsmooth = &quot;best&quot;) %&gt;% colorbar(title = &quot;zsmooth&quot;) %&gt;% layout(xaxis = list(title = &quot;zsmooth&quot;)), add_histogram2d(p, nbinsx = 60, nbinsy = 60) %&gt;% colorbar(title = &quot;nbins&quot;) %&gt;% layout(xaxis = list(title = &quot;nbins&quot;)), shareY = TRUE, titleX = TRUE ) FIGURE 8.1: Three different uses of histogram2d() 8.2 Rectangular binning in R In Bars &amp; histograms, we leveraged a number of algorithms in R for computing the “optimal” number of bins for a histogram, via hist(), and routing those results to add_bars(). There is a surprising lack of research and computational tools for the 2D analog, and among the research that does exist, solutions usually depend on characteristics of the unknown underlying distribution, so the typical approach is to assume a Gaussian form (Scott 1992). Practically speaking, that assumption is not very useful, but 2D kernel density estimation provides a useful alternative that tends to be more robust to changes in distributional form. Although kernel density estimation requires choice of kernel and a bandwidth parameter, the kde2d() function from the MASS package provides a well-supported rule-of-thumb for estimating the bandwidth of a Gaussian kernel density (Venables and Ripley 2002). Figure 8.2 uses kde2d() to estimate a 2D density, scales the relative frequency to an absolute frequency, then uses the add_heatmap() function to display the results as a heatmap. kde_count &lt;- function(x, y, ...) { kde &lt;- MASS::kde2d(x, y, ...) df &lt;- with(kde, setNames(expand.grid(x, y), c(&quot;x&quot;, &quot;y&quot;))) # The &#39;z&#39; returned by kde2d() is a proportion, # but we can scale it to a count df$count &lt;- with(kde, c(z) * length(x) * diff(x)[1] * diff(y)[1]) data.frame(df) } kd &lt;- with(diamonds, kde_count(log(carat), log(price), n = 30)) plot_ly(kd, x = ~x, y = ~y, z = ~count) %&gt;% add_heatmap() %&gt;% colorbar(title = &quot;Number of diamonds&quot;) FIGURE 8.2: 2D Density estimation via the kde2d() function 8.3 Categorical axes The functions add_histogram(), add_histogram2contour(), and add_heatmap() all support categorical axes. Thus, add_histogram() can be used to easily display 2-way contingency tables, but since its easier to compare values along a common scale rather than compare colors (Cleveland and McGill 1984), I recommend creating grouped bar charts instead. The add_heatmap() function can still be useful for categorical axes, however, as it allows us to display whatever quantity we want along the z axis (color). Figure 8.3 uses add_heatmap() to display a correlation matrix. Notice how the limits arguments in the colorbar() function can be used to expand the limits of the color scale to reflect the range of possible correlations (something that is not easily done in plotly.js). corr &lt;- cor(dplyr::select_if(diamonds, is.numeric)) plot_ly(x = rownames(corr), y = colnames(corr), z = corr, colors = &quot;RdBu&quot;) %&gt;% add_heatmap() %&gt;% colorbar(limits = c(-1, 1)) FIGURE 8.3: Displaying a correlation matrix with add_heatmap() and controling the scale limits with colorbar(). References "],
["other-3d-plots.html", "9 Other 3D plots", " 9 Other 3D plots In scatter traces, we saw how to make 3D scatter plots and 3D paths/lines, but plotly.js also supports 3D surface and triangular mesh surfaces (aka trisurf plots). For a nice tutorial on creating trisurf plots in R via plot_ly(), I recommend visiting this tutorial. Creating 3D surfaces with add_surface() is a lot like creating heatmaps with add_heatmap(). In fact, you can even create 3D surfaces over categorical x/y (try changing add_heatmap() to add_surface() in Figure 8.3)! That being said, there should be a sensible ordering to the x/y axes in a surface plot since plotly.js interpolates z values. Usually the 3D surface is over a continuous region, as is done in Figure 9.1 to display the height of a volcano. If a numeric matrix is provided to z as in Figure 9.1, the x and y attributes do not have to be provided, but if they are, the length of x should match the number of columns in the matrix and y should match the number of rows. x &lt;- seq_len(nrow(volcano)) + 100 y &lt;- seq_len(ncol(volcano)) + 500 plot_ly() %&gt;% add_surface(x = ~x, y = ~y, z = ~volcano) FIGURE 9.1: A 3D surface of volcano height. "],
["raster-images.html", "10 Raster images", " 10 Raster images In R, there is native support for raster objects which encode bitmap images as essentially a matrix of color codes. m &lt;- matrix(hcl(0, 80, seq(50, 80, 10)), nrow = 4, ncol = 5) (r &lt;- as.raster(m)) #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] &quot;#C54E6D&quot; &quot;#C54E6D&quot; &quot;#C54E6D&quot; &quot;#C54E6D&quot; &quot;#C54E6D&quot; #&gt; [2,] &quot;#E16A86&quot; &quot;#E16A86&quot; &quot;#E16A86&quot; &quot;#E16A86&quot; &quot;#E16A86&quot; #&gt; [3,] &quot;#FE86A1&quot; &quot;#FE86A1&quot; &quot;#FE86A1&quot; &quot;#FE86A1&quot; &quot;#FE86A1&quot; #&gt; [4,] &quot;#FFA2BC&quot; &quot;#FFA2BC&quot; &quot;#FFA2BC&quot; &quot;#FFA2BC&quot; &quot;#FFA2BC&quot; plot(r) The raster2uri() function converts raster objects to a data URI, so they can be easily embedded via plotly’s image API: plot_ly() %&gt;% layout(images = list( source = raster2uri(r), # converts a raster object to a data URI. xref = &quot;x&quot;, yref = &quot;y&quot;, x = 0, y = 0, sizex = 1, sizey = 1, sizing = &quot;stretch&quot;, xanchor = &quot;left&quot;, yanchor = &quot;bottom&quot; )) FIGURE 10.1: A simple raster object displayed as an image For more examples of the image API, see https://plot.ly/r/logos/ "],
["other-chart-types.html", "11 Other chart types", " 11 Other chart types Point to https://plot.ly docs? "],
["leveraging-ggplotly.html", "12 Leveraging ggplotly() 12.1 A case study comparing ggplotly() to plot_ly()", " 12 Leveraging ggplotly() Talk generally about what things ggplot2 makes easy That is, when to use ggplotly() over plot_ly()? Cover ggplot2 geoms that fill a void left by plot_ly() geom_freqpoly() 12.1 A case study comparing ggplotly() to plot_ly() That is, what’s currently in ggplotly-vs-plotly.Rmd "],
["introduction-2.html", "13 Introduction", " 13 Introduction This chapter shows you how to save and embed your plotly graphs within larger HTML documents, interactively edit (i.e., post-process) them, and export to static file formats – all of which can be useful tools for creating ‘publication-quality’ graphics. Static images can be created either from the command line (via the orca() function) or from the interactive graphic itself. The former is great if you need to export many images at once and the latter is convenient if you need to export a manually edited version of the default view (e.g., Figure 16.1). All the R code in this chapter runs entirely locally using 100% free and open source software with no calls to external services. "],
["saving-and-embedding-html.html", "14 Saving and embedding HTML", " 14 Saving and embedding HTML Any widget made from any htmlwidgets package (e.g., plotly, leaflet, DT, etc) can be saved as a standalone HTML file via the htmlwidgets::saveWidget() function. By default, it produces a completely self-contained HTML file, meaning that all the necessary JavaScript and CSS dependency files are bundled inside the HTML file. This makes it very easy to share a widget as a single HTML file. In this case, consider using the partial_bundle() function to reduce the size of the bundled files. By default, it automatically determines a reduced version of plotly.js that is sufficient for rendering your graphic. This can lead to a substantial reduction in the overall file size, especially if you’re using basic chart types: p &lt;- plot_ly(x = 1:10, y = 1:10) %&gt;% add_markers() widget_file_size &lt;- function(p) { d &lt;- tempdir() withr::with_dir(d, htmlwidgets::saveWidget(p, &quot;index.html&quot;)) f &lt;- file.path(d, &quot;index.html&quot;) mb &lt;- round(file.info(f)$size / 1e6, 3) message(&quot;File is: &quot;, mb,&quot; MB&quot;) } widget_file_size(p) #&gt; File is: 3.078 MB widget_file_size(partial_bundle(p)) #&gt; File is: 1.01 MB If you want to embed numerous widgets in a larger HTML document (e.g., via HTML &lt;iframe&gt;s), self-contained HTML is not recommended. That’s because, if you embed numerous self-contained widgets inside a larger document, your browser has to repeatedly parse the same dependencies over and over. Instead, if you save all the dependency files externally into a single directory, the browser will only have to parse those dependencies once, which can dramatically improve responsiveness. You can do this by setting selfcontained = FALSE and specifying a fixed libdir in saveWidget(). It’s also worth noting that using htmlwidgets::saveWidget() with selfcontained = FALSE is essentially the same as using htmltools::save_html() which saves arbitrary HTML content to a file. The htmltools::save_html() function is useful for saving numerous htmlwidgets (e.g., Figure ??) and/or other custom HTML markup (e.g., Figure 30.1) in a single HTML page. htmlwidgets::saveWidget(plot_ly(x = rnorm(100)), &quot;p1.html&quot;, selfcontained = FALSE, libdir = &quot;lib&quot;) htmlwidgets::saveWidget(plot_ly(x = rnorm(100)), &quot;p2.html&quot;, selfcontained = FALSE, libdir = &quot;lib&quot;) In this case, if you wanted to share \"p1.html\" and/or \"p2.html\" with someone else, make sure to include the libdir folder, perhaps via a zip file: zip(&quot;p1.zip&quot;, c(&quot;p1.html&quot;, &quot;lib&quot;)) zip(&quot;p2.zip&quot;, c(&quot;p2.html&quot;, &quot;lib&quot;)) Embedding these HTML files via an HTML &lt;iframe&gt; is convenient not only for re-using a widget in various parent documents, but also for preventing any JavaScript and CSS in the parent document from negatively impacting how the widget renders. Rather than writing the HTML &lt;iframe&gt; tag directly, I recommend using htmltools::tags$iframe() – this will allow you to leverage bookdown’s figure captioning, numbering, and automatic snapshots for non-HTML output: ` ``{r} htmltools::tags$iframe( src = &quot;p1.html&quot;, scrolling = &quot;no&quot;, seamless = &quot;seamless&quot;, frameBorder = &quot;0&quot; ) ``` A great tool that helps automate this sort of workflow with responsive iframes is the widgetframe package (Karambelkar 2017). See the ‘widgetframe and knitr’ vignette for documentation of options for controling where, how, and if external dependencies are stored on the file system when using it inside a knitr/rmarkdown document. browseVignettes(&quot;widgetframe&quot;) References "],
["exporting-static-images.html", "15 Exporting static images 15.1 With code 15.2 From a browser 15.3 Sizing exports", " 15 Exporting static images 15.1 With code Any plotly object can be saved as a static image via the orca() function. To use it, you’ll need the orca command-line utility (CLI). This CLI can be installed via node.js, conda, or a standalone binary from https://github.com/plotly/orca/releases. Figure 15.1 demonstrates how orca() can generate a svg (or pdf) that can then be imported into Adobe Illustrator for post-processing. Although it’s a nice option to have, importing into Adobe Illustrator might not enable as nice of a workflow as using plotly’s native support for editable layout components in the browser, then exporting to svg/pdf (as shown in Figure 16.1). FIGURE 15.1: Using the orca() function to export a WebGL/Canvas based plotly graphic to a static pdf file. That pdf file can then be imported into Adobe Illustrator for post-processing. 15.2 From a browser Exporting an image from a browser is a nice option if you need to perform edits before exporting or if you’d like others to share your work. By default, the ‘download plot’ icon in the modebar will download to png and use the height and width of the plot, but these defaults can be altered via the plot’s configuration: plot_ly() %&gt;% config( toImageButtonOptions = list( format = &quot;svg&quot;, filename = &quot;myplot&quot;, width = 600, height = 700 ) ) FIGURE 15.2: Specifying options for static image exporting via the modebar. Clicking on the ‘download plot’ icon should prompt your browser to download a static svg file named ‘myplot.svg’ 15.3 Sizing exports It’s worth noting that the height and width of a static image must be specified in pixels, which is intuitive for most file formats (png, jpeg, svg, etc) but when exporting to pdf, you might want to specify the size in inches. If you multiply the DPI of your machine’s display by the number of inches you want, you’ll get the desired result. So, if you want a 8x11 pdf, and are on a typical 96 DPI display, you can do: orca(plot_ly(), width = 8 * 96, height = 11 * 96) On the other hand, if you’re performing interactive editing and exporting, you may want to set a fixed size for the plot: plot_ly(width = 8 * 96, height = 11 * 96) %&gt;% config(toImageButtonOptions = list(format = &quot;svg&quot;)) "],
["editing-views-for-publishing.html", "16 Editing views for publishing", " 16 Editing views for publishing Numerous layout components of a plotly graph can be directly manipulated, including annotation text and placement (more on this in section 21.2.3). In addition, the download (aka, toImage) button can be customized to export a static version to different file types including: svg, png, jpeg, and webp. Since svg can be easily converted to pdf, this effectively means we can edit a graph in a browser to perform touch-ups, then export to a high-quality pdf. At least currently, this workflow is recommended over first exporting to pdf (via orca()) then using Adobe Illustrator to manipulate the vectors, especially for adjusting the placement of annotations. Figure 16.1 demonstrates this workflow on a choropleth map of estimated income in Minnesota by county where the top 10 counties by total income are labeled.10 For visuals like this, automated algorithms for placing the labels may not yield polished results, so it can be nice to have the option to adjust the placement manually. Although pressing ‘download plot’ exports a static version of the current state of the plot, there currently isn’t an official way to save the state of these manual edits in the HTML version. You could, however, create a shiny app that listens to the 'plotly_relayout' event to obtain the new annotation positions (see, for example, Figure 21.5) and translate that information into code. Click to show code library(dplyr) library(sf) library(purrr) library(tidycensus) library(USAboundaries) # obtain geographical information for each county in MN mn_sf &lt;- us_counties(states = &quot;MN&quot;) # get income information for each county in MN mn_income &lt;- get_acs(geography = &quot;county&quot;, variables = &quot;B19013_001&quot;, state = &quot;MN&quot;) %&gt;% mutate( NAME = sub(&quot;County, Minnesota&quot;, &quot;&quot;, NAME), county = reorder(NAME, estimate), color = scales::col_numeric(&quot;viridis&quot;, NULL)(estimate) ) # find center of each county (for placing annotations) mn_center &lt;- mn_sf %&gt;% st_centroid() %&gt;% mutate( x = map_dbl(geometry, 1), y = map_dbl(geometry, 2) ) # get top 10 counties by income with their x/y center location top10labels &lt;- mn_income %&gt;% top_n(10, estimate) %&gt;% left_join(mn_center, by = c(&quot;GEOID&quot; = &quot;geoid&quot;)) # the map and top 10 county labels map &lt;- plot_ly() %&gt;% add_sf( data = left_join(mn_sf, mn_income, by = c(&quot;geoid&quot; = &quot;GEOID&quot;)), color = ~I(color), split = ~NAME, stroke = I(&quot;black&quot;), span = I(1), hoverinfo = &quot;none&quot; ) %&gt;% add_annotations( data = select(top10labels, NAME, x, y), text = ~NAME, x = ~x, y = ~y ) # the dot-plot bars &lt;- ggplot(mn_income, aes(x = estimate, y = county)) + geom_errorbarh(aes(xmin = estimate - moe, xmax = estimate + moe)) + geom_point(aes(color = color), size = 2) + scale_color_identity() # make manual edits in the browser, then click the # &#39;toImage&#39; button to export an svg file ggplotly(bars, dynamicTicks = TRUE, tooltip = &quot;y&quot;, height = 8 * 96, width = 11 * 96) %&gt;% subplot(map, nrows = 1, widths = c(0.3, 0.7)) %&gt;% layout(showlegend = FALSE) %&gt;% config( edits = list( annotationPosition = TRUE, annotationTail = TRUE, annotationText = TRUE ), toImageButtonOptions = list(format = &quot;svg&quot;) ) FIGURE 16.1: Estimated total income by county in Minnesota. The top 10 counties are labeled with editable annotations. After manually adjusting the placement of county labels in a web browser, and zooming in on the top 10 counties in the dot plot, the ‘download plot’ button is used to export to svg. After pressing the “download plot” button to export svg, then the rsvg package can be used to convert the svg to pdf (Ooms 2018). # This is the directory that my browser places downloads... # you may have to change this to your download directory download_dir &lt;- &quot;~/Downloads/&quot; withr::with_dir(download_dir, rsvg::rsvg_pdf(&quot;newplot.svg&quot;, &quot;mn.pdf&quot;)) References "],
["arranging-views.html", "17 Arranging views 17.1 Arranging htmlwidgets 17.2 Merging plotly objects 17.3 Navigating many views", " 17 Arranging views One technique essential to high-dimensional data analysis is the ability to arrange multiple views. Ideally, these views are linked in some way to foster comparisons (the next chapter discusses linking techniques). The next section, Arranging htmlwidgets describes techniques for arranging htmlwidget objects, which many R packages for creating web-based data visualizations build upon, including plotly. Typically interactivity is isolated within an htmlwidget object, but Linking views without shiny explores some more recent work on enabling interactivity across htmlwidget objects. The following section, Subplots describes the subplot() function, which is useful for merging multiple plotly objects into a single htmlwidget object. The main benefit of merging (rather than arranging) plotly objects is that it gives us the ability to synchronize zoom and pan events across multiple axes. The last section, Navigating many views discusses some useful tools for restricting focus on interesting views when there are more views than you can possibly digest visually. 17.1 Arranging htmlwidgets Since plotly objects inherit properties from an htmlwidget object, any method that works for arranging htmlwidgets also works for plotly objects. In some sense, an htmlwidget object is just a collection of HTML tags, and the htmltools package provides some useful functions for working with HTML tags (RStudio and Inc. 2016). The tagList() function gathers multiple HTML tags into a tag list, and when printing a tag list inside of a knitr/rmarkdown document (Xie 2016a); (Allaire et al. 2016), it knows to render as HTML. However, when printing via the R/RStudio console, you must use browsable() to render and open the tag list as a web page (otherwise, it prints the HTML tags to your R console). Those familiar with shiny might already be familiar with using uiOutput() and/or renderUI() to dynamically render tag lists server-side. library(htmltools) library(plotly) p &lt;- plot_ly(x = rnorm(100)) # NOTE: you don&#39;t need browsable() in rmarkdown, but you do at the R prompt browsable(tagList(p, p)) FIGURE 17.1: Printing multiple htmlwidget objects with tagList(). To render tag lists at the command line, wrap them in browsable() Figure 17.1 renders two plots, each in its own row spanning the width of the page, because each htmlwidget object is an HTML &lt;div&gt; tag. More often than not, it is desirable to arrange multiple plots in a given row, and there are a few ways to do that. A very flexible approach is to wrap all of your plots in a flexbox (i.e., an HTML &lt;div&gt; with display: flex Cascading Style Sheets (CSS) property). The tags$div() function from htmltools provides a way to wrap a &lt;div&gt; around both tag lists and htmlwidget objects, and set attributes, such as style. As Figure 17.2 demonstrates, this approach also provides a nice way to add custom styling to the page, such as borders around each panel. tags$div( style = &quot;display: flex; flex-wrap: wrap&quot;, tags$div(p, style = &quot;width: 50%; padding: 1em; border: solid;&quot;), tags$div(p, style = &quot;width: 50%; padding: 1em; border: solid;&quot;), tags$div(p, style = &quot;width: 100%; padding: 1em; border: solid;&quot;) ) FIGURE 17.2: Arranging multiple htmlwidgets with flexbox Another way to arrange multiple htmlwidget objects on a single page is to leverage the fluidPage(), fluidRow(), and column() functions from the shiny package. library(shiny) fluidPage( fluidRow(p), fluidRow( column(6, p), column(6, p) ) ) FIGURE 17.3: Arranging multiple htmlwidgets with fluidPage() from the shiny package. All the arrangement approaches discussed thus far are agnostic to output format, meaning that they can be used to arrange htmlwidgets within any knitr/rmarkdown document.11 If the htmlwidgets do not need to be embedded within a larger document that requires an opinionated output format, the flexdashboard package provides a rmarkdown template for generating dashboards, with a convenient syntax for arranging views (Allaire 2016). 17.2 Merging plotly objects The subplot() function provides a flexible interface for merging multiple plotly objects into a single object (i.e., view). It is more flexible than most trellis display frameworks (e.g., ggplot2’s facet_wrap()) as you don’t have to condition on a value of common variable in each display (Richard A. Becker 1996). Its capabilities and interface is similar to the grid.arrange() function from the gridExtra package, which allows you to arrange multiple grid grobs in a single view, effectively providing a way to arrange (possibly unrelated) ggplot2 and/or lattice plots in a single view (R Core Team 2016); (Auguie 2016); (Sarkar 2008). Figure 17.4 shows the most simple way to use subplot() which is to directly supply plotly objects. library(plotly) p1 &lt;- plot_ly(economics, x = ~date, y = ~unemploy) %&gt;% add_lines(name = &quot;unemploy&quot;) p2 &lt;- plot_ly(economics, x = ~date, y = ~uempmed) %&gt;% add_lines(name = &quot;uempmed&quot;) subplot(p1, p2) FIGURE 17.4: The most basic use of subplot() to merge multiple plotly objects into a single plotly object. Although subplot() accepts an arbitrary number of plot objects, passing a list of plots can save typing and redundant code when dealing with a large number of plots. Figure 17.5 shows one time series for each variable in the economics dataset and share the x-axis so that zoom/pan events are synchronized across each series: vars &lt;- setdiff(names(economics), &quot;date&quot;) plots &lt;- lapply(vars, function(var) { plot_ly(economics, x = ~date, y = as.formula(paste0(&quot;~&quot;, var))) %&gt;% add_lines(name = var) }) subplot(plots, nrows = length(plots), shareX = TRUE, titleX = FALSE) FIGURE 17.5: Five different economic variables on different y scales and a common x scale. Zoom and pan events in the x-direction are synchronized across plots. A plotly subplot is a single plotly graph with multiple traces anchored on different axes. If you pre-specify an axis ID for each trace, subplot() will respect that ID. Figure 17.6 uses this fact in correspondence with the fact that mapping a discrete variable to color creates one trace per value. In addition to providing more control over trace placement, this provides a convenient way to control coloring (we could have symbol/linetype to achieve the same effect). economics %&gt;% tidyr::gather(variable, value, -date) %&gt;% transform(id = as.integer(factor(variable))) %&gt;% plot_ly(x = ~date, y = ~value, color = ~variable, colors = &quot;Dark2&quot;, yaxis = ~paste0(&quot;y&quot;, id)) %&gt;% add_lines() %&gt;% subplot(nrows = 5, shareX = TRUE) FIGURE 17.6: Pre-populating y axis IDs. Conceptually, subplot() provides a way to place a collection of plots into a table with a given number of rows and columns. The number of rows (and, by consequence, the number of columns) is specified via the nrows argument. By default each row/column shares an equal proportion of the overall height/width, but as shown in Figure 17.7 the default can be changed via the heights and widths arguments. FIGURE 17.7: A visual diagram of controling the heights of rows and widths of columns. This flexibility is quite useful for a number of visualizations, for example, as shown in Figure 17.8, a joint density plot is really of subplot of joint and marginal densities. The heatmaply package is great example of leveraging subplot() in a similar way to create interactive dendrograms (Galili 2016). x &lt;- rnorm(100) y &lt;- rnorm(100) s &lt;- subplot( plot_ly(x = x, color = I(&quot;black&quot;)), plotly_empty(), plot_ly(x = x, y = y, color = I(&quot;black&quot;)), plot_ly(y = y, color = I(&quot;black&quot;)), nrows = 2, heights = c(0.2, 0.8), widths = c(0.8, 0.2), shareX = TRUE, shareY = TRUE, titleX = FALSE, titleY = FALSE ) layout(s, showlegend = FALSE) FIGURE 17.8: A joint density plot with synchronized axes. 17.2.1 Recursive subplots The subplot() function returns a plotly object so it can be modified like any other plotly object. This effectively means that subplots work recursively (i.e., you can have subplots within subplots). This idea is useful when your desired layout doesn’t conform to the table structure described in the previous section. In fact, you can think of a subplot of subplots like a spreadsheet with merged cells. Figure 17.9 gives a basic example where each row of the outer-most subplot contains a different number of columns. plotList &lt;- function(nplots) { lapply(seq_len(nplots), function(x) plot_ly()) } s1 &lt;- subplot(plotList(6), nrows = 2, shareX = TRUE, shareY = TRUE) s2 &lt;- subplot(plotList(2), shareY = TRUE) subplot( s1, s2, plot_ly(), nrows = 3, margin = 0.04, heights = c(0.6, 0.3, 0.1) ) FIGURE 17.9: Recursive subplots. The concept is particularly useful when you want plot(s) in a given row to have different widths from plot(s) in another row. Figure 17.10 uses this recursive behavior to place many bar charts in the first row, and a single choropleth in the second row. # specify some map projection/options g &lt;- list( scope = &#39;usa&#39;, projection = list(type = &#39;albers usa&#39;), lakecolor = toRGB(&#39;white&#39;) ) # create a map of population density density &lt;- state.x77[, &quot;Population&quot;] / state.x77[, &quot;Area&quot;] map &lt;- plot_geo(z = ~density, text = state.name, locations = state.abb, locationmode = &#39;USA-states&#39;) %&gt;% layout(geo = g) # create a bunch of horizontal bar charts vars &lt;- colnames(state.x77) barcharts &lt;- lapply(vars, function(var) { plot_ly(x = state.x77[, var], y = state.name) %&gt;% add_bars(orientation = &quot;h&quot;, name = var) %&gt;% layout(showlegend = FALSE, hovermode = &quot;y&quot;, yaxis = list(showticklabels = FALSE)) }) subplot( subplot(barcharts, margin = 0.01), map, nrows = 2, heights = c(0.3, 0.7), margin = 0.1 ) FIGURE 17.10: Multiple bar charts of US statistics by state in a subplot with a choropleth of population density 17.2.2 ggplot2 subplots Underneath the hood, ggplot2 facets are implemented as subplots, which enables the synchronized zoom events on shared axes. Since subplots work recursively, it is also possible to have a subplot of ggplot2 faceted plots, as Figure 17.11 shows. Moreover, subplot() can understand ggplot objects, so there is no need to translate them to plotly object via ggplotly() (unless you want to leverage some of the ggplotly() arguments, such as tooltip for customizing information displayed on hover). e &lt;- tidyr::gather(economics, variable, value, -date) gg1 &lt;- ggplot(e, aes(date, value)) + geom_line() + facet_wrap(~variable, scales = &quot;free_y&quot;, ncol = 1) gg2 &lt;- ggplot(e, aes(factor(1), value)) + geom_violin() + facet_wrap(~variable, scales = &quot;free_y&quot;, ncol = 1) + theme(axis.text = element_blank(), axis.ticks = element_blank()) subplot(gg1, gg2) %&gt;% layout(margin = list(l = 50)) FIGURE 17.11: Arranging multiple faceted ggplot2 plots into a plotly subplot. 17.3 Navigating many views Sometimes you have to consider way more views than you can possibly digest visually. In Multiple linked views, we explore some useful techniques for implementing the popular visualization mantra from Shneiderman (1996): “Overview first, zoom and filter, then details-on-demand.” In fact, Figure 21.10 from section 21.2.5 provides an example of this mantra put into practice. The correlation matrix provides an overview of the correlation structure between all the variables, and by clicking a cell, it populates a scatterplot between those two specific variables. This works fine with tens or hundreds or variables, but once you have thousands or tens-of-thousands of variables, this technique begins to fall apart. At that point, you may be better off defining a range of correlations that you’re interested in exploring, or better yet, incorporating another measure (e.g., a test statistic), then focusing on views that match a certain criteria. Tukey and Tukey (n.d.) first described the idea of using quantitative measurements of scatterplot characteristics (e.g. correlation) to help guide exploratory analysis of many variables. This idea, coined scagnostics (short for scatterplot diagnostics), has since been made explicit, and many measures have been explored, even measures specifically useful for time-series have been proposed (Wilkinson, Anand, and Grossman 2005); (Wilkinson and Wills 2008); (Dang and Wilkinson 2012). Probably the most universally useful scagnostic is the outlying measure which helps identify projections of the data space that contain outlying observations. Of course, the idea of associating quantitative measures with a graphical display of data can be generalized to include more that just scatterplots, and in this more general case, these measures are sometimes referred to as cognostics. The same problems and principles that inspired scagnostics has inspired work on more general divide &amp; recombine technique(s) for working with navigating through many statistical artifacts (Cleveland and Hafen 2014); (Saptarshi Guha and Cleveland 2012), including visualizations (Hafen et al. 2013). The trelliscope package provides a system for computing arbitrary cognostics on each panel of a trellis display as well as an interactive graphical user interface for defining (and navigating through) interesting panels based on those cognostics (Hafen 2016). This system also allows users to define the graphical method for displaying each panel, so plotly graphs can easily be embedded. The trelliscope package is currently built upon shiny, but as Figure 17.12 demonstrates, the trelliscopejs package provides lower-level tools that allow one to create trelliscope displays without shiny (Hafen and Schloerke, n.d.). library(trelliscopejs) qplot(cty, hwy, data = mpg) + xlim(7, 37) + ylim(9, 47) + theme_bw() + facet_trelliscope( ~ manufacturer + class, nrow = 2, ncol = 4, as_plotly = TRUE, plotly_args = list(dynamicTicks = T) ) FIGURE 17.12: Using plotly within a trelliscope References "],
["animating-views.html", "18 Animating views", " 18 Animating views Both plot_ly() and ggplotly() support key frame animations through the frame attribute/aesthetic. They also support an ids attribute/aesthetic to ensure smooth transitions between objects with the same id (which helps facilitate object constancy). Figure 18.1 recreates the famous gapminder animation of the evolution in the relationship between GDP per capita and life expectancy evolved over time (Bryan 2015). The data is recorded on a yearly basis, so the year is assigned to frame, and each point in the scatterplot represents a country, so the country is assigned to ids, ensuring a smooth transition from year to year for a given country. data(gapminder, package = &quot;gapminder&quot;) gg &lt;- ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent)) + geom_point(aes(size = pop, frame = year, ids = country)) + scale_x_log10() ggplotly(gg) FIGURE 18.1: Animation of the evolution in the relationship between GDP per capita and life expectancy in numerous countries. As long as a frame variable is provided, an animation is produced with play/pause button(s) and a slider component for controlling the animation. These components can be removed or customized via the animation_button() and animation_slider() functions. Moreover, various animation options, like the amount of time between frames, the smooth transition duration, and the type of transition easing may be altered via the animation_opts() function. Figure 18.2 shows the same data as Figure 18.1, but doubles the amount of time between frames, uses linear transition easing, places the animation buttons closer to the slider, and modifies the default currentvalue.prefix settings for the slider. base &lt;- gapminder %&gt;% plot_ly(x = ~gdpPercap, y = ~lifeExp, size = ~pop, text = ~country, hoverinfo = &quot;text&quot;) %&gt;% layout(xaxis = list(type = &quot;log&quot;)) base %&gt;% add_markers(color = ~continent, frame = ~year, ids = ~country) %&gt;% animation_opts(1000, easing = &quot;elastic&quot;, redraw = FALSE) %&gt;% animation_button( x = 1, xanchor = &quot;right&quot;, y = 0, yanchor = &quot;bottom&quot; ) %&gt;% animation_slider( currentvalue = list(prefix = &quot;YEAR &quot;, font = list(color=&quot;red&quot;)) ) FIGURE 18.2: Modifying animation defaults with animation_opts(), animation_button(), and animation_slider(). If frame is a numeric variable (or a character string), frames are always ordered in increasing (alphabetical) order; but for factors, the ordering reflects the ordering of the levels. Consequently, factors provide the most control over the ordering of frames. In Figure 18.3, the continents (i.e., frames) are ordered according their average life expectancy across countries within the continent. Furthermore, since there is no meaningful relationship between objects in different frames of Figure 18.3, the smooth transition duration is set to 0. This helps avoid any confusion that there is a meaningful connection between the smooth transitions. Note that these options control both animations triggered by the play button or via the slider. meanLife &lt;- with(gapminder, tapply(lifeExp, INDEX = continent, mean)) gapminder$continent &lt;- factor( gapminder$continent, levels = names(sort(meanLife)) ) base %&gt;% add_markers(data = gapminder, frame = ~continent) %&gt;% hide_legend() %&gt;% animation_opts(frame = 1000, transition = 0, redraw = FALSE) FIGURE 18.3: Animation of GDP per capita versus life expectancy by continent. The ordering of the contintents goes from lowest average (across countries) life expectancy to highest. Both the frame and ids attributes operate on the trace level – meaning that we can target specific layers of the graph to be animated. One obvious use case for this is to provide a background which displays every possible frame (which is not animated) and overlay the animated frames onto that background. Figure 18.4 shows the same information as Figure 18.2, but layers animated frames on top of a background of all the frames. As a result, it is easier to put a specific year into a global context. base %&gt;% add_markers(color = ~continent, alpha = 0.2, showlegend = F) %&gt;% add_markers(color = ~continent, frame = ~year, ids = ~country) %&gt;% animation_opts(1000, redraw = FALSE) FIGURE 18.4: Overlaying animated frames on top of a background of all possible frames. References "],
["introduction-3.html", "19 Introduction", " 19 Introduction Motivate linked views, perhaps through an example? Discuss the pros/cons between client-side/server-side linking "],
["client-side-linking.html", "20 Client-side linking 20.1 Graphical queries 20.2 Highlight versus filter events 20.3 Linking animated views 20.4 Examples 20.5 Limitations", " 20 Client-side linking Linking of multiple data views offers a powerful approach to visualization as well as communication of structure in high-dimensional data. In particular, linking of multiple 1-2 dimensional statistical graphics can often lead to insight that a single view could not possibly reveal. For decades, statisticians and computer scientists have been using and authoring systems for multiple linked views, many of which can be found in the ASA’s video library. Some noteworthy videos include focusing and linking, missing values, and exploring Tour De France data (Swayne, Cook, and Buja 1998); (Theus and Urbanek 2008). These early systems were incredibly sophisticated, but the interactive graphics they produce are not easily shared, replicated, or incorporated in a larger document. Web technologies offer the infrastructure to address these issues, which is a big reason why many modern interactive graphics systems are web based. When talking about interactive web-based graphics, it’s important to recognize the difference between a web application and a purely client-side webpage, especially when it comes to saving, sharing, and hosting the result. A web application relies on a client-server relationship where the client’s (i.e., end user) web browser requests content from a remote server. This model is necessary whenever the webpage needs to execute computer code that is not natively supported by the client’s web browser. As Section 21 details, the flexibility that a web application framework, like shiny, offers is an incredibly productive and powerful way to link multiple data views; but when it comes to distributing a web application, it introduces a lot of complexity and computational infrastructure that may or may not be necessary. Figure 20.1 is a basic illustration of the difference between a web application and a purely client-side web page. Thanks to JavaScript and HTML5, purely client-side web pages can still be dynamic without any software dependencies besides a modern web browser. In fact, Section (graphical-queries) outlines plotly’s graphical querying framework for linking multiple plots entirely client-side, which makes the result very easy to distribute (see Section (saving)). There are, of course, many useful examples of linked and dynamic views that can not be easily expressed as a database query, but a suprising amount actually can, and the remainder can likely be quickly implemented as a shiny web application. FIGURE 20.1: A diagram of the graphical querying framework underlying Figure 20.7. The graphical querying framework implemented by plotly is inspired by Buja et al. (1991), where direct manipulation of graphical elements in multiple linked plots is used to perform data base queries and visually reveal high-dimensional structure in real-time. Cook, Buja, and Swayne (2007) goes on to argue this framework is preferable to posing data base queries dynamically via a menus, as described by Ahlberg, Williamson, and Shneiderman (1991), and goes on to state that “Multiple linked views are the optimal framework for posing queries about data”. The next section shows you how to implement similar graphical queries in a standalone webpage using R code. 20.1 Graphical queries This section focuses on a particular approach to linking views known as graphical (database) queries using the R package plotly. With plotly, one can write R code to pose graphical queries that operate entirely client-side in a web browser (i.e., no special web server or callback to R is required). In addition to teaching you how to pose queries with the highlight_key() function, this section shows you how to control how queries are triggered and visually rendered via the highlight() function. Figure 20.2 shows a scatterplot of the relationship between weight and miles per gallon of 32 cars. It also uses highlight_key() to assign the number of cylinders to each point so that when a particular point is ‘queried’ all points with the same number of cylinders are highlighted (the number of cylinders is displayed with text just for demonstration purposes). By default, a mouse click triggers a query, and a double-click clears the query, but both of these events can be customized through the highlight() function. By typing help(highlight) in your R console, you can learn more about what events are supported for turning graphical queries on and off. library(plotly) mtcars %&gt;% highlight_key(~cyl) %&gt;% plot_ly(x = ~wt, y = ~mpg, text = ~cyl, mode = &quot;markers+text&quot;, textposition = &quot;top&quot;, hoverinfo = &quot;x+y&quot;) %&gt;% highlight(on = &quot;plotly_hover&quot;, off = &quot;plotly_doubleclick&quot;) FIGURE 20.2: A visual depiction of how highlight_key() attaches metadata to graphical elements to enable graphical database queries. Each point represents a different car and the number of cylinders (cyl) is assigned as metadata so that when a particular point is queried all points with the same number of cylinders are highlighted. Generally speaking, highlight_key() assigns data values to graphical marks so that when graphical mark(s) are directly manipulated through the on event, it uses the corresponding data values (call it $SELECTION_VALUE) to perform an SQL query of the following form. SELECT * FROM mtcars WHERE cyl IN $SELECTION_VALUE For a more compelling application, lets use graphical querying to explore the txhousing dataset first introduced in Section ??. Recall how Figure 41.5 shows Houston and San Antonio housing prices relative to other Texan cities by programmatically highlighting their time series. Instead of highlighting with code, we could allow anyone to explore prices in any city through graphical queries, as shown in Figure 20.3. One subtlety to be aware of in terms of the implementation of this graphical query is that every point along a line may have a different data value assigned to it. In this case, since the city column is used as both the visual grouping and interactive querying variable, we can query an individual time series by clicking on a point along that line. Section 20.4.1 has examples of using different grouping and querying variables to query multiple related groups of visual geometries at once, which can be a powerful technique.12 # set `city` as the SQL &#39;query by&#39; column tx &lt;- highlight_key(txhousing, ~city) # initiate a plotly object base &lt;- plot_ly(tx, color = I(&quot;black&quot;)) %&gt;% group_by(city) # create a time series of median house price time_series &lt;- base %&gt;% group_by(city) %&gt;% add_lines(x = ~date, y = ~median) # set a default query to &#39;South Padre Island&#39; which can be changed via mouse click highlight(time_series, on = &quot;plotly_click&quot;, defaultValue = &quot;South Padre Island&quot;) FIGURE 20.3: Graphical query of housing prices in various Texas cities. The query in this particular example must be triggered through clicking directly on a time series. Querying a city via direct manipulation is somewhat helpful for focusing on a particular time series, but it’s not so helpful for querying a city by name and/or comparing multiple cities at once. As it turns out, plotly makes it easy to add a selectize.js powered dropdown widget for querying by name (aka indirect manipulation) by setting selectize = TRUE.13 When it comes to comparing multiple cities, we want to be able to both retain previous selections (persistent = TRUE) as well as control the highlighting color (dynamic = TRUE). This videos explains how to use these features in Figure 20.4 to compare pricing across different cities. highlight(time_series, on = &quot;plotly_click&quot;, selectize = TRUE, dynamic = TRUE, persistent = TRUE) FIGURE 20.4: Using a selectize dropdown widget to search for cities by name and comparing multiple cities through persistent selection with a dynamic highlighting color. See this video for a demo and audio explanation. By querying a few different cities in Figure 20.4, one obvious thing we can learn is that not every city has complete pricing information (e.g., South Padre Island, San Marcos, etc). To learn more about what cities are missing information as well as how that missingness is structured, Figure 20.5 links a view of the raw time series to a dot-plot of the corresponding number of missing values per city. In addition to making it easy to see how cities rank in terms of missing house prices, it also provides a way to query the corresponding time series (i.e., reveal the structure of those missing values) by brushing cities in the dot-plot. This general pattern of linking aggregated views of the data to more detailed views fits the famous and practical information visualization advice from Shneiderman (1996): “Overview first, zoom and filter, then details on demand”. # remember, `base` is a plotly object, but we can use dplyr verbs to # manipulate the input data # (`txhousing` with `city` as a grouping and querying variable) dot_plot &lt;- base %&gt;% summarise(miss = sum(is.na(median))) %&gt;% filter(miss &gt; 0) %&gt;% add_markers(x = ~miss, y = ~forcats::fct_reorder(city, miss), hoverinfo = &quot;x+y&quot;) %&gt;% layout( xaxis = list(title = &quot;Number of months missing&quot;), yaxis = list(title = &quot;&quot;) ) subplot(dot_plot, time_series, widths = c(0.2, 0.8), titleX = TRUE) %&gt;% layout(showlegend = FALSE) %&gt;% highlight(on = &quot;plotly_selected&quot;, dynamic = TRUE, selectize = TRUE) FIGURE 20.5: Linking a dot-plot of the number of missing housing prices with the raw time series. By brushing markers on the dot-plot, their raw time series is highlighted on the right hand side. How does plotly know to highlight the time series when markers in the dot-plot are selected? The answer lies in what data values are embedded in the graphical markers via highlight_key(). When ‘South Padre Island’ is selected, like in Figure 20.6, it seems as though the logic says to simply change the color of any graphical elements that match that value, but the logic behind plotly’s graphical queries is a bit more subtle and powerful. Another, more accurate, framing of the logic is to first imagine a linked database query being performed behind the scenes (as in Figure 20.6). When ‘South Padre Island’ is selected, it first filters the aggregated dot-plot data down to just that one row, then it filters down the raw time-series data down to every row with ‘South Padre Island’ as a city. The drawing logic will then call Plotly.addTrace() with the newly filtered data which adds a new graphical layer representing the selection, allowing us to have finely-tuned control over the visual encoding of the data query. FIGURE 20.6: A diagram of the graphical querying framework underlying Figure 20.5. The biggest advantage of drawing an entirely new graphical layer with the filtered data is that it becomes easy to leverage statistical trace types for producing summaries that are conditional on the query. Figure 20.7 leverages this functionality to dynamically produce probability densities of house price in response to a query events. Section 20.4.2 has more examples of leveraging statistical trace types with graphical queries. hist &lt;- base %&gt;% add_histogram(x = ~median, histnorm = &quot;probability density&quot;) subplot(time_series, hist, nrows = 2) %&gt;% layout(barmode = &quot;overlay&quot;, showlegend = FALSE) %&gt;% highlight(dynamic = TRUE, selectize = TRUE, selected = attrs_selected(opacity = 0.3)) FIGURE 20.7: Linking house prices as a function of time with their probability density estimates. Another neat consequence of drawing a completely new layer is that we can control the plotly.js attributes in that layer through the selected argument of the highlight() function. In Figure 20.7 we use it to ensure the new highlighting layer has some transparency to more easily compare the city specific distribution to the overall distribution. This section is designed to help give you a foundation for leveraging graphical queries in your own work. Hopefully by now you have a rough idea what graphical queries are, how they can be useful, and how to create them with highlight_key() and highlight(). Understanding the basic idea is one thing, but applying it effectively to new problems is another thing entirely. To help spark your imagination and demonstrate what’s possible, Section 20.4 has numerous subsections each with numerous examples of graphical queries in action. 20.2 Highlight versus filter events Section 20.1 provides an overview of plotly’s framework for highlight events, but it also supports filter events. These events trigger slightly different logic: A highlight event dims the opacity of existing marks, then adds an additional graphical layer representing the selection. A filter event completely remove existing marks and rescales axes to the remaining data.14 Figure 20.8 provides a quick visual depiction in the difference between filter and highlight events. At least currently, filter events must be fired from filter widgets from the crosstalk package, and these widgets expect an object of class SharedData as input. As it turns out, the highlight_key() function, introduced in section 20.1, creates a SharedData instance and is essentially a wrapper for crosstalk::SharedData$new(). class(highlight_key(mtcars)) #&gt; [1] &quot;SharedData&quot; &quot;R6&quot; Figure 20.8 demonstrates the main difference in logic between filter and highlight events. Notice how, in the code implementation, the ‘querying variable’ definition for filter events is part of the filter widget. That is, city is defined as the variable of interest in filter_select(), not in the creation of tx. That is (intentionally) different from the approach for highlight events, where the ‘querying variable’ is a property of the dataset behind the graphical elements. library(crosstalk) # generally speaking, use a &quot;unique&quot; key for filter, # especially when you have multiple filters! tx &lt;- highlight_key(txhousing) gg &lt;- ggplot(tx) + geom_line(aes(date, median, group = city)) filter &lt;- bscols( filter_select(&quot;id&quot;, &quot;Select a city&quot;, tx, ~city), ggplotly(gg, dynamicTicks = TRUE), widths = c(12, 12) ) tx2 &lt;- highlight_key(txhousing, ~city, &quot;Select a city&quot;) gg &lt;- ggplot(tx2) + geom_line(aes(date, median, group = city)) select &lt;- highlight( ggplotly(gg, tooltip = &quot;city&quot;), selectize = TRUE, persistent = TRUE ) bscols(filter, select) FIGURE 20.8: Comparing filter to highlight events. Filter events completely remove existing marks and rescales axes to the remaining data. When using multiple filter widgets to filter the same dataset, as done in Figure 20.9, you should avoid referencing a non-unique querying variable (i.e., key-column) in the SharedData object used to populate the filter widgets. Remember that the default behavior of highlight_key() and SharedData$new() is to use the row-index (which is unique). This ensures the intersection of multiple filtering widgets queries the correct subset of data. library(crosstalk) tx &lt;- highlight_key(txhousing) widgets &lt;- bscols( widths = c(12, 12, 12), filter_select(&quot;city&quot;, &quot;Cities&quot;, tx, ~city), filter_slider(&quot;sales&quot;, &quot;Sales&quot;, tx, ~sales), filter_checkbox(&quot;year&quot;, &quot;Years&quot;, tx, ~year, inline = TRUE) ) bscols( widths = c(4, 8), widgets, plot_ly(tx, x = ~date, y = ~median, showlegend = FALSE) %&gt;% add_lines(color = ~city, colors = &quot;black&quot;) ) FIGURE 20.9: Filtering on multiple variables. As Figure 20.10 demonstrates, filter and highlight events can work in conjunction with various htmlwidgets. In fact, since the semantics of filter are more well-defined than highlight, linking filter events across htmlwidgets via crosstalk should generally be more well-supported.15 library(leaflet) eqs &lt;- highlight_key(quakes) stations &lt;- filter_slider(&quot;station&quot;, &quot;Number of Stations&quot;, eqs, ~stations) p &lt;- plot_ly(eqs, x = ~depth, y = ~mag) %&gt;% add_markers(alpha = 0.5) %&gt;% highlight(&quot;plotly_selected&quot;) map &lt;- leaflet(eqs) %&gt;% addTiles() %&gt;% addCircles() bscols( widths = c(6, 6, 3), p, map, stations ) FIGURE 20.10: Linking plotly and leaflet through both filter and highlight events. When combining filter and highlight events, one (current) limitation to be aware of is that the highlighting variable has to be nested inside filter variable(s). For example, in Figure 20.11, we can filter by continent and highlight by country, but there is currently no way to highlight by contintent and filter by country. library(gapminder) g &lt;- highlight_key(gapminder, ~country) continent_filter &lt;- filter_select(&quot;filter&quot;, &quot;Select a country&quot;, g, ~continent) p &lt;- plot_ly(g) %&gt;% group_by(country) %&gt;% add_lines(x = ~year, y = ~lifeExp, color = ~continent) %&gt;% layout(xaxis = list(title = &quot;&quot;)) %&gt;% highlight(selected = attrs_selected(showlegend = FALSE)) bscols(continent_filter, p, widths = 12) FIGURE 20.11: Combining filtering and highlighting with non-unique querying variables 20.3 Linking animated views The section linking views without shiny details a framework for linking views through direct manipulation. This same framework can be leveraged to highlight objects as they progress through an animation, or even link objects between animations. Figure 20.12 extends Figure 18.1 by layering on linear models specific to each frame and specifying continent as a key variable. As a result, one may interactively highlight any continent they wish, and track the relationship through the animation. In the animated version of Figure 18.1, the user highlights the Americas, which makes it much easier to see that the relationship between GDP per capita and life expectancy was very strong starting in the 1950s, but progressively weakened throughout the years. g &lt;- highlight_key(gapminder, ~continent) gg &lt;- ggplot(g, aes(gdpPercap, lifeExp, color = continent, frame = year)) + geom_point(aes(size = pop, ids = country)) + geom_smooth(se = FALSE, method = &quot;lm&quot;) + scale_x_log10() highlight(ggplotly(gg), &quot;plotly_hover&quot;) FIGURE 20.12: Highlighting the relationship between GDP per capita and life expectancy in the Americas and tracking that relationship through several decades. In addition to highlighting objects within an animation, objects may also be linked between animations. Figure 20.13 links two animated views: on the left-hand side is population density by country and on the right-hand side is GDP per capita versus life expectancy. By default, all of the years are shown in black and the current year is shown in red. By pressing play to animate through the years, we can see that all three of these variables have increased (on average) fairly consistently over time. By linking the animated layers, we may condition on an interesting region of this data space to make comparisons in the overall relationship over time. For example, in Figure 20.13, countries below the 50th percentile in terms of population density are highlighted in blue, then the animation is played again to reveal a fairly interesting difference in these groups. From 1952 to 1977, countries with a low population density seem to enjoy large increases in GDP per capita and moderate increases in life expectancy, then in the early 80s, their GPD seems to decrease while the life expectancy greatly increases. In comparison, the high density countries seems to enjoy a more consistent and steady increase in both GDP and life expectancy. Of course, there are a handful of exceptions to the overall trend, such as the noticeable drop in life expectancy for a handful of countries during the nineties, which are mostly African countries feeling the affects of war. FIGURE 20.13: Comparing the evolution in the relationship between per capita GDP and life expectancy in countries with large populations (red) and small populations (blue). The gapminder data used thus far does not include surface area information, so Figure 20.13 leverages a list of countries by area on Wikipedia. The R script used to obtain and clean that list is here, but the cleaned version is directly available, plus add the areas to the gapminder data with the following code: countryByArea &lt;- read.table( &quot;https://bit.ly/2h6vscu&quot;, header = TRUE, stringsAsFactors = FALSE ) gap &lt;- gapminder %&gt;% dplyr::left_join(countryByArea, by = &quot;country&quot;) %&gt;% transform(popDen = pop / area) %&gt;% transform(country = forcats::fct_reorder(country, popDen)) The enhanced version of the gapminder data, gap, includes population density (population per square kilometer) and is used for the background layer (i.e., black points) in Figure 20.13. In order to link the animated layers (i.e., red points), we need another version of gap that marks the country variable as the link between the plots (gapKey). The new() method for the SharedData class from the crosstalk package provides one way to define this link.16 gapKey &lt;- highlight_key(gap, ~country) p1 &lt;- plot_ly(gap, y = ~country, x = ~popDen, hoverinfo = &quot;x&quot;) %&gt;% add_markers(alpha = 0.1, color = I(&quot;black&quot;)) %&gt;% add_markers(data = gapKey, frame = ~year, ids = ~country, color = I(&quot;red&quot;)) %&gt;% layout(xaxis = list(type = &quot;log&quot;)) p2 &lt;- plot_ly(gap, x = ~gdpPercap, y = ~lifeExp, size = ~popDen, text = ~country, hoverinfo = &quot;text&quot;) %&gt;% add_markers(color = I(&quot;black&quot;), alpha = 0.1) %&gt;% add_markers(data = gapKey, frame = ~year, ids = ~country, color = I(&quot;red&quot;)) %&gt;% layout(xaxis = list(type = &quot;log&quot;)) subplot(p1, p2, nrows = 1, widths = c(0.3, 0.7), titleX = TRUE) %&gt;% hide_legend() %&gt;% animation_opts(1000, redraw = FALSE) %&gt;% layout(hovermode = &quot;y&quot;, margin = list(l = 100)) %&gt;% highlight(&quot;plotly_selected&quot;, color = &quot;blue&quot;, opacityDim = 1, hoverinfo = &quot;none&quot;) 20.4 Examples 20.4.1 Querying facetted charts A facetted chart, also known as a trellis or small multiples display, is an effective way to observe how a certain relationship or visual pattern changes with a discrete variable (Richard A. Becker 1996) (Tufte 2001b). The implementation of a facetted chart partitions a data set into groups, then produces a graphical panel for each group using a fixed visual encoding (e.g. a scatterplot). When these groups are related in some way, it can be useful to consider linking the panels through graphical queries to reveal greater insight, especially when it comes to making comparisons both within and across multiple groups. Figure 20.14 is an example of making comparisons both within and across panels via graphical querying in a facetted chart. Each panel represents one year of English Premier League standings across time and each line represents a team (the querying variable). Since the x-axis represents the number of games within season and y-axis tracks cumulative points relative to the league average, lines with a positive slope represent above average performance and a negative slope represents below average performance. This design makes it easy to query a good (or bad) team for a particular year (via direct manipulation) to see who the team is as well as how they’ve compared to the competition in other years. In addition, the dynamic and persistent color brush allows us to query other teams to compare both within and across years. This example is shipped as a demo with the plotly package and uses data from the engsoccerdata package (Curley 2016). # By entering this demo in your R console it will print out the actual source code necessary to recreate the graphic # Also, `demo(package = &quot;plotly&quot;)` will list of all demos shipped with plotly demo(&quot;crosstalk-highlight-epl-2&quot;, package = &quot;plotly&quot;) FIGURE 20.14: Graphical querying in a facetted display of English Premier League standings over time. The combination of direct and indirect manipulation with the dynamic color brush makes it easy to make comparisons between good and/or bad teams relative to their known rivals. The demo above requires some fairly advanced data pre-processing, so to learn how to implement graphical queries in trellis displays, let’s work with more minimal examples. Figure 20.15 gives us yet another look at the txhousing dataset. This time we focus on just four cities and give each city it’s own panel in the trellis display by leveraging facet_wrap() from ggplot2. Within each panel, we’ll wrap the house price time series by year by putting the month on the x-axis and grouping by year. Then, to link these panels, we can ulitize year as a querying variable. As a result, not only do we have the ability to analyze annual trends within city, but we can also query specific years to compare unusual or interesting years both within and across cities. library(dplyr) txsmall &lt;- txhousing %&gt;% select(city, year, month, median) %&gt;% filter(city %in% c(&quot;Galveston&quot;, &quot;Midland&quot;, &quot;Odessa&quot;, &quot;South Padre Island&quot;)) txsmall %&gt;% highlight_key(~year) %&gt;% { ggplot(., aes(month, median, group = year)) + geom_line() + facet_wrap(~city, ncol = 2) } %&gt;% ggplotly(tooltip = &quot;year&quot;) FIGURE 20.15: Monthly median house prices in four Texan cities. Querying by year allows one to compare unusual or interesting years both within and across cities. Figure 20.16 displays the same information as 20.15, but shows a way to implement a linked trellis display via plot_ly() instead of ggplotly(). This approach leverages dplyr::do() to create plotly object for each city/panel, then routes that list of plots into subplot(). One nuance here is that the querying variable has to be defined within the do() statement, but everytime highlight_key() is called, it creates a crosstalk::SharedData object belonging to a new unique group, so to link these panels together the group must be set to a constant value (here we’ve set group = \"txhousing-trellis\"). txsmall %&gt;% group_by(city) %&gt;% do( p = highlight_key(., ~year, group = &quot;txhousing-trellis&quot;) %&gt;% plot_ly(showlegend = FALSE) %&gt;% group_by(year) %&gt;% add_lines( x = ~month, y = ~median, text = ~year, hoverinfo = &quot;text&quot; ) %&gt;% add_annotations( text = ~unique(city), x = 0.5, y = 1, xref = &quot;paper&quot;, yref = &quot;paper&quot;, xanchor = &quot;center&quot;, yanchor = &quot;bottom&quot;, showarrow = FALSE ) ) %&gt;% subplot(nrows = 2, margin = 0.05, shareY = TRUE, shareX = TRUE, titleY = FALSE) FIGURE 20.16: Using plot_ly() instead of ggplotly() to implement a linked trellis display. 20.4.2 Statistical queries 20.4.2.1 Statistical queries with plot_ly() Figure 20.7 introduced the concept of leveraging statistical trace types inside the graphical querying framework. This section gives some more examples of leveraging these trace types to dynamically produce statistical summaries of graphical queries. But first, to help understand what makes a trace “statistical”, consider the difference between add_bars() and add_histogram() (described in detail in Section 6). The important difference here is that add_bars() requires the bar heights to be pre-specified, whereas plotly.js does the relevant computations in add_histogram(). More generally, with a statistical trace, you provide a collection of “raw” values and plotly.js performs the statistical summaries necessary to render the graphic. As Figure 20.24 shows, sometimes you’ll want to fix certain parameters of the summary (e.g., number of bins in a histogram) to ensure the selection layer is comparable to original layer. Figure 20.17 demonstrates routing of a scatterplot brushing event to two different statistical trace types: add_boxplot() and add_histogram(). Here we’ve selected all cars with 4 cylinders to show that cylinders appears to have a significant impact on miles per gallon for pickups and sport utility vehicles, but the interactive graphic allows us to query any subset of cars. Often times, with scatterplot brushing, it’s desirable to have the row index inform the SQL query (i.e., have a 1-to-1 mapping between a row of data and the marker encoding that row). This happens to be the default behavior of highlight_key() – if no data variable is specified, then it automatically uses the row index as the querying variable. demo(&quot;crosstalk-highlight-binned-target-a&quot;, package = &quot;plotly&quot;) FIGURE 20.17: Linking a (jittered) dotplot of engine displacement by number of cylinders with boxplots of miles per gallon split by class and a bar chart of Dynamic 2-way ANOVA. When using a statistical trace type with graphical queries, it’s often desirable to set the querying variable as the row index. That’s because, with a statistical trace, numerous data values are attached to each graphical mark; and in that case, it’s most intuitive if each value queries just one observation. Figure 20.18 gives a simple example of linking a (dynamic) bar chart with a scatterplot in this way to allow us to query interesting regions of the data space defined by engine displacement (disp), miles per gallon highway (hwy), and the class of car (class). Notice how selections can derive from either view, and since we’ve specified \"plotly_selected\" as the on event, either rectangular or lasso selections can be used to trigger the query. d &lt;- highlight_key(mpg) base &lt;- plot_ly(d, color = I(&quot;black&quot;), showlegend = FALSE) subplot( add_histogram(base, x = ~class), add_markers(base, x = ~displ, y = ~hwy) ) %&gt;% # Selections are actually additional traces, and, by default, # plotly.js will try to dodge bars placed under the same category layout(barmode = &quot;overlay&quot;, dragmode = &quot;lasso&quot;) %&gt;% highlight(&quot;plotly_selected&quot;) FIGURE 20.18: Linking a bar chart with a scatterplot to query interesting regions of the data space defined by engine displacement (disp), miles per gallon highway (hwy), and the class of car (class). Notice how, by using add_histogram(), the number of cars within each class is dynamically computed by plotly.js. Figure 20.19 adds two more statistical trace types to Figure 20.18 to further explore how miles per gallon highway is related to fuel type (fl) and front/rear/4 wheel drive (drv). In particular, one can effectively condition on these discrete variables to see how the other distributions respond by brushing and dragging over markers. For example, in Figure 20.19, front-wheel drive cars are highlighted in red, then 4-wheel drive cars in blue, and as a result, we can see that the main effect of going from 4 to front wheel-drive is are also large interaction effect sizes with regular and diesel fuel types. d &lt;- highlight_key(mpg) base &lt;- plot_ly(d, color = I(&quot;black&quot;), showlegend = FALSE) subplot( add_markers(base, x = ~displ, y = ~hwy), add_boxplot(base, x = ~fl, y = ~hwy) %&gt;% add_markers(x = ~fl, y = ~hwy, alpha = 0.1), add_trace(base, x = ~drv, y = ~hwy, type = &quot;violin&quot;) %&gt;% add_markers(x = ~drv, y = ~hwy, alpha = 0.1), shareY = TRUE ) %&gt;% subplot(add_histogram(base, x = ~class), nrows = 2) %&gt;% # Selections are actually additional traces, and, by default, # plotly.js will try to dodge bars placed under the same category layout(barmode = &quot;overlay&quot;) %&gt;% highlight(&quot;plotly_selected&quot;, dynamic = TRUE) FIGURE 20.19: Using statistical queries to perform a 2-way ANOVA on the mpg dataset. Cars with front-wheel drive are highlighted in red and 4-wheel drive highlighted in blue. The dynamically rendered boxplots by fuel type indicate significant interaction effects. 20.4.3 Statistical queries with ggplotly() Compared to plot_ly(), statistical queries (client-side) with ggplotly() are fundamentally limited. That’s because, the statistical R functions that ggplot2 relies on to generate the graphical layers can’t necessarily be recomputed with different input data in your web browser. That being said, this is really only an issue when attempting to target a ggplot2 layer with a non-identity statistic (e.g., geom_smooth(), stat_summary(), etc). In that case, one should consider linking views server-side, as covered in section 21. As Figure 20.20 demonstrates, you can still have a ggplot2 layer with a non-identity statistic serve as the source of a selection. In that case, ggplotly() will automatically attach all the input values of the querying variable into the creation of the relevant graphical object (e.g. the fitted line). That is why, in the example below, when a fitted line is hovered upon, all the points belonging to that particular group are highlighted, even when the querying variable is the row index. m &lt;- highlight_key(mpg) p &lt;- ggplot(m, aes(displ, hwy, colour = class)) + geom_point() + geom_smooth(se = FALSE, method = &quot;lm&quot;) ggplotly(p) %&gt;% highlight(&quot;plotly_hover&quot;) FIGURE 20.20: Engine displacement versus highway miles per gallon by class of car. The linear model for each class, as well as the individual observations, can be selected by hovering over the line of fitted values. An individual observation can also be selected by hovering over the relevant point. Figure 20.20 demonstrates highlighting in a single view when the querying variable is the row index, but the linking could also be done by matching the querying variable with the ggplot2 group of interest, as is done in Figure 20.21. This way, when a user highlights an individual point, it highlights the entire group instead of just that point. m &lt;- highlight_key(mpg, ~class) p1 &lt;- ggplot(m, aes(displ, fill = class)) + geom_density() p2 &lt;- ggplot(m, aes(displ, hwy, fill = class)) + geom_point() subplot(p1, p2) %&gt;% hide_legend() %&gt;% highlight(&quot;plotly_hover&quot;) FIGURE 20.21: Clicking on a density estimate to highlight all the raw observations that went into that estimate. In summary, we’ve learned numerous things about statistical queries: A statistical trace (e.g., add_histogram(), add_boxplot(), etc) can be used as both the source and target of a graphical query. When a statistical trace is the target of a graphical query, it’s often desirable to have the row index assigned as the querying variable. A ggplot2 layer can be used as the source of a graphical query, but when it is the target, non-trivial statistical functions can not be recomputed client-side. In that case, one should consider linking views server side, as covered in section 21. 20.4.4 Geo-spatial queries Section 5 covers several different approaches17 for rendering geo-spatial information, and each approach supports graphical querying. One clever approach is to render a 3D globe as a surface, then layer on geo-spatial data on top of that globe with a scatter3d trace. Not only is 3D a nice way to visualize geospatial data that has altitude (in addition to latitude and longitude), but it also grants the ability to interpolate color along a path. Figure 20.22 renders tropical storms paths on a 3D globe and uses color to encode the altitude of the storm at that point. Below the 3D view is a 2D view of altitude versus distance traveled. These views are linked by a graphical query where the querying variable is the storm ID. demo(&quot;sf-plotly-3D-globe&quot;, package = &quot;plotly&quot;) FIGURE 20.22: Linking a 3D globe with tropical storm paths to a 2D view of the storm altitude versus distance traveled. A more widely used approach to geo-spatial data visualization is to render lat/lon data on a basemap layer that updates in response to zoom events. The plot_mapbox() function from plotly does this via integration with mapbox. Figure 20.23 uses plot_mapbox() highlighting earthquakes west of Fiji to compare the relative frequency of their magnitude and number of reporting stations (to the overall relative frequency). eqs &lt;- highlight_key(quakes) # you need a mapbox API key to use plot_mapbox() # https://www.mapbox.com/signup/?route-to=https://www.mapbox.com/studio/account/tokens/ map &lt;- plot_mapbox(eqs, x = ~long, y = ~lat) %&gt;% add_markers(color = ~depth) %&gt;% layout( mapbox = list( zoom = 2, center = list(lon = ~mean(long), lat = ~mean(lat)) ) ) %&gt;% highlight(&quot;plotly_selected&quot;) # shared properties of the two histograms hist_base &lt;- plot_ly(eqs, color = I(&quot;black&quot;), histnorm = &quot;probability density&quot;) %&gt;% layout(barmode = &quot;overlay&quot;, showlegend = FALSE) %&gt;% highlight(selected = attrs_selected(opacity = 0.5)) histograms &lt;- subplot( add_histogram(hist_base, x = ~mag), add_histogram(hist_base, x = ~stations), nrows = 2, titleX = TRUE ) crosstalk::bscols(histograms, map) FIGURE 20.23: Querying earthquakes by location and displaying their a histogram of their magnitude and number of stations. Every 2D mapping approach in plotly (e.g., plot_mapbox(), plot_ly(), geom_sf()) has a special understanding of the simple features data structure provided by the sf package. Sievert (2018b) and Sievert (2018c) goes more in depth about simple features support in plotly and provides more examples of graphical queries and animation with simple features, but Figure 20.24 demonstrates a clever ‘trick’ to get bi-directional brushing between polygon centroids and a histogram showing a numerical summary of the polygons. The main idea is to leverage the st_centroid() function from sf to get the polygons centroids, then link those points to the histogram via highlight_key(). library(sf) nc &lt;- st_read(system.file(&quot;shape/nc.shp&quot;, package = &quot;sf&quot;), quiet = TRUE) nc_query &lt;- highlight_key(nc, group = &quot;sf-rocks&quot;) nc_centroid &lt;- highlight_key(st_centroid(nc), group = &quot;sf-rocks&quot;) map &lt;- plot_mapbox(color = I(&quot;black&quot;)) %&gt;% add_sf(data = nc) %&gt;% add_sf(data = nc_centroid) %&gt;% layout(showlegend = FALSE) %&gt;% highlight(&quot;plotly_selected&quot;, dynamic = TRUE) hist &lt;- plot_ly(color = I(&quot;black&quot;)) %&gt;% add_histogram( data = nc_query, x = ~AREA, xbins = list(start = 0, end = 0.3, size = 0.01) ) %&gt;% layout(barmode = &quot;overlay&quot;) %&gt;% highlight(&quot;plotly_selected&quot;) crosstalk::bscols(widths = 12, map, hist) FIGURE 20.24: Graphically querying North Carolina by location and area 20.4.5 Linking with other htmlwidgets The plotly package is able to share graphical queries with a limited set of other R packages that build upon the htmlwidgets standard. At the moment, graphical queries work best with leaflet and DT. Figure 20.25 links plotly with DT, and since the data set linked bewteen the two is an sf data frame, each row of the table is linked to a polygon on the map through the row index of the same dataset. demo(&quot;sf-dt&quot;, package = &quot;plotly&quot;) FIGURE 20.25: Linking a plot_ly()-based map with a datatable() from the DT package. As already shown in section 20.2, plotly can share graphical queries with leaflet. Some of the more advanced features (e.g., persistent selection with dynamic color brush) are not yet officially supported, but you can still leverage these experimental features by installing the experimental versions of leaflet referenced in the code below. For example, in Figure 20.26, persistent selection with dynamic colors allows one to first highlight earthquakes with a magnitude of 5 or higher in red, then earthquakes with a magnitude of 4.5 or lower, and the corresponding earthquakes are highlighted in the leaflet map. This reveals an interesting relationship in magnitude and geographic location, and leaflet provides the ability to zoom and pan on the map to investigate regions that have a high density of quakes. # requires an experimental version of leaflet # devtools::install_github(&quot;rstudio/leaflet#346&quot;) library(leaflet) qquery &lt;- highlight_key(quakes) p &lt;- plot_ly(qquery, x = ~depth, y = ~mag) %&gt;% add_markers(alpha = 0.5) %&gt;% highlight(&quot;plotly_selected&quot;, dynamic = TRUE) map &lt;- leaflet(qquery) %&gt;% addTiles() %&gt;% addCircles() # persistent selection can be specified via options() withr::with_options( list(persistent = TRUE), crosstalk::bscols(widths = c(6, 6), p, map) ) FIGURE 20.26: Linking views between plotly and leaflet to explore the relation between magnitude and geographic location of earthquakes around Fiji. Figure 20.27 uses another experimental feature of querying leaflet polygons in response to direct manipulation of a plotly graph. # requires an experimental version of leaflet # devtools::install_github(&quot;rstudio/leaflet#391&quot;) library(leaflet) library(sf) nc &lt;- system.file(&quot;shape/nc.shp&quot;, package = &quot;sf&quot;) %&gt;% st_read() %&gt;% st_transform(4326) %&gt;% highlight_key() map &lt;- leaflet(nc) %&gt;% addTiles() %&gt;% addPolygons( opacity = 1, color = &#39;white&#39;, weight = .25, fillOpacity = .5, fillColor = &#39;blue&#39;, smoothFactor = 0 ) p &lt;- plot_ly(nc) %&gt;% add_markers(x = ~BIR74, y = ~SID79) %&gt;% layout(dragmode = &quot;lasso&quot;) %&gt;% highlight(&quot;plotly_selected&quot;) crosstalk::bscols(map, p) FIGURE 20.27: Querying polygons on a leaflet map in response to direct manipulation of a plotly graph. 20.4.6 Generalized pairs plots Section 4.1.2 introduced the generalized pairs plot made via GGally::ggpairs() which, like ggplot(), partially supports graphical queries. The brushing in Figure 20.28 demonstrates how the scatterplots can respond to a graphical queries (allowing us to see how these relationships behave in specific subsections of the data space), but for the same reasons outlined in 20.4.3, the statistical summaries (e.g., the density plots and correlations) don’t respond to the graphical query. highlight_key(iris) %&gt;% GGally::ggpairs(aes(color = Species), columns = 1:4) %&gt;% ggplotly() %&gt;% highlight(&quot;plotly_selected&quot;) FIGURE 20.28: Brushing a scatterplot matrix via the ggpairs() function in the GGally package. A video demonstrating the graphical queries can be viewed here 20.4.7 Querying diagnostic plots In addition to the ggpairs() function for generalized pairs plots, the GGally packages also has a ggnostic() function which generates a matrix of diagnostic plots from a model object using ggplot2. Each column of this matrix represents a different explanatory variable and each row represents a different diagnostic measure. Figure 20.29 shows the default display for a linear model, which includes residuals (resid), estimates of residual standard deviation when a particular observation is excluded (sigma), diagonals from the projection matrix (hat), and cooks distance (cooksd). library(dplyr) library(GGally) mtcars %&gt;% # for better tick labels mutate(am = recode(am, `0` = &quot;automatic&quot;, `1` = &quot;manual&quot;)) %&gt;% lm(mpg ~ wt + qsec + am, data = .) %&gt;% ggnostic(mapping = aes(color = am)) %&gt;% ggplotly() FIGURE 20.29: Graphical queries applied to multiple diagnostic plots of a linear model. The ggplotly() function has a special method for ggnostic() that adds graphical queries automatically with support for both individual observations (e.g. points) as well as meaningful groups (e.g., automatic vs manual). Injecting interactivity into ggnostic() via ggplotly() enhances the diagnostic plot in at least two ways. Coloring by a factor variable in the model allows us to highlight that region of the design matrix by selecting a relevant statistical summary, which can help avoid overplotting when dealing with numerous factor levels. For example, in Figure 20.29, the user first highlights diagnostics for cars with manual transmission (in blue), then cars with automatic transmission (in red). Perhaps more widely useful is the ability to highlight individual observations since most of these diagnostics are designed to identify highly influential or unusual observations. In Figure 20.29, there is one observation with a noticeably high value of cooksd, which suggests the observation has a large influence on the fitted model. Clicking on that point highlights its corresponding diagnostic measures, plotted against each explanatory variable. Doing so makes it obvious that this observation is influential since it has a unusually high response/residual in a fairly sparse region of the design space (i.e., it has a pretty high value of wt) and removing it would significantly reduce the estimated standard deviation (sigma). By comparison, the other two observations with similar values of wt have a response value very close to the overall mean, so even though their value of hat is high, their value of sigma is low. 20.4.7.1 Subset queries via list-columns All the graphical querying examples thus far use highlight_key() to attach values from atomic vector of a data frame to graphical marker(s), but what non-atomic vectors (i.e., list-columns)? When it comes to emitting events, there is no real difference – plotly will “inform the world” of a set of selection values, which is the union of all data values in the graphical query. However, as Figure 20.30 demonstrates, when plotly receives a list-column query, it will highlight graphical markers with data value(s) that are a subset of the selected values. For example, when the point [3, 3] is queried, plotly will highlight all markers that represent a subset of {A, B, C}, which is why both [1, 1] (representing the set {A}) and (2, 2) (representing the set {A, B}) are highlighted. d &lt;- tibble::tibble( x = 1:4, y = 1:4, key = lapply(1:4, function(x) LETTERS[seq_len(x)]), txt = sapply(key, function(x) sprintf(&quot;{%s}&quot;, paste(x, collapse = &quot;, &quot;))) ) highlight_key(d, ~key) %&gt;% plot_ly(x = ~x, y = ~y, text = ~txt, hoverinfo = &quot;text&quot;) %&gt;% highlight(&quot;plotly_selected&quot;) %&gt;% layout(dragmode = &quot;lasso&quot;) FIGURE 20.30: A simple example of subset queries via a list-column One compelling use case for subset queries is dendograms. In fact, plotly provides a plot_dendro() function for making dendrograms with support for subset queries. Figure 20.31 gives an example of brushing a branch of a dendrogram to query leafs that are similar in some sense. Any dendrogram object can be provided to plot_dendro(), but this particular example visualizes the similarity of US states in terms of their arrest statistics via a hierarchical clustering model on the USArrests dataset. hc &lt;- hclust(dist(USArrests), &quot;ave&quot;) dend1 &lt;- as.dendrogram(hc) plot_dendro(dend1, height = 600) %&gt;% hide_legend() %&gt;% highlight(&quot;plotly_selected&quot;, persistent = TRUE, dynamic = TRUE) FIGURE 20.31: Leveraging hierarchical selection and persistent brushing to paint branches of a dendrogram. Figure 20.32 links the dendrogram from Figure 20.31 to a map of the US and a grand tour of the arrest statistics to better understand and diagnose a hierarchical clustering methodology. By highlighting branches of the dendrogram, we can effectively choose a partitioning of the states into similar groups, and see how that model choice projects to the data space18 through a grand tour. The grand tour is a special kind of animation that interpolates between random 2D projections of numeric data allowing the viewer to perceive the shape of a high-dimensional point cloud (Asimov 1985). Note how the grouping portrayed in Figure 20.32 does a fairly good job of staying separated in the grand tour. demo(&quot;animation-tour-USArrests&quot;, package = &quot;plotly&quot;) FIGURE 20.32: Linking a dendrogram to a grand tour and map of the USArrests data to visualize a classification in 5 dimensions. 20.5 Limitations Linking of data views, as defined in Section ??, has a much larger scope than the graphical querying framework covered in this chapter. For serious statistical analysis, one often needs to link views in a way that can not be easily compiled down to client-side web technologies. For these use cases, the R package shiny makes it very easy to build on concepts we’ve already covered to build more powerful client-server applications entirely in R, without having to learn any HTML, CSS, or JavaScript. The next chapter 21 gives a brief introduction to shiny, then dives right into concepts related to linking plotly graphics to other arbitrary views. References "],
["linking-server-side.html", "21 Server-side linking with shiny 21.1 Embedding plotly in shiny 21.2 Leveraging plotly input events 21.3 Improving performance 21.4 Advanced applications 21.5 Discussion", " 21 Server-side linking with shiny Section 20.1 covers an approach to linking views client-side with graphical database queries, but not every linked data view can be reasonably framed as a database query. If you need more control, you have at least two more options: add custom JavaScript (covered in section 26) and/or link views server-side via a web application. Some concepts useful for the former approach are covered in 26, but this chapter is all about the latter approach. There are several different frameworks for creating web applications via R, but we’ll focus our attention on linking plotly graphs with shiny – an R package for creating reactive web applications entirely in R. Shiny’s reactive programming model allows R programmers to build upon their existing R knowledge and create data-driven web applications without any prior web programming experience. Shiny itself is largely agnostic to the engine used to render data views (that is, you can incorporate any sort of R output), but shiny itself also adds some special support for interacting with static R graphics and images (Chang 2017). When linking graphics in a web application, there are tradeoffs to consider when using static R plots over web-based graphics. As it turns out, those tradeoffs complement nicely with the relative strengths and weaknesses of linking views with plotly, making their combination a powerful toolkit for linking views on the web from R. Shiny itself provides a way to access events with static graphics made with any of the following R packages: graphics, ggplot2, and lattice. These packages are very mature, fully-featured, well-tested, and support a incredibly wide range of graphics, but since they must be regenerated on the server, they are fundamentally limited from an interactive graphics perspective. Comparatively speaking, plotly does not have the same range and history, but it does provide more options and control over interactivity. More specifically, because plotly is inherently web-based, it allows for more control over how the graphics update in response to user input (e.g., change the color of a few points instead of redrawing the entire image). This idea is explored in more depth in section 21.3.1. This chapter teaches you how to use plotly graphs inside shiny, how to get those graphics communicating with other types of data views, and how to do it all efficiently. Section 21.1 provides an introduction to shiny it’s reactive programming model, Section 21.2 shows how to leverage plotly inputs in shiny to coordinate multiple views, Section 21.3.1 shows how to respond to input changes efficiently, and Section 21.4 demonstrates some advanced applications. 21.1 Embedding plotly in shiny Before linking views with plotly inside shiny, let’s first talk about how to embed plotly inside a basic shiny app! Through a couple basic examples, you’ll learn the basic components of a shiny and get a feel for shiny’s reactive programming model, as well as pointers to more learning materials. 21.1.1 Your first shiny app The most common plotly+shiny pattern uses a shiny input to control a plotly output. Figure 21.1 gives a simple example of using shiny’s selectizeInput() function to create a dropdown that controls a plotly graph. This example, as well as every other shiny app, has two main parts: The user interface, ui, defines how inputs and output widgets are displayed on the page. The fluidPage() function offers a nice and quick way get a grid-based responsive layout19, but it’s also worth noting the UI is completely customizable20, and packages such as shinydashboard make it easy to leverage more sophisticated layout frameworks (Chang and Borges Ribeiro 2018). The server function, server, defines a mapping from input values to output widgets. More specifically, the shiny server is an R function() between input values on the client and outputs generated on the web server. Every input widget, including the selectizeInput() in Figure 21.1, is tied to a input value that can be accesssed on the server inside a reactive expression. Shiny’s reactive expressions build a dependency graph between outputs (aka, reactive endpoints) and inputs (aka, reactive sources). The true power of reactive expressions lies in their ability to chain together and cache computations, but let’s first focus on generating outputs. In order to generate an output, you have to choose a suitable function for rendering the result of a reactive expression. Figure 21.1 uses the renderPlotly() function to render a reactive expression that generates a plotly graph. This expression depends in the input value input$cities (i.e., the input value tied to the input widget with an inputId of \"cities\") and stores the output as output$p. This instructs shiny to insert the reactive graph into the plotlyOutput(outputId = \"p\") container defined in the user interface. library(shiny) library(plotly) ui &lt;- fluidPage( selectizeInput( inputId = &quot;cities&quot;, label = &quot;Select a city&quot;, choices = unique(txhousing$city), selected = &quot;Abilene&quot;, multiple = TRUE ), plotlyOutput(outputId = &quot;p&quot;) ) server &lt;- function(input, output, ...) { output$p &lt;- renderPlotly({ plot_ly(txhousing, x = ~date, y = ~median) %&gt;% filter(city %in% input$cities) %&gt;% group_by(city) %&gt;% add_lines() }) } shinyApp(ui, server) FIGURE 21.1: Using a shiny input widget to control which time series are shown on a plotly graph. If, instead of a plotly graph, a reactive expression generates a static R graphic, simply use renderPlot() (instead of renderPlotly()) to render it and plotOutput() (instead of plotlyOutput()) to position it. Other shiny output widgets also use this naming convention: renderDataTable()/datatableOutput(), renderPrint()/verbatimTextOutput(), renderText()/textOutput(), renderImage()/imageOutput(), etc. Packages that are built on the htmlwidgets standard (e.g. plotly and leaflet) are, in some sense, also shiny output widgets that are encouraged to follow this same naming convention (e.g. renderPlotly()/plotlyOutput() and renderLeaflet()/leafletOutput()). Shiny also comes pre-packaged with a handful of other useful input widgets. Although many shiny apps use them straight “out-of-the-box”, input widgets can easily be stylized with CSS and/or SASS, and even custom input widgets can be integrated (Mastny 2018, @shiny-custom-inputs). selectInput()/selectizeInput() for dropdown menus. numericInput() for a single number. sliderInput() for a numeric range. textInput() for a character string. dateInput() for a single date. dateRangeInput() for a range of dates. fileInput() for uploading files. checkboxInput()/checkboxGroupInput()/radioButtons() for choosing a list of options. Going forward our focus is to link multiple graphs in shiny through direct manipulation, so we focus less on using these input widgets, and more on using plotly and static R graphics as inputs to other output widgets. Section 21.2 provides an introduction to this idea, but before we learn how to access these input events, you may want to know a bit more about rendering plotly inside shiny. 21.1.2 Hiding and redrawing on resize The renderPlotly() function renders anything that the plotly_build() function understands, including plot_ly(), ggplotly(), and ggplot2 objects.21 It also renders NULL as an empty HTML div, which is handy for certain cases where it doesn’t make sense to render a graph. Figure 21.2 leverages these features to render an empty div while selectizeInput()’s placeholder is shown, but then render a plotly graph via ggplotly() once cities have been selected. Figure 21.2 also shows how to make the plotly output depend on the size of the container that holds the plotly graph. By default, when a browser is resized, the graph size is changed purely client-side, but this reactive expression will re-execute when the browser window is resized. Due to technical reasons this can improve ggplotly() resizing behavior22, but should be used with caution when handling large data and long render times. library(shiny) library(plotly) cities &lt;- unique(txhousing$city) ui &lt;- fluidPage( selectizeInput( inputId = &quot;cities&quot;, label = NULL, # placeholder prompt is triggered when first choice is an empty string choices = c(&quot;Please choose a city&quot; = &quot;&quot;, cities), multiple = TRUE ), plotlyOutput(outputId = &quot;p&quot;) ) server &lt;- function(input, output, session, ...) { output$p &lt;- renderPlotly({ req(input$cities) if (identical(input$cities, &quot;&quot;)) return(NULL) p &lt;- ggplot(data = filter(txhousing, city %in% input$cities)) + geom_line(aes(date, median, group = city)) ggplotly(p, height = session$clientData$output_p_height, width = session$clientData$output_p_width) }) } shinyApp(ui, server) FIGURE 21.2: Rendering a plotly graph in shiny if and only if the selectizeInput()’s dropdown is non-empty. When the graph is present, and the window is resized, then the reactive expression is re-evaluated. When a reactive expression inside renderPlotly() is re-executes, it triggers a full redraw of the plotly graph on the client. Generally speaking, this makes your shiny app logic easy to reason about, but it’s not always performant enough. For example, say you have a scatterplot with 10s of thousands of points, and you just want to add a fitted line to those points (in respond to input event)? Instead of redrawing the whole plot from scratch, it can be way more performant to partially update specific components of the visual. Section 21.3.1 covers this idea through a handful of examples. 21.2 Leveraging plotly input events Section 21.1 covered how to render shiny output widgets (e.g., plotlyOutput()) that depend on a input widget, but what about having an output act like an input to another output? For example, say we’d like to dynamically generate a bar chart (i.e., an output) based on a point clicked on a scatter-plot (i.e., an input event tied to an output widget). In addition to shiny’s static graph and image rendering functions (e.g., plotOutput()/imageOutput()), there are a handful of other R packages that expose user interaction with “output” widget(s) as input value(s). Cheng (2018c) and Xie (2018) describe the interface for the leaflet and DT packages. This section outlines the interface for plotlyOutput(). This sort of functionality plays a vital role in linking of views through direct manipulation, similar to what we’ve already seen in section 20.1, but having access to plotly events on a shiny server allows for much more flexibility than linking views purely client-side. The event_data() function is the most straight-forward way to access a plotly input events in shiny. Although event_data() is function, it references and returns a shiny input value, so event_data() needs to be used inside a reactive context. Most of these available events are data-specific traces (e.g., \"plotly_hover\", \"plotly_click\", \"plotly_selected\", etc), but there are also some that are layout-specific (e.g., \"plotly_relayout\"). Most plotly.js events23 are accessible through this interface – for a complete list see the help(event_data) documentation page. Numerous Figures in the following sections show how to access common plotly events in shiny and do something with the result. When using these events to inform another view of the data, it’s often necessary to know what portion of data was queried in the event (i.e., the x/y positions alone may not be enough to uniquely identify the information of interest). For this reason, it’s often a good idea to supply a key (or customdata) attribute, so that you can map the event data back to the original data. The key attribute is only supported in shiny, but customdata is officially supported by plotly.js, and thus can also be used to attach meta-information to event – see section 26 for more details. 21.2.1 Dragging events There are currently four different modes for mouse click+drag behavior (i.e., dragmode) in plotly.js: zoom, pan, rectangular selection, and lasso selection. This mode may be changed interactively via the modebar that appears above a plotly graph, but the default mode can also be set from the command-line. The default dragmode in Figure 21.3 is set to 'select', so that dragging draws a rectangular box which highlights markers. When in this mode, or in the lasso selection mode, information about the drag event can be accessed in four different ways: \"plotly_selecting\", \"plotly_selected\", \"plotly_brushing\", and \"plotly_brushed\". Both the \"plotly_selecting\" and \"plotly_selected\" events emit information about trace(s) appearing within the interior of the brush – the only difference is that \"plotly_selecting\" fires repeatedly during drag events, whereas \"plotly_selected\" fires after drag events (i.e., after the mouse has been released). The semantics behind \"plotly_brushing\" and \"plotly_brushed\" are similar, but these emit the x/y limits of the selection brush. As for the other two dragging modes (zoom and pan), since they modify the range of the x/y axes, information about these events can be accessed through \"plotly_relayout\". Sections 21.3.1 and 21.4 both have advanced applications of these dragging events. library(shiny) ui &lt;- fluidPage( radioButtons(&quot;plotType&quot;, &quot;Plot Type:&quot;, choices = c(&quot;ggplotly&quot;, &quot;plotly&quot;)), plotlyOutput(&quot;plot&quot;), verbatimTextOutput(&quot;selecting&quot;), verbatimTextOutput(&quot;brushing&quot;), verbatimTextOutput(&quot;relayout&quot;) ) server &lt;- function(input, output, session) { nms &lt;- row.names(mtcars) output$plot &lt;- renderPlotly({ p &lt;- if (identical(input$plotType, &quot;ggplotly&quot;)) { ggplotly(ggplot(mtcars, aes(x = mpg, y = wt, key = nms)) + geom_point()) } else { plot_ly(mtcars, x = ~mpg, y = ~wt, key = nms) } layout(p, dragmode = &quot;select&quot;) }) output$selecting &lt;- renderPrint({ d &lt;- event_data(&quot;plotly_selecting&quot;) if (is.null(d)) &quot;Selected data appears here&quot; else d }) output$brushing &lt;- renderPrint({ d &lt;- event_data(&quot;plotly_brushing&quot;) if (is.null(d)) &quot;Selection brush limits appear here&quot; else d }) output$relayout &lt;- renderPrint({ d &lt;- event_data(&quot;plotly_relayout&quot;) if (is.null(d)) &quot;Zoom and pan info appears here&quot; else d }) } shinyApp(ui, server) FIGURE 21.3: Accessing event data from click and drag events. 21.2.2 3D events Drag selection events (i.e., \"plotly_selecting\") are currently only available for 2D charts, but other common events are generally supported for any type of graph, including 3D charts. Figure 21.4 accesses various events in 3D including: \"plotly_hover\", \"plotly_click\", \"plotly_legendclick\", \"plotly_legenddoubleclick\", and \"plotly_relayout\". The data emitted via \"plotly_hover\" and \"plotly_click\" is structured similarly to data emitted from \"plotly_selecting\"/\"plotly_selected\". Figure 21.4 also demonstrates how one can react to particular components of a conflated event like \"plotly_relayout\". That is, \"plotly_relayout\" will fire whenever any part of the layout has changed, so if we want to trigger behavior if and only if there are changes to the camera eye, one could first check if the information emitted contains information about the camera eye. library(shiny) ui &lt;- fluidPage( plotlyOutput(&quot;plot&quot;), verbatimTextOutput(&quot;hover&quot;), verbatimTextOutput(&quot;click&quot;), verbatimTextOutput(&quot;legendclick&quot;), verbatimTextOutput(&quot;legend2click&quot;), verbatimTextOutput(&quot;relayout&quot;) ) server &lt;- function(input, output, session) { output$plot &lt;- renderPlotly({ plot_ly(mtcars, x = ~wt, y = ~mpg, z = ~disp, color = ~factor(cyl)) }) output$hover &lt;- renderPrint({ d &lt;- event_data(&quot;plotly_hover&quot;) if (is.null(d)) &quot;Hover events appear here&quot; else d }) output$click &lt;- renderPrint({ d &lt;- event_data(&quot;plotly_click&quot;) if (is.null(d)) &quot;Click events appear here&quot; else d }) output$legendclick &lt;- renderPrint({ d &lt;- event_data(&quot;plotly_legendclick&quot;)$name if (is.null(d)) &quot;Legend click&quot; else d }) output$legend2click &lt;- renderPrint({ d &lt;- event_data(&quot;plotly_legenddoubleclick&quot;)$name if (is.null(d)) &quot;Legend double-click&quot; else d }) output$relayout &lt;- renderPrint({ d &lt;- event_data(&quot;plotly_relayout&quot;)$scene.camera$eye if (is.null(d)) &quot;Camera eye info&quot; else d }) } shinyApp(ui, server) FIGURE 21.4: Accessing 3D events. 21.2.3 Edit events A little known fact about plotly is that you can directly manipulate annotations, title, shapes (e.g., circle, lines, rectangles), legends, and more by simply adding config(p, editable = TRUE) to a plot p. Moreover, since these are all layout components, we can access information about these ‘edit events’, by listening to the \"plotly_relayout\" events. Figure 21.5 just how easy it is to access information about changes in annotation positioning and content. library(shiny) ui &lt;- fluidPage( plotlyOutput(&quot;p&quot;), verbatimTextOutput(&quot;info&quot;) ) server &lt;- function(input, output, session) { output$p &lt;- renderPlotly({ plot_ly() %&gt;% layout( annotations = list( list( text = emo::ji(&quot;fire&quot;), x = 0.5, y = 0.5, xref = &quot;paper&quot;, yref = &quot;paper&quot;, showarrow = FALSE ), list( text = &quot;fire&quot;, x = 0.5, y = 0.5, xref = &quot;paper&quot;, yref = &quot;paper&quot; ) )) %&gt;% config(editable = TRUE) }) output$info &lt;- renderPrint({ event_data(&quot;plotly_relayout&quot;) }) } shinyApp(ui, server) FIGURE 21.5: Accessing information about direct manipulation of annotations. Figure 21.6 demonstrates directly manipulating a circle shape and accessing the new positions of the circle. In constrast to Figure 21.5, which made everything (e.g. the plot and axis titles) editable via config(p, editable = TRUE), note how Figure 21.6 makes use of the edits argument to make only the shapes editable. library(shiny) library(plotly) ui &lt;- fluidPage( plotlyOutput(&quot;p&quot;), verbatimTextOutput(&quot;event&quot;) ) server &lt;- function(input, output, session) { output$p &lt;- renderPlotly({ plot_ly() %&gt;% layout( xaxis = list(range = c(-10, 10)), yaxis = list(range = c(-10, 10)), shapes = list( type = &quot;circle&quot;, fillcolor = &quot;gray&quot;, line = list(color = &quot;gray&quot;), x0 = -10, x1 = 10, y0 = -10, y1 = 10, xsizemode = &quot;pixel&quot;, ysizemode = &quot;pixel&quot;, xanchor = 0, yanchor = 0 ) ) %&gt;% config(edits = list(shapePosition = TRUE)) }) output$event &lt;- renderPrint({ event_data(&quot;plotly_relayout&quot;) }) } shinyApp(ui, server) FIGURE 21.6: Accessing information about direct manipulation of circle shapes. Figure 21.7 uses an ediatble vertical line and the plotly_relayout event data to ‘snap’ the line to the closest point in a sequence of x values. It also places a marker on the intersection between the vertical line shape and the line chart of y values. Notice how, by accessing event_data() in this way (i.e., the source and target view of the event is the same), the chart is actually fully redrawn every time the line shape moves. If performance were an issue (i.e., we were dealing with lots of lines), this type of interaction likely won’t be very responsive. In that case, you can use event_data() to trigger side-effects (i.e., partially modify the plot) which is covered in 21.3.1. library(shiny) library(plotly) ui &lt;- fluidPage( plotlyOutput(&quot;p&quot;), verbatimTextOutput(&quot;event&quot;) ) x &lt;- seq(-10, 10) y &lt;- rnorm(length(x)) server &lt;- function(input, output, session) { output$p &lt;- renderPlotly({ d &lt;- event_data(&quot;plotly_relayout&quot;) selected_point &lt;- if (!is.null(d[[&quot;shapes[0].x0&quot;]])) { # &#39;snap&#39; the x-position from the event to the closest `x` value xint &lt;- d[[&quot;shapes[0].x0&quot;]] xpt &lt;- x[which.min(abs(x - xint))] list(x = xpt, y = y[which(x == xpt)]) } else { # default to list(x = 1, y = y[which(x == 1)]) } plot_ly(color = I(&quot;red&quot;)) %&gt;% add_lines(x = x, y = y) %&gt;% add_markers(x = selected_point$x, y = selected_point$y) %&gt;% layout( shapes = list( type = &quot;line&quot;, line = list(color = &quot;gray&quot;, dash = &quot;dot&quot;), x0 = selected_point$x, x1 = selected_point$x, y0 = 0, y1 = 1, yref = &quot;paper&quot; ) ) %&gt;% config(editable = TRUE) }) } shinyApp(ui, server) FIGURE 21.7: Dragging a vertical line shape and ‘snapping’ the line to match the closest provided x value. 21.2.4 Relayout vs restyle events Remember every graph has two critical components: data (i.e., traces) and layout. Similar to how \"plotly_relayout\" reports partial modifications to the layout, the \"plotly_restyle\" event reports partial modification to traces. Compared to \"plotly_relayout\", there aren’t very many native direct manipulation events that would trigger a \"plotly_restyle\" event. For example, zoom/pan events, camera changes, editing annotations/shapes/etc all trigger a \"plotly_relayout\" event, but not many traces allow you to directly manipulate their properties. One notable exception is the \"parcoords\" trace type which has native support for brushing lines along an axis dimension(s). As Figure 21.8 demonstrates, these brush events emit a \"plotly_restyle\" event with the range(s) of the highlighted dimension. library(plotly) library(shiny) ui &lt;- fluidPage( plotlyOutput(&quot;parcoords&quot;), verbatimTextOutput(&quot;info&quot;) ) server &lt;- function(input, output, session) { output$parcoords &lt;- renderPlotly({ plot_ly(iris) %&gt;% add_parcoords() }) output$info &lt;- renderPrint({ d &lt;- event_data(&quot;plotly_restyle&quot;) if (is.null(d)) &quot;Brush along a dimension&quot; else d }) } shinyApp(ui, server) FIGURE 21.8: Using the \"plotly_restyle\" event to access brushed dimensions of a parallel coordinates plot. As Figure 21.9 shows, it’s possible to use this information to infer which data points are highlighted. The logic to do so is fairly sophisticated, and requires accumulation of the event data, as discussed in section 21.2.8. plotly_example(&quot;shiny&quot;, &quot;event_data_parcoords&quot;) FIGURE 21.9: Displaying the highlighted observations of a parcoords trace. 21.2.5 Scoping events This section leverages the interface for accessing plotly input events introduced in section 21.2 to inform other data views about those events. When managing multiple views that communicate with one another, you’ll need to be aware of which views are a source of interaction and which are a target (a view can be both, at once!). The event_data() function provides a source argument to help refine which view(s) serve as the source of an event. The source argument takes a string ID, and when that ID matches the source of a plot_ly()/ggplotly() graph, then the event_data() is “scoped” to that view. To get a better idea of how this works, consider Figure 21.10 Figure 21.10 allows one to click on a cell of correlation heatmap to generate a scatterplot of the two corresponding variables – allowing for a closer look at their relationship. In the case of a heatmap, the event data tied to a plotly_click event contains the relevant x and y categories (e.g., the names of the data variables of interest) and the z value (e.g., the pearson correlation between those variables). In order to obtain click data from the heatmap, and only the heatmap, it’s important that the source argument of the event_data() function matches the source argument of plot_ly(). Otherwise, if the source argument was not specified event_data(\"plotly_click\") would also fire if and when the user clicked on the scatterplot, likely causing an error. library(shiny) # cache computation of the correlation matrix correlation &lt;- round(cor(mtcars), 3) ui &lt;- fluidPage( plotlyOutput(&quot;heat&quot;), plotlyOutput(&quot;scatterplot&quot;) ) server &lt;- function(input, output, session) { output$heat &lt;- renderPlotly({ plot_ly(source = &quot;heat_plot&quot;) %&gt;% add_heatmap( x = names(mtcars), y = names(mtcars), z = correlation ) }) output$scatterplot &lt;- renderPlotly({ # if there is no click data, render nothing! clickData &lt;- event_data(&quot;plotly_click&quot;, source = &quot;heat_plot&quot;) if (is.null(clickData)) return(NULL) # Obtain the clicked x/y variables and fit linear model to those 2 vars vars &lt;- c(clickData[[&quot;x&quot;]], clickData[[&quot;y&quot;]]) d &lt;- setNames(mtcars[vars], c(&quot;x&quot;, &quot;y&quot;)) yhat &lt;- fitted(lm(y ~ x, data = d)) # scatterplot with fitted line plot_ly(d, x = ~x) %&gt;% add_markers(y = ~y) %&gt;% add_lines(y = ~yhat) %&gt;% layout( xaxis = list(title = clickData[[&quot;x&quot;]]), yaxis = list(title = clickData[[&quot;y&quot;]]), showlegend = FALSE ) }) } shinyApp(ui, server) FIGURE 21.10: Linking each cell of a correlation heatmap to their corresponding scatterplots. 21.2.6 Event priority By default, event_data() only invalidates a reactive expression when the value of it’s corresponding shiny input changes. Sometimes, you might want a particular event, say \"plotly_click\", to always invalidate a reactive expression. Figure 21.11 shows the difference between this default behavior versus setting priority = 'event'. By default, repeatedly clicking the same marker won’t update the clock, but when setting the priority argument to event, repeatedly clicking the same marker will update the clock (i.e., it will invalidate the reactive expression). library(shiny) ui &lt;- fluidPage( plotlyOutput(&quot;p&quot;), textOutput(&quot;time1&quot;), textOutput(&quot;time2&quot;) ) server &lt;- function(input, output, session) { output$p &lt;- renderPlotly({ plot_ly(x = 1:2, y = 1:2, size = I(c(100, 150))) %&gt;% add_markers() }) output$time1 &lt;- renderText({ event_data(&quot;plotly_click&quot;) paste(&quot;Input priority: &quot;, Sys.time()) }) output$time2 &lt;- renderText({ event_data(&quot;plotly_click&quot;, priority = &quot;event&quot;) paste(&quot;Event priority: &quot;, Sys.time()) }) } shinyApp(ui, server) FIGURE 21.11: A demo of input priority versus event priority. Clicking on the same marker repeatedly, by default, won’t invalidate a reactive expression that depends on ‘plotly_click’, but it will invalidate when given event priority. There are numerous events accessible through event_data() that don’t contain any information (e.g., \"plotly_doublelick\", \"plotly_deselect\", \"plotly_afterplot\", etc). These events are automatically given an event priority since their corresponding shiny input value never changes. One common use case for events like \"plotly_doublelick\" (fired when double-clicking in a zoom or pan dragmode) and \"plotly_deselect\" (fired when double-clicking in a selection mode) is to clear or reset accumulating event data. 21.2.7 Handling discrete axes For events that are trace-specific (e.g. \"plotly_click\", \"plotly_hover\", \"plotly_selecting\", etc), the positional data (e.g., x/y/z) is always numeric, so if you have a plot with discrete axes, you might want to know how to map that numeric value back to the relevant input data category. In some cases, you can avoid the problem by assigning the discrete variable of interest to the key/customdata attribute, but you might also want to reserve that attribute to encode other information, like a fill aesthetic. Figure 21.12 shows how to map the numerical x value emitted in a click event back to the discrete variable that it corresponds to (mpg$class) and leverages customdata to encode the fill mapping allowing us to display the data records a clicked bar corresponds to. In both ggplotly() and plot_ly(), categories associated with a character vector are always alphabetized, so if you sort() the unique() character values, then the vector indices will match the x event data values. On the other hand, if x were a factor variable, the x event data would match the ordering of the levels() attribute. library(shiny) library(dplyr) ui &lt;- fluidPage( plotlyOutput(&quot;bars&quot;), verbatimTextOutput(&quot;click&quot;) ) classes &lt;- sort(unique(mpg$class)) server &lt;- function(input, output, session) { output$bars &lt;- renderPlotly({ ggplot(mpg, aes(class, fill = drv, customdata = drv)) + geom_bar() }) output$click &lt;- renderPrint({ d &lt;- event_data(&quot;plotly_click&quot;) if (is.null(d)) return(&quot;Click a bar&quot;) mpg %&gt;% filter(drv %in% d$key) %&gt;% filter(class %in% classes[d$x]) }) } shinyApp(ui, server) FIGURE 21.12: Retrieving the data observations that correspond to a particular bar in a stacked bar chart. 21.2.8 Accumulating and managing event data Currently all the events accessible through event_data() are transient. This means that, given an event like \"plotly_click\", the value of event_data() will only reflect the most recent click information. However, in order to implement complex linked graphics with persistent qualities, like Figure 20.4 or 21.22, you’ll need someway to accumulate and manage event data. The general mechanism that shiny provides to achieve this kind of task is reactiveVal() (or, the plural version, reactiveValues()), which essentially provides a way to create and manage input values entirely server-side. Figure 21.13 demonstrates a shiny app that accumulates hover information and paints the hovered points in red. Every time a hover event is triggered, the corresponding car name is added to the set of selected cars, and everytime the plot is double-clicked that set is cleared. This general pattern of initializing a reactive value (i.e., cars &lt;- reactiveVal()), updating that value upon a suitable observeEvent() event with relevant customdata, and clearing that reactive value (i.e., cars(NULL)) in response to another event is a very useful pattern to can support essentially any sort of linked views paradigm because the logic behind the resolution of selection sequences is under your complete control in R. For example, 21.13 simply adds accumulates the event data from \"plotly_hover\" (which is like a logical OR operations), but for other applications, you may need different logic, like the AND, XOR, etc. library(shiny) ui &lt;- fluidPage( plotlyOutput(&quot;p&quot;), tableOutput(&quot;table&quot;) ) server &lt;- function(input, output, session) { # keep track of which cars have been hovered on cars &lt;- reactiveVal() # On hover, the key field of the event data contains the car name # Add that name to the set of all &quot;selected&quot; cars observeEvent(event_data(&quot;plotly_hover&quot;), { car &lt;- event_data(&quot;plotly_hover&quot;)$key cars_old_new &lt;- c(cars(), car) cars(unique(cars_old_new)) }) # clear the set of cars when a double-click occurs observeEvent(event_data(&quot;plotly_doubleclick&quot;), { cars(NULL) }) output$p &lt;- renderPlotly({ # if the car is selected, paint it red cols &lt;- ifelse(row.names(mtcars) %in% cars(), &quot;red&quot;, &quot;black&quot;) mtcars %&gt;% plot_ly( x = ~wt, y = ~mpg, key = row.names(mtcars), color = I(cols) ) %&gt;% add_markers() }) output$table &lt;- renderTable({ filter(mtcars, row.names(mtcars) %in% cars()) }) } shinyApp(ui, server) FIGURE 21.13: Using reactiveVals() to enable a persistent brush via mouse hover. In this example, the brush can be cleared through a double-click event. Figure 21.14 demonstrates a shiny gadget for interactively removing/adding points from a linear model via a scatterplot. A shiny gadget is similar to a normal shiny app except that it allows you to return object(s) from the application back to into your R session. In this case, Figure 21.14 returns the fitted model with the outliers removed and the choosen polynomial degree. The logic behind this app does more than simply accumulate event data everytime a point is clicked. Instead, it adds points to the ‘outlier’ set only if it isn’t already an outlier, and removes points that are already in the “outlier” set (so, it’s essentially XOR logic). plotly_example(&quot;shiny&quot;, &quot;lmGadget&quot;) FIGURE 21.14: Interactively removing observations from a linear model. Credit to Winston Chang for the initial implementation of this shiny gadget using shiny::plotOutput() instead of plotly::plotlyOutput() As you can already see, the ability to accumulate and manage event data is a critical skill to have in order to implement shiny applications with complex interactive capabilities. The pattern demonstrates here is known more generally as “maintaining state” of a shiny app based on user interactions and has a variety of applications. So far, we’ve really only see how to maintain state of a single view, but as we’ll see later in section 21.4, the ability to maintain state is required to implement many advanced applications of multiple linked views. Also, it should be noted that Figure 21.13 and 21.14 perform a full redraw when updated – these apps would feel a bit more responsive if they leveraged strategies from section 21.3.1. 21.3 Improving performance Multiple linked views are known to help facilitate data exploration, but latency in the user interface is also known to reduce exploratory findings (Heer 2014). In addition to the advice and techniques offered in section 21.3.1 for improving plotly’s performance in general, there are also techniques specifically for shiny apps that you can leverage to help improve the user experience. When trying to speed-up any slow code, the first step is always to identify the main contributor(s) to the poor performance. In some cases, your intuition may serve as a helpful guide, but in order to really see what’s going on, consider using a code profiling tool like profvis (Chang and Luraschi 2018). The profvis package provides a really nice way to visualize and isolate slow running R code in general, but it also works well for profiling shiny apps (RStudio 2014b). A lot of different factors can contribute to poor performance in a shiny app, but thankfully, the shiny ecosystem provides an extensive toolbox for diagnosing and improving performance. The profvis package is great for identifying “universal” performance issues, but when deploying shiny apps into production, there may be other potential bottlenecks that surface. This is largely due to R’s single-threaded nature – a single R server has difficulty scaling to many users because, by default, it can only handle one job at a time. The shinyloadtest package helps to identify those bottlenecks and shiny’s support for asynchronous programming with promises is one way to address them without increasing computational infrastructure (e.g. multiple servers) (Dipert, Schloerke, and Borges 2018); (Cheng 2018b). To reiterate the section on “Improving performance and scalability” in shiny from Cheng (2018a), you have a number of tools available to address performance: The profvis package for profiling code. Cache computations ahead-of-time. Cache computations at run time. Cache computations through chaining reactive expressions. Leverage multiple R processes and/or servers. Async programming with promises We won’t directly cover these topics, but it’s worth noting that all these tools are primarily designed for improving server-side performance of a shiny app. It could be that sluggish plots in your shiny app are due to sluggish server-side code, but it could also be that some of the sluggishness is due to redundant work being done client-side by plotly. Avoiding this redundancy, as covered in section 21.3.1, can be difficult, and it doesn’t always lead to noticable improvements. However, when you need to put lots of graphical elements on a plot, then update just a portion of the plot in response to user event(s), the added complexity can be worth the effort. 21.3.1 Partial plotly updates By default, when renderPlotly() renders a new plotly graph it’s essentially equivalent to executing a block of R code from your R prompt and generating a new plotly graph from scratch. That means, not only does the R code need to re-execute to generate a new R object, but it also has to re-serialize that object as JSON, and your browser has to re-render the graph from the new JSON object (more on this in section ??). In cases where your plotly graph does not need to serialize a lot data and/or render lots of graphical elements, as in Figure 21.1, you can likely perform a full redraw without noticable glitches, especially if you use canvas-based rendering rather than SVG (i.e., toWebGL()). Generally speaking, you should try very hard to make your app responsive before adopting partial plotly updates in shiny. It makes your app logic easy to reason about because you don’t have to worry about maintaining the state of the graph, but sometimes you have no other choice. On initial page load, plotly graphs must be drawn from stratch, but when responding to certain user events, often times a partial update to an existing plot is sufficient and more responsive. Take, for instance, the difference between Figure 21.15, which does a full redraw on every update, and Figure 21.16, which does a partial update after initial load. Both of these shiny apps display a scatterplot with 100,000 points and allow a user to overlay a fitted line through a checkbox. The key difference is that in Figure 21.15, the plotly graph is regenerated from scratch everytime the value of input$smooth changes, whereas in Figure 21.16 only the fitted line is added/removed from the plotly. Since the main bottleneck lies in redrawing the points, Figure 21.16 can add/remove the fitted line is a much more responsive fashion. library(shiny) library(plotly) # Generate 100,000 observations from 2 correlated random variables d &lt;- MASS::mvrnorm(1e6, mu = c(0, 0), Sigma = matrix(c(1, 0.5, 0.5, 1), 2, 2)) d &lt;- setNames(as.data.frame(d), c(&quot;x&quot;, &quot;y&quot;)) # fit a simple linear model m &lt;- lm(y ~ x, data = d) # generate y predictions over a grid of 10 x values dpred &lt;- data.frame( x = seq(min(d$x), max(d$x), length.out = 10) ) dpred$yhat &lt;- predict(m, newdata = dpred) ui &lt;- fluidPage( plotlyOutput(&quot;scatterplot&quot;), checkboxInput(&quot;smooth&quot;, label = &quot;Overlay fitted line?&quot;, value = FALSE) ) server &lt;- function(input, output, session) { output$scatterplot &lt;- renderPlotly({ p &lt;- plot_ly(d, x = ~x, y = ~y) %&gt;% add_markers(color = I(&quot;black&quot;), alpha = 0.05) %&gt;% toWebGL() %&gt;% layout(showlegend = FALSE) if (!input$smooth) return(p) add_lines(p, data = dpred, x = ~x, y = ~yhat, color = I(&quot;red&quot;)) }) } shinyApp(ui, server) FIGURE 21.15: Naive implementation of a shiny app that optionally overlays a fitted line to a scatterplot. A full redraw of the plot is performed everytime the checkbox is clicked, leading to an unnecessarily slow plot. In terms of the implementation behind Figure 21.15 and 21.16, the only difference resides in the server definition. In Figure 21.16, the renderPlotly() statement no longer has a dependency on input values, so that code is only executed once (on page load) to generate the initial view of the scatterplot. The logic behind adding and removing the fitted line is handled through an observe() block – this reactive expression watches the input$smooth input value and modifies the output$scatterplot widget whenever it changes. To trigger a modification of a plotly output widget, you must create a proxy object with plotlyProxy() that references the relevant output ID. Once a proxy object is created, you can invoke any sequence of plotly.js function(s) on it with plotlyProxyInvoke(). Invoking a method with the correct arguments can be tricky and requires knowledge of plotly.js because plotlyProxyInvoke() will send these arguments directly to the plotly.js method and therefore doesn’t support the same ‘high-level’ semantics that plot_ly() does. server &lt;- function(input, output, session) { output$scatterplot &lt;- renderPlotly({ plot_ly(d, x = ~x, y = ~y) %&gt;% add_markers(color = I(&quot;black&quot;), alpha = 0.05) %&gt;% toWebGL() }) observe({ if (input$smooth) { # this is essentially the plotly.js way of doing # `p %&gt;% add_lines(x = ~x, y = ~yhat) %&gt;% toWebGL()` # without having to redraw the entire plot plotlyProxy(&quot;scatterplot&quot;, session) %&gt;% plotlyProxyInvoke( &quot;addTraces&quot;, list( x = dpred$x, y = dpred$yhat, type = &quot;scattergl&quot;, mode = &quot;lines&quot;, line = list(color = &quot;red&quot;) ) ) } else { # JavaScript index starts at 0, so the &#39;1&#39; here really means # &quot;delete the second traces (i.e., the fitted line)&quot; plotlyProxy(&quot;scatterplot&quot;, session) %&gt;% plotlyProxyInvoke(&quot;deleteTraces&quot;, 1) } }) } FIGURE 21.16: A more responsive version of Figure 21.15. Figure 21.15 demonstrates a common use case where partial updates can be helpful, but there are other not-so-obvious cases. The next section covers a range of examples where you’ll see how to leverage partial updates to implement smooth ‘streaming’ visuals, avoid resetting axis ranges, avoid flickering basemap layers, and more. 21.3.2 Partial update examples The last section explains why you may want to leverage partial plotly updates in shiny to get more responsive updates through an example. That example leveraged the plotly.js functions Plotly.addTraces() and Plotly.deleteTraces() to add/remove a layer to a plot after it’s initial draw. There are numerous other plotly.js functions that can be handy for a variety of use cases, some of the most widely used ones are: Plotly.restyle() for updating data visuals (section 21.3.2.1), Plotly.relayout() for updating the layout (section 21.3.2.2), and Plotly.extendTraces() for streaming data (section 21.3.2.3). 21.3.2.1 Modifying traces All plotly figures have two main components: traces (i.e., mapping from data to visuals) and layout. The plotly.js function Plotly.restyle() is for modifying any existing traces. In addition to being a performant way to modify existing data and/or visual properties, it also has the added benefit of not affecting the current layout of the graph. Notice how, in Figure 21.17 for example, when the size of the marker/path changes, it doesn’t change the camera’s view of the 3D plot that the user altered after initial draw. If these input widgets triggered a full redraw of the plot, the camera would be reset to it’s initial state. library(shiny) library(plotly) ui &lt;- fluidPage( sliderInput(&quot;marker&quot;, &quot;Marker size&quot;, min = 0, max = 20, value = 8), sliderInput(&quot;path&quot;, &quot;Path size&quot;, min = 0, max = 30, value = 2), plotlyOutput(&quot;p&quot;) ) server &lt;- function(input, output, session) { output$p &lt;- renderPlotly({ plot_ly( economics, x = ~pce, y = ~psavert, z = ~unemploy, color = ~as.numeric(date), mode = &quot;markers+lines&quot; ) }) observeEvent(input$marker, { plotlyProxy(&quot;p&quot;, session) %&gt;% plotlyProxyInvoke( &quot;restyle&quot;, # could also do list(marker = list(size = input$marker)) # but that overwrites the existing marker definition # https://github.com/plotly/plotly.js/issues/1866#issuecomment-314115744 list(marker.size = input$marker) ) }) observeEvent(input$path, { plotlyProxy(&quot;p&quot;, session) %&gt;% plotlyProxyInvoke( &quot;restyle&quot;, list(line.width = input$path) ) }) } shinyApp(ui, server) FIGURE 21.17: Using Plotly.restyle() to change just the width of a path and markers along that path in response to changes to shiny input sliders. One un-intuitive thing about Plotly.restyle() is that it fully replaces object (i.e., attributes that contain attributes) definitions like marker by default. To modify just a particular attribute of an object, like the size of a marker, you must replace that attribute directly (hence marker.size). As mentioned in the official documentation, by default, modifications are applied to all traces, but specific traces can be targeted through their trace index (which starts at 0, because JavaScript)! 21.3.2.2 Updating the layout All plotly figures have two main components: traces (i.e., mapping from data to visuals) and layout. The plotly.js function Plotly.relayout() modifies the layout component, so it can control a wide variety of things such titles, axis definitions, annotations, shapes, and many other things. It can even be used to change the basemap layer of a Mapbox-powered layout, as in Figure 21.18. Note how this example uses schema() to grab all the pre-packaged basemap layers and create a dropdown of those options, but you can also provide a URL to a custom basemap style. library(shiny) library(plotly) # get all the available mapbox styles mapStyles &lt;- schema()$layout$layoutAttributes$mapbox$style$values ui &lt;- fluidPage( selectInput(&quot;style&quot;, &quot;Select a mapbox style&quot;, mapStyles), plotlyOutput(&quot;map&quot;) ) server &lt;- function(input, output, session) { output$map &lt;- renderPlotly({ plot_mapbox() }) observeEvent(input$style, { plotlyProxy(&quot;map&quot;, session) %&gt;% plotlyProxyInvoke( &quot;relayout&quot;, list(mapbox = list(style = input$style)) ) }) } shinyApp(ui, server) FIGURE 21.18: Using Plotly.relayout() to ‘auto-range’ the y-axis in response to changes in the x-axis range. Figure 21.19 demonstrates a clever use of Plotly.relayout() to set the y-axis range in response to changes in the x-axis range. library(shiny) library(plotly) ui &lt;- fluidPage( plotlyOutput(&quot;plot&quot;) ) server &lt;- function(input, output, session) { p &lt;- ggplot(txhousing) + geom_line(aes(date, median, group = city)) output$plot &lt;- renderPlotly({ ggplotly(p, dynamicTicks = TRUE) %&gt;% rangeslider() }) observeEvent(event_data(&quot;plotly_relayout&quot;), { d &lt;- event_data(&quot;plotly_relayout&quot;) xmin &lt;- if (length(d[[&quot;xaxis.range[0]&quot;]])) d[[&quot;xaxis.range[0]&quot;]] else d[[&quot;xaxis.range&quot;]][1] xmax &lt;- if (length(d[[&quot;xaxis.range[1]&quot;]])) d[[&quot;xaxis.range[1]&quot;]] else d[[&quot;xaxis.range&quot;]][2] if (is.null(xmin) || is.null(xmax)) return(NULL) # compute the y-range based on the new x-range idx &lt;- with(txhousing, xmin &lt;= date &amp; date &lt;= xmax) yrng &lt;- extendrange(txhousing$median[idx]) plotlyProxy(&quot;plot&quot;, session) %&gt;% plotlyProxyInvoke(&quot;relayout&quot;, list(yaxis = list(range = yrng))) }) yRange &lt;- range(txhousing$median, na.rm = TRUE) observeEvent(event_data(&quot;plotly_doubleclick&quot;), { plotlyProxy(&quot;plot&quot;, session) %&gt;% plotlyProxyInvoke(&quot;relayout&quot;, list(yaxis = list(range = yRange))) }) } shinyApp(ui, server) FIGURE 21.19: Using Plotly.relayout() to ‘auto-range’ the y-axis in response to changes in the x-axis range. 21.3.2.3 Streaming data At this point, we’ve seen how to add/remove traces (e.g., add/remove a fitted line, as in Figure 21.16), and how to edit specific trace properties (e.g., change marker size or path width, as in Figure 21.17), but what about adding more data to existing trace(s)? This is a job for the plotly.js function Plotly.extendTraces() and/or Plotly.prependTraces() which can used to efficiently ‘stream’ data into an existing plot, as done in Figure 21.20. The implementation behind Figure 21.20, an elementary example of a random walk, makes use of some fairly sophisicated reactive programming tools from shiny. Similar to most examples from this section, the renderPlotly() statement is executed once on initial load to draw the initial line with just two data points. By default, the plot is not streaming, but streaming can be turned on or off through the click of a button, which will require the app to know (at all times) whether or not we are in a streaming state. One way to do this is to leverage shiny’s reactiveValues(), which act like input values, but can be created and modified entirely server-side, making them quite useful for maintaining state of an application. In this case, the reactive value rv$stream is used to store the streaming state, which is turned on/off whenever the actionButton() is clicked (via the observeEvent() logic). Even if the app is not streaming, there is still constant client/server communication because of the use of invalidateLater() inside the observe(). This effectively tells shiny to re-evaluate the observe() block every 100 milliseconds. If the app isn’t in streaming mode, then it exits early without doing anything. If the app is streaming, then we first use sample() to randomly draw either -1 or 1 (with equal probability) and use the result to update the most recent (x, y) state. This is done by assigning a new value to the reactive values rv$y and rv$n within an isolate()d context – if this assignment happened outside of an isolate()d context it would cause the reactive expression to be invalidated and cause an infinite loop! Once we have the new (x, y) point stored away, Plotly.extendTraces() can be used to add the new point to the plotly graph. library(shiny) library(plotly) ui &lt;- fluidPage( actionButton(&quot;stream&quot;, &quot;Turn stream on/off&quot;), plotlyOutput(&quot;plot&quot;) ) server &lt;- function(input, output, session) { # initial values yint &lt;- c(0, 1) # initiate graph with initial values output$plot &lt;- renderPlotly({ plot_ly(y = yint, x = seq_along(yint)) %&gt;% add_lines() }) # reactiveValues() act very much like input values, but may be used to # maintain state (e.g., are we currently streaming?) rv &lt;- reactiveValues( stream = FALSE, yend = sum(yint), n = length(yint) ) # turn streaming on/off when the button is pressed observeEvent(input$stream, { rv$stream &lt;- if (rv$stream) FALSE else TRUE }) observe({ # if we&#39;re not streaming, don&#39;t do anything if (!rv$stream) return() # re-execute this code block to every 100 milliseconds invalidateLater(100, session) # changing a reactive value &quot;invalidates&quot; it, so isolate() is needed # to avoid recursion isolate({ rv$n &lt;- rv$n + 1 rv$yend &lt;- rv$yend + sample(c(-1, 1), 1) }) # add the new value to the plot plotlyProxy(&quot;plot&quot;, session) %&gt;% plotlyProxyInvoke( &quot;extendTraces&quot;, list( y = list(list(rv$yend)), x = list(list(rv$n)) ), list(0) ) }) } shinyApp(ui, server) FIGURE 21.20: Using Plotly.extendTraces() to efficiently stream data into a plotly chart. This specific example implements a random walk (using R’s random number generator) which updates every 100 milliseconds. To see more examples that leverage partial updating, see section 21.4.2. 21.4 Advanced applications This section combines concepts from prior sections in linking views with shiny and applies them towards some popular use cases. 21.4.1 Drill-down The so-called ‘drill-down’ chart tends to include a vague grouping of interactive graphics that allow one to generate new views based on interesting subset(s) of the data. In Figure 21.21, the first bar chart shows store sales broked down by their main categories. By clicking on a bar, one can drill-down into that category to see the breakdown of sub-categories within that category. From there, one may pick a sub-category to populate a time series of the corresponding sales; and futhermore, click on a particular date to see the actual sales records for that day. In a drill-down chart, a change in the top-level category should trigger changes to sub-categories, so to handle this logic correctly, you’ll want to store selections in reactive values and update those values accordingly when relevant events occur. For example, note how in Figure 21.21, a click of a category clears the sub-category and order-date. Moreover, a change in a sub-category will clear the order-date, but doesn’t change the category. library(shiny) library(plotly) library(dplyr) # CSV available from https://github.com/cpsievert/plotly_book sales &lt;- readr::read_csv(&quot;data/sales.csv&quot;) ui &lt;- fluidPage( plotlyOutput(&quot;category&quot;, height = 200), plotlyOutput(&quot;sub_category&quot;, height = 200), plotlyOutput(&quot;sales&quot;, height = 300), dataTableOutput(&quot;datatable&quot;) ) # avoid repeating this code axis_titles &lt;- . %&gt;% layout( xaxis = list(title = &quot;&quot;), yaxis = list(title = &quot;Sales&quot;) ) server &lt;- function(input, output, session) { # for maintaining the state of drill-down variables category &lt;- reactiveVal() sub_category &lt;- reactiveVal() order_date &lt;- reactiveVal() # when clicking on a category, observeEvent(event_data(&quot;plotly_click&quot;, source = &quot;category&quot;), { category(event_data(&quot;plotly_click&quot;, source = &quot;category&quot;)$x) sub_category(NULL) order_date(NULL) }) observeEvent(event_data(&quot;plotly_click&quot;, source = &quot;sub_category&quot;), { sub_category(event_data(&quot;plotly_click&quot;, source = &quot;sub_category&quot;)$x) order_date(NULL) }) observeEvent(event_data(&quot;plotly_click&quot;, source = &quot;order_date&quot;), { order_date(event_data(&quot;plotly_click&quot;, source = &quot;order_date&quot;)$x) }) output$category &lt;- renderPlotly({ sales %&gt;% count(category, wt = sales) %&gt;% plot_ly(x = ~category, y = ~n, source = &quot;category&quot;) %&gt;% axis_titles() %&gt;% layout(title = &quot;Sales by category&quot;) }) output$sub_category &lt;- renderPlotly({ if (is.null(category())) return(NULL) sales %&gt;% filter(category %in% category()) %&gt;% count(sub_category, wt = sales) %&gt;% plot_ly(x = ~sub_category, y = ~n, source = &quot;sub_category&quot;) %&gt;% axis_titles() %&gt;% layout(title = category()) }) output$sales &lt;- renderPlotly({ if (is.null(sub_category())) return(NULL) sales %&gt;% filter(sub_category %in% sub_category()) %&gt;% count(order_date, wt = sales) %&gt;% plot_ly(x = ~order_date, y = ~n, source = &quot;order_date&quot;) %&gt;% add_lines() %&gt;% axis_titles() %&gt;% layout(title = paste(sub_category(), &quot;sales over time&quot;)) }) output$datatable &lt;- renderDataTable({ if (is.null(order_date())) return(NULL) sales %&gt;% filter( sub_category %in% sub_category(), as.Date(order_date) %in% as.Date(order_date()) ) }) } shinyApp(ui, server) FIGURE 21.21: Using a drill-down approach to navigating through sales data by category, sub-category, and order date. 21.4.2 Cross-filter Related to the drill-down chart is so-called ‘cross-filter’ chart. The main difference between drill-down and cross-filter is that, with cross-filter, the visualizations are typically fixed and selection(s) impose a filter on the data shown in those fixed views. The typical cross-filter implementation allows multiple brushes (i.e., filters) and uses the intersection of those filters to the dataset portrayed in those views. Figure 21.22 demonstrates how one could apply this technique to a set of histograms using the flights dataset from the nycflights13 package (Wickham 2018). The brush range for each view in stored and maintained in a reactiveValues() variable, named brush_ranges. Since the actual bar heights reflect only the active filters in other views, the d_filter() function is called for each view using only the brush_ranges from the other views. library(shiny) library(dplyr) library(nycflights13) # install from https://github.com/hadley/ggstat library(ggstat) # Collect numeric variables to be shown as histograms in the crossfilter d &lt;- select(flights, arr_time, dep_time, arr_delay, dep_delay, air_time, distance) # Generate an output container per variable ui &lt;- fluidPage( lapply(names(d), function(nm) plotlyOutput(nm, height = 200, width = &quot;49%&quot;, inline = TRUE)) ) server &lt;- function(input, output, session) { # These reactive values track the set of active brushes # Each reactive value corresponds to a different variable brush_ranges &lt;- reactiveValues() # Filter the dataset based on every active brush range except for one (var) d_filter &lt;- function(d, var = &quot;arr_time&quot;) { for (nm in setdiff(names(d), var)) { rng &lt;- brush_ranges[[nm]] if (is.null(rng)) next d &lt;- filter(d, between(d[[nm]], min(rng), max(rng))) } d } # Implement same render logic for each variable lapply(names(d), function(nm) { counts &lt;- d[[nm]] %&gt;% bin_fixed(bins = 150) %&gt;% compute_stat(d[[nm]]) %&gt;% filter(!is.na(xmin_)) %&gt;% mutate(xmid = (xmin_ + xmax_) / 2) output[[nm]] &lt;- renderPlotly({ plot_ly(counts, source = nm) %&gt;% add_bars(x = ~xmid, y = ~count_) %&gt;% layout( dragmode = &quot;select&quot;, selectdirection = &quot;h&quot;, xaxis = list( title = nm, range = range(d[[nm]], na.rm = TRUE) ), yaxis = list(title = &quot;&quot;) ) }) observeEvent(event_data(&quot;plotly_brushing&quot;, source = nm), ignoreNULL = FALSE, { # inform the world about the new brush range brush_ranges[[nm]] &lt;- event_data(&quot;plotly_brushing&quot;, source = nm)$x # update the bar heights of every view (except for the one being brushed) for (var in setdiff(names(d), nm)) { # views respect every brush except for their own d_filtered &lt;- d_filter(d, var) # bin the filtered data based on the global binning definition counts_filter &lt;- d[[var]] %&gt;% bin_fixed(bins = 150) %&gt;% compute_stat(d_filtered[[var]]) %&gt;% filter(!is.na(xmin_)) %&gt;% mutate(xmid = (xmin_ + xmax_) / 2) # finally, update the bar heights plotlyProxy(var, session) %&gt;% plotlyProxyInvoke(&quot;restyle&quot;, &quot;y&quot;, list(counts_filter$count_), 0) } }) }) } shinyApp(ui, server) FIGURE 21.22: Crossfiltering flights data from the nycflights13 package (Wickham 2018). Even though the filtering and binning logic occurs server-side, a very minimal amount of data is sent between server and client (just the brush range and bar heights). Moreover, to perform the UI update, the client only has to tweak existing bar heights, so the overall user experience is quite responsive. One weakness of a typical crossfilter interface like Figure 21.22 is that it’s difficult to make visual comparisons. That is, when a filter is applied, you lose a visual reference to the overall distribution and/or prior filter, making difficult to make meaningful comparisons. Figure 21.22 modifies the logic of Figure 21.23 to enable filter comparisons by adding the ability to change the color of the brush. Moreover, for sake of demonstration and simplicity, it also allows for only one active filter per color (i.e., brushing within color is transient). One could borrow logic from Figure 21.22 to allow multiple filters for each color, but this would require multiple brush_ranges. Since brushing within color is transient, in constrast to Figure 21.22, Figure 21.23 doesn’t have to track the state of all the active brushes. It does, however, need to display relative rather than absolute frequencies to facilitate comparison of small filter range(s) to the overall distribution. This particular implementation takes the overall distribution as a “base layer” that remains fixed and overlays a handful of “selection layers” – one for each possible brush color. These selection layers begin with a height of 0, but when the relevant brush fires the heights of the bars for the relevant layer is modified. This approach may seem like a hack, but it leads to a fluid user experience because it’s not much work to adjust the height of a bar that already exists. library(shiny) library(dplyr) library(nycflights13) library(colourpicker) # install from https://github.com/hadley/ggstat library(ggstat) # Select all the (numeric) variables to be shown as histograms # in the crossfilter d &lt;- select(flights, arr_time, dep_time, arr_delay, dep_delay, air_time, distance) # Determing a color palette for the brush n_colors &lt;- 5 color_codes &lt;- RColorBrewer::brewer.pal(n_colors, &quot;Dark2&quot;) # Generate an output container per variable ui &lt;- fluidPage( fluidRow( tags$div( style = &quot;display:inline-block; max-width:150px; margin-left:50px&quot;, colourInput(&quot;brush_color&quot;, &quot;Pick a brush color&quot;, color_codes[1], palette = &quot;limited&quot;, allowedCols = color_codes) ), tags$div( style = &quot;display:inline-block&quot;, actionButton(&quot;clear&quot;, &quot;Clear Selection&quot;) ) ), lapply(names(d), function(nm) plotlyOutput(nm, height = 200, width = &quot;49%&quot;, inline = TRUE)) ) server &lt;- function(input, output, session) { # Implement same render logic for each variable lapply(names(d), function(nm) { # By letting R handle the binning, there is less data to send over the # wire (and, thus, a more responsive app over back connections) counts &lt;- d[[nm]] %&gt;% bin_fixed(bins = 150) %&gt;% compute_stat(d[[nm]]) %&gt;% filter(!is.na(xmin_)) %&gt;% mutate( xmid = (xmin_ + xmax_) / 2, prop_ = count_ / sum(count_), zeros = 0 ) output[[nm]] &lt;- renderPlotly({ # Draw two layers of bars, one for the overall (black) # distribution, and one for the filtered data (red) p &lt;- plot_ly( counts, x = ~xmid, alpha = I(0.5), source = nm, unselected = list(marker = list(opacity = 1)) ) %&gt;% add_bars(y = ~prop_, color = I(&quot;black&quot;)) %&gt;% layout( dragmode = &quot;select&quot;, selectdirection = &quot;h&quot;, xaxis = list( title = nm, range = range(d[[nm]], na.rm = TRUE) ), yaxis = list( title = &quot;&quot;, showticks = FALSE, showticklabels = FALSE, showgrid = FALSE ), barmode = &quot;overlay&quot;, showlegend = FALSE ) for (col in color_codes) { p &lt;- add_bars(p, y = ~zeros, color = I(col)) } p }) # when the selection is cleared, return the selection layer bars to 0 observeEvent(input$clear, { plotlyProxy(nm, session) %&gt;% plotlyProxyInvoke(&quot;restyle&quot;, &quot;y&quot;, list(counts$zeros), seq_along(color_codes)) }) # each brush color code corresponds to a different trace index trace_index &lt;- reactive(match(input$brush_color, color_codes)) observe({ b &lt;- event_data(&quot;plotly_brushing&quot;, source = nm)$x in_bounds &lt;- between(d[[nm]], min(b), max(b)) lapply(names(d), function(var) { p &lt;- plotlyProxy(var, session) if (is.null(b)) { # brush has been cleared, return the selection bars to a zero height plotlyProxyInvoke(p, &quot;restyle&quot;, &quot;y&quot;, list(counts$zeros), trace_index()) } else { # if the brush originates from the proxy target # then don&#39;t compute a new marginal distribution, # just highlight the range of interest props &lt;- if (nm == var) { if_else( between(counts$xmin_, min(b), max(b)) &amp; between(counts$xmax_, min(b), max(b)), counts$prop_, 0 ) } else { d[[var]] %&gt;% bin_fixed(bins = 150) %&gt;% compute_stat(d[[var]][in_bounds]) %&gt;% filter(!is.na(xmin_)) %&gt;% mutate(prop_ = count_ / sum(count_)) %&gt;% pull(prop_) } plotlyProxyInvoke(p, &quot;restyle&quot;, &quot;y&quot;, list(props), trace_index()) } }) }) }) } shinyApp(ui, server) FIGURE 21.23: Comparing filters with a dynamic color brush. This particular example compares ‘red eye’ flights (in green) to early morning flights (in orange). This makes it easier to see that delays occur more often for ‘red eye’ flights. 21.5 Discussion Compared to the linking framework covered in section 20.1, the ability to link views server-side with shiny opens the door to many new possibilities. This chapter focuses mostly on using just plotly within shiny, but the shiny ecosystem is vast and these techniques can of course be used to inform other views, such as static plots, other htmlwidgets packages (e.g., leaflet, DT, network3D, etc), and other custom shiny bindings. In fact, I have a numerous shiny apps publically available via an R package that use numerous tools to provide exploratory interfaces to a variety of domain-specific problems, including zikar::explore() for exploring Zika virus reports, eechidna::launch() for exploring Australian election and census data, and bcviz::launch() for exploring housing and census information in British Colombia (Sievert 2018d); (Cook et al. 2017); (Sievert 2018a). These complex applications also serve as a reference as to how can use the client-side linking framework (i.e., crosstalk) inside a large appllication. See this video for an example: FIGURE 21.24: Example of a shiny app that has crosstalk functionality embedded. Sometimes shiny gets a bad wrap for being too slow or unresponsive, but as we learned in sections 21.3.1 and 21.4, we can still have very advanced functionality as well as a good user experience – it just takes a bit more effort to optimize performance in some cases. In fact, one could argue that a server-client approach to crossfiltering, as done in Figure 21.22 is more scalable than a purely client-side approach since the client wouldn’t need to know about the raw data – just the summary statistics. Nevertheless, sometimes linking views server side simply isn’t an option for you or your organization. Maybe your IT administrator simply won’t allow you to distribute your work outside of a standalone HTML file. Figure 21.10 is just one example of a linked graphic that could be replicated using the graphical querying framework from section 20.1, but it would require pre-computing every possible view (which becomes un-manageable when there are many possible selections) and posing the update logic as a database query. When users are only allowed to select (e.g. click/hover) a single element at a time, the number of possible selections increases linearly with the number of elements, but when users are allowed to select any subset of elements (e.g., scatterplot brushing), the number of possible selection explodes (increases at a factorial rate). For example, adding a cell to Figure 21.10 only adds one possible selection, but if we added more states to Figure 21.10, the number of possible states goes from 50! to 51! Even in the case that you need a standalone HTML file and the R API that plotly provides doesn’t support the type of interactivity that you desire, you can always layer on additional JavaScript to hopefully achieve the functionality you desire. This can be useful for something as simple as opening a hyperlink when clicking on marker of a plotly graph – this topic is covered in section 26. References "],
["scaling.html", "22 Introduction", " 22 Introduction Scaling visualization to large amounts of information requires a combination of engineering, statistics, creativity, and critical thinking. All too often, people decide they want to look at all the raw data before having any look at any statistical summaries. Unfortunately, this can lead to wasted time on interesting engineering problems that generate un-satistifying analytical results. That being said, even if you’ve thought carefully about leveraging summaries, having a good grasp on the technical landscape for doing large-scale visualization on the web can still be useful. Part 22 covered linked views and demonstrated some techniques which can help put the famous infovis mantra into practice: “Overview first, then zoom and filter, then details on demand”. In other words, don’t try to show all the raw data in a single – show interesting summaries, then provide interactive tools to extract more information. From a statistical perspective, this mantra tends to work well, because, as Hadley Wickham says: “Visualization surprise, but don’t scale well. Models (i.e. summaries) scale well, but don’t surprise”. In other words, a model helps to reduce the amount of information to display, but it can not point out what important information it does not capture. By providing interactive tools that can reveal the information behind a particular summary, you provide a better framework for questioning the assumption inherent in your summarized overview of the data. Of course, when dealing with non-trivial models (i.e. summaries), it can be quite useful to leverage a statistical computing environment. These are helpful concepts to keep in mind when designing an exploratory interface to large scale data, and you’ll see several figures re-inforce these concepts, but for now we focus on the limitations in terms of rendering lots of graphical elements on a page. Whether you’re printing the result of ggplotly(), plot_ly(), or more generally any R htmlwidget, there are two classes of efficiency to be aware of: print-time (i.e. build) and run-time (i.e. render) efficiency. Roughly speaking, the bulk of the time translates R code to an R list. That list is then serialized as JSON (via jsonlite::toJSON()) and should match a JSON specification (i.e. schema) defined by the JavaScript library (which uses the JSON to render the widget). "],
["run-time-efficiency.html", "23 Run-time efficiency", " 23 Run-time efficiency SVG vs Web-GL Draw comparison to pdf/png Borrow examples from workshop A quick and easy way to try and improve render performance is to use canvas-based rendering (instead of vector-based SVG) with toWebGL(p). Switching from vector to canvas is generally a good idea when dealing with &gt;30,000 vectors, but in this case, we’re only dealing with a couple hundred vector paths, so switching from vector to canvas for our map won’t significantly improve rendering performance, and in fact, we’ll lose some nice SVG exclusive features (the plotly.js team is getting close to eliminating these limitations!). Instead, what we could (and should!) do is reduce the amount of points along to each path (technically speaking, we’ll reduce the complexity of the SVG d attribute). "],
["print-time-efficiency.html", "24 Print-time efficiency", " 24 Print-time efficiency profvis Data summary/simplification What’s in a plotly object? What happens at print-time? Build-time versus render time Build time profvis Render time SVG vs Web-GL rendering Data summary/simplification If you’ve ever found ggplotly() slow to print, chances are, the bulk of the time is spent building the R list and sending the JSON to plotly.js. For many htmlwidgets, the build time is negligible, but for more complex widgets like plotly, a lot of things need to happen, especially for ggplotly() since we call ggplot2::ggplot_build(), then crawl and map that data structure to plotly.js. In a shiny app, both the build and render stages are required on initial load, but the new plotlyProxy() interface provides a way to ‘cache’ expensive build (and render!) operation and update a graph by modifying just specific components of the figure (via plotly.js functions). Outside of a ‘reactive context’ like shiny, you could use htmlwidgets::saveWidget() to ‘cache’ the results of the build step to disk, send the file to someone else (or host it online somewhere), then only the render step is required to view the graph. "],
["a-case-study-with-cranlogs.html", "25 A case study with cranlogs", " 25 A case study with cranlogs "],
["javascript.html", "26 Introduction", " 26 Introduction The same plotly.js events that we accessed in shiny through event_data() in section 21.2 can also be leveraged purely client-side with some custom JavaScript (JS). That means, by knowing a little bit about JS and the plotly.js library, we can extend graphs created with the R package to have custom behavior without requiring a client-server application. This portion of the book focuses on writing custom responses to commonly used plotly.js events, but a lot of the same tools and techniques could be used to extend these graphs in other ways as well. To add a custom JS event handler to a plotly graph, you can leverage the onRender() function from the htmlwidgets package. This R function accepts a JS function as a string and calls that function when the widget is done rendering in the browser. The JS function needs (at least) one argument, el, which is the Document Object Model (DOM) element containing the plotly graph. Figure 26.1 shows how you could use onRender() to log (and inspect) the DOM element to your browser’s JS console. You can open the console of any browser (including RStudio!) with right-click -&gt; “Inspect Element” -&gt; “Console” tab (or similar). To demonstrate some useful DOM element’s properties, Figure 26.1 uses Firefox to inspect the element as a global variable, but as Figure 28.1 shows, Chrome currently offers better tools for code debugging the JS function provided to onRender() (e.g., setting breakpoints in virtual memory). library(htmlwidgets) plot_ly(z = ~volcano) %&gt;% onRender(&quot;function(el) { console.log(el); }&quot;) FIGURE 26.1: Using htmlwidgets::onRender() to inspect the relevant DOM instance containing the plotly graph and information related to it’s current display. The _fullData and _fullLayout attributes bound to the element are ‘internal’ (meaning relying on this information in production code is discouraged), but do provide a useful description of the chart’s current state, especially if you need access to computations done by plotly.js (e.g., axis tick placement). If you’re completely new to JavaScript and JSON, section 27 provides a foundation for understanding the subsequent sections, but those already familiar can skip ahead to section 28. "],
["json.html", "27 Working with JSON 27.1 Assignment, subsetting, and iteration 27.2 Mapping R to JSON", " 27 Working with JSON JavaScript and other web technologies are intimidating and time-consuming to learn, but by borrowing some knowledge of R’s data structures24, we can get up and running with useful examples fairly quickly. JavaScript Object Notation (JSON) is a popular data-interchange format that JavaScript uses to work with data. As turns out, working with JSON in JS is somewhat similar to working with list()s in R – both are recursive and heterogenous data structures that have similar semantics for accessing values. In JSON, there are three basic building blocks: objects, arrays, and primitive data types (e.g., number, string, boolean, null, undefined). Loosely speaking, a JSON array is similar to a un-named list() in R and a JSON object is similar to an un-named list(). In fact, if you’re already comfortable creating and subsetting named and un-named list()s in R, you can transfer some of that knowledge to JSON arrays and objects. 27.1 Assignment, subsetting, and iteration In R, the &lt;- operator assigns a value to a name, and the [[ operator extracts a list element by index: arr &lt;- list(&quot;hello&quot;, &quot;world&quot;, 10) arr[[1]] #&gt; &quot;hello&quot; In JS, the = assigns a value to a name. When assigning a new name, you should include the var keyword (or similar) to avoid creation of a global variable. The [ operator extracts list elements by index, but be careful, indexing in JS starts at 0 (not 1)! var arr = [&quot;hello&quot;, &quot;world&quot;, 10]; arr[0] // &quot;hello&quot; In R, the $ and [[ operator can be used to extract list elements by name. The difference is that $ does partial matching of names, while [[ requires the exact name. obj &lt;- list(x = c(&quot;hello&quot;, &quot;world&quot;), zoo = 10) obj$z #&gt; 10 obj[[&quot;zoo&quot;]] #&gt; 10 In JS, the . and [ operator can be used to extract list elements by name. In either case, the naming must be exact. var obj = { x: [&quot;hello&quot;, &quot;world&quot;], zoo: 10 } obj.zoo // 10 obj[&#39;zoo&#39;] // 10 Unlike R list()s, arrays and objects in JS come with properties and methods that can be accessed via the . operator. Arrays, in particular, have a length property and a map() method for applying a function to each array element: arr.length // 3 arr.map(function(item) { return item + 1; }); // [&quot;hello1&quot;, &quot;world1&quot;, 11] In R, both the lapply() and purrr::map() family of functions provide a similar functional interface. Also, note that operators like + in JS do even more type coercion than R, so although item + 1 works for strings in JS, it would throw an error in R (an that’s ok, most times you probably don’t want to add a string to a number)! If instead, you wanted to only add 1 to numeric values, you could use is.numeric() in R within an if else statement. purrr::map(arr, function(item) if (is.numeric(item)) item + 1 else item) #&gt; [[1]] #&gt; [1] &quot;hello&quot; #&gt; #&gt; [[2]] #&gt; [1] &quot;world&quot; #&gt; #&gt; [[3]] #&gt; [1] 11 In JS, you can use the typeof keyword to get the data type as well as the conditional ternary operator (condition ? exprT : exprF) to acheive the same task. arr.map(function(item) { return typeof item == &quot;number&quot; ? item + 1 : item; }); // [&quot;hello&quot;, &quot;world&quot;, 11] There are a handful of other useful array and object methods, but to keep things focused, we’ll only cover what’s required to comprehend section 28. A couple examples in that section use the filter() method, which like map() applies a function to each array element, but expects a logical expression and returns only the elements that meet the condition. arr.filter(function(item) { return typeof item == &quot;string&quot;; }); // [&quot;hello&quot;, &quot;world&quot;] 27.2 Mapping R to JSON In R, unlike JSON, there is no distinction between scalars and vectors of length 1. That means there is ambiguity as to what a vector of length 1 in R should map to in JSON. The jsonlite package defaults to an array of length 1, but this can be avoided by setting auto_unbox = TRUE. jsonlite::toJSON(&quot;A string in R&quot;) #&gt; [&quot;A string in R&quot;] jsonlite::toJSON(&quot;A string in R&quot;, auto_unbox = TRUE) #&gt; &quot;A string in R&quot; It’s worth noting that plotly.js, which consumes JSON objects, has specific expectations and rules about scalars versus arrays of length 1. If you’re calling the plotly.js library directly in JS, as we’ll see later in section 28, you’ll need to be mindful of the difference between scalars and arrays of length 1. Some attributes, like text and marker.size, accept both scalars and arrays and apply different rules based on the difference. Some other attributes, like x, y, and z only accept arrays and will error out if given a scalar. To learn about these rules and expectations, you can use the schema() function from R to inspect plotly.js’ specification as shown in Figure 27.1. Note that attributes with a val_type of 'data_array' require an array while attributes with an arrayOk: true field accept either scalars or arrays. schema() FIGURE 27.1: Using the plotly schema() to obtain more information about expected attribute types. In JSON, unlike R, there is no distinction between a heterogeneous and homogeneous collection of data types. In other words, in R, there is an important difference between list(1, 2, 3) and c(1, 2, 3) (the latter is an atomic vector and has a different set of rules). In JSON, there is no strict notion of a homogenous collection, so working with JSON arrays is essentially like being forced to use list() in R. This subtle fact can lead to some suprising results when trying to serialize R vectors as JSON arrays. For instance, if you wanted to create a JSON array, say [1,\"a\",true] using R objects, you may be tempted to do the following: jsonlite::toJSON(c(1, &quot;a&quot;, TRUE)) #&gt; [&quot;1&quot;,&quot;a&quot;,&quot;TRUE&quot;] But this actually creates an array of strings instead of the array with a number, string, and boolean that we desire. The problems actually lies in the fact that c() coerces the collection of values into an atomic vector. Instead, you should use list() over c(): jsonlite::toJSON(list(1, &quot;a&quot;, TRUE), auto_unbox = TRUE) #&gt; [1,&quot;a&quot;,true] If you’d like a nice succinct overview on the topic, see http://adv-r.had.co.nz/Data-structures.html↩ "],
["js-event-handlers.html", "28 Adding custom event handlers", " 28 Adding custom event handlers When using onRender() to provide a JS function to be called upon static render of a plotly object, the relevant DOM element (el) has an on() method that accepts a function to be called whenever a plotly.js (or DOM) event occurs on that DOM element. Currently all plotly.js event handlers accept a function with a single argument, and that argument either contains nothing (e.g. \"plotly_afterplot\", etc) or a single object with all the relevant information about the event (e.g. \"plotly_hover\", \"plotly_selected\", etc). Figure 28.1 logs and inspects data (d) emitted during the \"plotly_hover\", \"plotly_click\", and \"plotly_selected\" events. The object emitted for these events includes a key, named points, with information tying the selection back to the input data. The points key is always an array of object(s) where each object represents a different data point. This object contains any supplied customdata, the relevant x/y location, and a reference back to the input data. library(htmlwidgets) plot_ly(mtcars, x = ~wt, y = ~mpg) %&gt;% onRender(&quot; function(el) { el.on(&#39;plotly_hover&#39;, function(d) { console.log(&#39;Hover: &#39;, d) }); el.on(&#39;plotly_click&#39;, function(d) { console.log(&#39;Click: &#39;, d) }); el.on(&#39;plotly_selected&#39;, function(d) { console.log(&#39;Select: &#39;, d) }); } &quot;) FIGURE 28.1: Inspecting event data for hover, click, and selected events. If a click or hover event does not derive from a statistical aggregation (e.g., boxplot, histogram, etc), the points array is of length 1; otherwise, the length corresponds to how many input values are represented in the selection. In Chrome, when you log an object to the console, you can click on a link to the JS source function where you can then set breakpoints. "],
["supplying-custom-data.html", "29 Supplying custom data", " 29 Supplying custom data As covered in section 21.2, it’s often useful to supply meta-information (i.e. custom data) to graphical marker(s) and use that information when responding to a event. For example, suppose we’d like each point in a scatterplot to act like a hyperlink to a different webpage. In order to do so, we can supply a url to each point (as metadata) and instruct the browser to open the relevant hyperlink on a click event. Figure 29.1 does exactly this by supplying urls to each point in R through the customdata attribute and defining a custom JS event to window.open() the relevant url upon a click event. In this case, since each point represents one row of data, the d.point is an array of length 1, so we may obtain the url of the clicked point with d.points[0].customdata. library(htmlwidgets) p &lt;- plot_ly(mtcars, x = ~wt, y = ~mpg) %&gt;% add_markers( text = rownames(mtcars), customdata = paste0(&quot;http://google.com/#q=&quot;, rownames(mtcars)) ) onRender( p, &quot; function(el) { el.on(&#39;plotly_click&#39;, function(d) { var url = d.points[0].customdata; window.open(url); }); } &quot;) FIGURE 29.1: Attaching hyperlinks to each point in a scatterplot and using a custom JS event to open that Google search query upon clicking a point. In addition to using window.open() to open the url, we could also add it to the plot as an annotation using the plotly.js function Plotly.relayout(), as done in Figure 29.2. Moreover, since plotly annotations support HTML markup, we can also treat that url as a true HTML hyperlink by wrapping it in an HTML &lt;a&gt; tag. In cases where your JS function starts to get complex, it can help to put that JS function in its own file, then use the R function readLines() to read it in as a string and pass along onRender() as done below: onRender(p, readLines(&quot;js/hover-hyperlink.js&quot;)) Click to show the ‘js/hover-hyperlink.js’ file function(el) { el.on(&#39;plotly_hover&#39;, function(d) { var url = d.points[0].customdata; var ann = { text: &quot;&lt;a href=&#39;&quot; + url + &quot;&#39;&gt;&quot; + url + &quot;&lt;/a&gt;&quot;, x: 0, y: 0, xref: &quot;paper&quot;, yref: &quot;paper&quot;, yshift: -40, showarrow: false }; Plotly.relayout(el.id, {annotations: [ann]}); }); } FIGURE 29.2: Using Plotly.relayout() to add and change hyperlink in response to hover events. When using Plotly.relayout(), or any other plotly.js function to modify a plot, you’ll need to know the id attribute of the relevant DOM instance that you want to manipulate. When working with a single object, you can simply use el.id to access the id attribute of that DOM instance. However, when trying to target another object, it gets trickier because id attributes are randomly generated by htmlwidgets. In that case, you likely want to pre-specify the id attribute so you can reference it client-side. You can pre-specify the id for any htmlwidgets object, say widget, by doing widget$elementId &lt;- “myID”. The customdata attribute can hold any R object that can be serialized as JSON, so you could, for example, attach complex data to markers/lines/text/etc using base64 strings. This could be useful for a number of things such as displaying an image on hover or click. For security reasons, plotly.js doesn’t allow inserting images in the tooltip, but you can always define your own tooltip by hiding the tooltip (hoverinfo='none'), then populating your own tooltip with suitable manipulation of the DOM in response to \"plotly_hover\"/\"plotly_unhover\" events. Figure 29.3 demonstrates how to leverage this infrastructure to display a png image in the top-left corner of a graph whenever a text label is hovered upon.25 x &lt;- 1:3 y &lt;- 1:3 logos &lt;- c(&quot;r-logo&quot;, &quot;penguin&quot;, &quot;rstudio&quot;) # base64 encoded string of each image uris &lt;- purrr::map_chr(logos, ~ base64enc::dataURI(file = sprintf(&quot;images/%s.png&quot;, .x))) # hoverinfo = &quot;none&quot; will hide the plotly.js tooltip, but the &#39;plotly_hover&#39; event will still fire plot_ly(hoverinfo = &quot;none&quot;) %&gt;% add_text(x = x, y = y, customdata = uris, text = logos) %&gt;% htmlwidgets::onRender(readLines(&quot;js/tooltip-image.js&quot;)) Click to show the ‘js/tooltip-image.js’ file // inspired, in part, by https://stackoverflow.com/a/48174836/1583084 function(el) { var tooltip = Plotly.d3.select(&#39;#&#39; + el.id + &#39; .svg-container&#39;) .append(&quot;div&quot;) .attr(&quot;class&quot;, &quot;my-custom-tooltip&quot;); el.on(&#39;plotly_hover&#39;, function(d) { var pt = d.points[0]; // Choose a location (on the data scale) to place the image // Here I&#39;m picking the top-left corner of the graph var x = pt.xaxis.range[0]; var y = pt.yaxis.range[1]; // Transform the data scale to the pixel scale var xPixel = pt.xaxis.l2p(x) + pt.xaxis._offset; var yPixel = pt.yaxis.l2p(y) + pt.yaxis._offset; // Insert the base64 encoded image var img = &quot;&lt;img src=&#39;&quot; + pt.customdata + &quot;&#39; width=100&gt;&quot;; tooltip.html(img) .style(&quot;position&quot;, &quot;absolute&quot;) .style(&quot;left&quot;, xPixel + &quot;px&quot;) .style(&quot;top&quot;, yPixel + &quot;px&quot;); // Fade in the image tooltip.transition() .duration(300) .style(&quot;opacity&quot;, 1); }); el.on(&#39;plotly_unhover&#39;, function(d) { // Fade out the image tooltip.transition() .duration(500) .style(&quot;opacity&quot;, 0); }); } FIGURE 29.3: Displaying an image on hover in a scatterplot. It’s worth noting that the JavaScript that powers Figure 29.3 works for other cartesian charts, even heatmap (as shown in Figure 29.4), but it would need to be adapted for 3D charts types. plot_ly(hoverinfo = &quot;none&quot;) %&gt;% add_heatmap(z = matrix(1:9, nrow = 3), customdata = matrix(uris, nrow = 3, ncol = 3)) %&gt;% htmlwidgets::onRender(readLines(&quot;js/tooltip-image.js&quot;)) FIGURE 29.4: Displaying an image on hover in a heatmap. On the JS side, the customdata attribute is designed to support any JS array of appropriate length, so if you need to supply numerous custom values to particular marker(s), list-columns in R provides a nice way to do so. Figure 29.5 leverages this idea to bind both the city and sales values to each point along a time series and display those values on hover. It also demonstrates how one can use the graphical querying framework from section 20.1 in tandem with a custom JS event. That is, highlight_key() and highlight() control the highlighting of the time series, while the custom JS event adds the plot annotation (all based on the same \"plotly_hover\" event). In this case, the highlighting, annotations, and circle shapes are triggered by a \"plotly_hover\" event and they all work in tandem because event handlers are cumulative. That means, if you wanted, you could register multiple custom handlers for a particular event. library(purrr) sales_hover &lt;- txhousing %&gt;% group_by(city) %&gt;% highlight_key(~city) %&gt;% plot_ly(x = ~date, y = ~median, hoverinfo = &quot;name&quot;) %&gt;% add_lines(customdata = ~map2(city, sales, ~list(.x, .y))) %&gt;% highlight(&quot;plotly_hover&quot;) onRender(sales_hover, readLines(&quot;js/tx-annotate.js&quot;)) Click to show the ‘js/tx-annotate.js’ file function(el) { el.on(&quot;plotly_hover&quot;, function(d) { var pt = d.points[0]; var cd = pt.customdata; var num = cd[1] ? cd[1] : &quot;No&quot;; var ann = { text: num + &quot; homes were sold in &quot; + cd[0] + &quot;, TX in this month&quot;, x: 0.5, y: 1, xref: &quot;paper&quot;, yref: &quot;paper&quot;, xanchor: &quot;middle&quot;, showarrow: false }; var circle = { type: &quot;circle&quot;, xanchor: pt.x, yanchor: pt.y, x0: -6, x1: 6, y0: -6, y1: 6, xsizemode: &quot;pixel&quot;, ysizemode: &quot;pixel&quot; }; Plotly.relayout(el.id, {annotations: [ann], shapes: [circle]}); }); } FIGURE 29.5: Combining the graphical querying framework from 20.1 with the ability to define custom JS event handlers. This example also leverages the fact that customdata supports list-columns to effectively bind both the city name and number of houses sold on a particular day. Sometimes supplying and accessing customdata alone is not quite enough for the task at hand. For instance, what if we wish to add the average monthly sales to the annotation for the city of interest in Figure 29.5? In cases like this, we may need to use customdata to query a portion of the plot’s input data, like Figure 29.5 does to compute and display average sales for a given city. This implementation leverages the fact that each selected point (pt) contains a reference to the entire trace it derives from (pt.data). As discussion behind Figure ?? noted, this particular plot has a single trace and uses missing values to create separate lines for each city. As a result, pt.data.customdata contains all the customdata we supplied from the R side, so to get all the sales for a given city, we first need to filter that array down to only the elements that are belong to that city (while being careful of missing values!). onRender(sales_hover, readLines(&quot;js/tx-mean-sales.js&quot;)) Click to show the ‘js/tx-mean-sales.js’ file function(el) { el.on(&quot;plotly_hover&quot;, function(d) { var pt = d.points[0]; var city = pt.customdata[0]; // get the sales for the clicked city var cityInfo = pt.data.customdata.filter(function(cd) { return cd ? cd[0] == city : false; }); var sales = cityInfo.map(function(cd) { return cd[1] }); // yes, plotly bundles d3 which you can access via Plotly.d3 var avgsales = Math.round(Plotly.d3.mean(sales)); // Display the mean sales for the clicked city var ann = { text: &quot;Mean monthly sales for &quot; + city + &quot; is &quot; + avgsales, x: 0.5, y: 1, xref: &quot;paper&quot;, yref: &quot;paper&quot;, xanchor: &quot;middle&quot;, showarrow: false }; Plotly.relayout(el.id, {annotations: [ann]}); }); } FIGURE 29.6: Displaying the average monthly sales for a city of interest on hover. This implementation supplies all the raw sales figures, then uses the hovered customdata value to query sales for the given city and display the average. Figure 29.7 uses the same customdata supplied to Figure 29.6 in order to display a histogram of monthly sales for the relevant city on hover. In addition, it displays a vertical line on the histogram to reflect the monthly sales for the point closest to the mouse cursor. To do all this efficiently, it’s best to add the histogram trace on the first hover event using Plotly.addTraces(), then supply different sales data via Plotly.restyle() (generally speaking, restyle() is way less expensive than addTraces()). That’s why the implementation leverages the fact that the DOM element (el) contains a reference to the current graph data (el.data). If the current graph has a trace with type of histogram, then it adds a histogram trace; otherwise, it supplies new x values to the histogram. sales_hover %&gt;% onRender(readLines(&quot;js/tx-annotate.js&quot;)) %&gt;% onRender(readLines(&quot;js/tx-inset-plot.js&quot;)) Click to show the ‘js/tx-inset-plot.js’ file function(el) { el.on(&quot;plotly_hover&quot;, function(d) { var pt = d.points[0]; var city = pt.customdata[0]; // get the sales for the clicked city var cityInfo = pt.data.customdata.filter(function(cd) { return cd ? cd[0] == city : false; }); var sales = cityInfo.map(function(cd) { return cd[1] }); // Collect all the trace types in this plot var types = el.data.map(function(trace) { return trace.type; }); // Find the array index of the histogram trace var histogramIndex = types.indexOf(&quot;histogram&quot;); // If the histogram trace already exists, just supply new x values if (histogramIndex &gt; -1) { Plotly.restyle(el.id, &quot;x&quot;, [sales], histogramIndex); } else { // create the histogram var trace = { x: sales, type: &quot;histogram&quot;, marker: {color: &quot;#1f77b4&quot;}, xaxis: &quot;x2&quot;, yaxis: &quot;y2&quot; }; Plotly.addTraces(el.id, trace); // place it on &quot;inset&quot; axes var x = { domain: [0.05, 0.4], anchor: &quot;y2&quot; }; var y = { domain: [0.6, 0.9], anchor: &quot;x2&quot; }; Plotly.relayout(el.id, {xaxis2: x, yaxis2: y}); } // Add a title for the histogram var ann = { text: &quot;Monthly house sales in &quot; + city + &quot;, TX&quot;, x: 2003, y: 300000, xanchor: &quot;middle&quot;, showarrow: false }; Plotly.relayout(el.id, {annotations: [ann]}); // Add a vertical line reflecting sales for the hovered point var line = { type: &quot;line&quot;, x0: pt.customdata[1], x1: pt.customdata[1], y0: 0.6, y1: 0.9, xref: &quot;x2&quot;, yref: &quot;paper&quot;, line: {color: &quot;black&quot;} }; Plotly.relayout(el.id, {&#39;shapes[1]&#39;: line}); }); } FIGURE 29.7: Adding another event handler to Figure 29.5 to draw an inset plot showing the distribution of monthly house sales. As long as your not allowing down-stream users to input paths to the input files (e.g., in a shiny app), you shouldn’t need to worry about the security of this example↩ "],
["client-side.html", "30 Leveraging web technologies from R", " 30 Leveraging web technologies from R Sometimes supplying customdata isn’t the best way to acheive a particular interactive feature. In those cases, you likely want to leverage other R interfaces to client-side technologies. Recall from section 17.1 that htmlwidgets objects are a special case of htmltools tags. That means, you can always complement your widget(s) with arbitrary HTML content by adding additional tags. Figure 30.1 leverages this idea to place an empty HTML &lt;div&gt; container below the correlation heatmap which is then populated with a plotly scatterplot upon clicking a cell. As it turns out, you could implement Figure 30.1 by binding x/y data to each heatmap cell via customdata, but that would require the browser to store twice the amount of data as what’s required here. Instead, this approach seralizes the input data (mtcars) into a JSON file via jsonlite so the webpage can read and parse the full dataset once and select just the two required columns when required (on click). There are a lot of ways to read JSON in JavaScript, but here we use the d3.js library’s d3.json() since plotly already comes bundled with the library (Heer 2011). Also, since the HTML file is reading the JSON from disk, most browsers won’t render the HTML file directly (at least, by default, for security reasons). To get around that, we can start up a simple web server from R using servr to serve both the HTML and JSON in way that your browser will deem safe to run (Xie 2016b). library(plotly) library(htmltools) nms &lt;- names(mtcars) p &lt;- plot_ly(d, colors = &quot;RdBu&quot;) %&gt;% add_heatmap( x = nms, y = nms, z = ~round(cor(mtcars), 3) ) %&gt;% onRender(&quot; function(el) { Plotly.d3.json(&#39;mtcars.json&#39;, function(mtcars) { el.on(&#39;plotly_click&#39;, function(d) { var x = d.points[0].x; var y = d.points[0].y; var trace = { x: mtcars[x], y: mtcars[y], mode: &#39;markers&#39; }; Plotly.newPlot(&#39;filtered-plot&#39;, [trace]); }); }); } &quot;) # In a temporary directory, save the mtcars dataset as json and # the html to an index.html file, then open via a web server withr::with_path(tempdir(), { jsonlite::write_json(as.list(mtcars), &quot;mtcars.json&quot;) html &lt;- tagList(p, tags$div(id = &#39;filtered-plot&#39;)) save_html(html, &quot;index.html&quot;) if (interactive()) servr::httd() }) FIGURE 30.1: Clicking on a correlation matrix to populate a scatterplot. All the JavaScript we’ve seen thus far is natively supported by modern web browsers, but for larger projects, you may want to leverage modern versions of JS (e.g, ES6) and modern JS development tools for compiling said JS to code that all browsers can support (e.g. Babel, Webpack, etc). The current landscape of JS development tooling is large, complex, fragmented, difficult for non-experts to navigate, and mostly beyond the scope of this book. Thankfully, popular JS libraries often provide a ‘standalone’ JS bundle which allows direct use their library without having to install and learn a bunch of new technology. Moreover, these bundles are likely available through a CDN service like https://unpkg.com/, https://www.cloudflare.com/cdn, etc. The R package runpkg makes it easy to download files from https://unpkg.com/ and include them in web pages generated through the htmltools package (Sievert 2019). It does this by returning a htmltools::htmlDependency() object which encapsulates the downloaded files and includes the JS scripts (or CSS stylesheets) into any page that depends on that object. Here we use it to download a standalone bundle of a popular React library for rendering all sort of different video formats, called react-player. React is hugely popular JavaScript framework that makes it easy to bundle and re-use components, so this same general idea could be reused to leverage other components.26 library(runpkg) react_player &lt;- download_files(&quot;react-player&quot;, &quot;dist/ReactPlayer.standalone.js&quot;) This react-player library provides a function called renderReactPlayer() that requires a placeholder (i.e., a DOM element) for inserting the video as well as a url (or file path) to the video. library(htmltools) # the video placeholder video &lt;- tags$div(id = &quot;video&quot;) # upon clicking the marker, populate a video # in the DOM element with an id of &#39;video&#39; p &lt;- plot_ly(x = 1, y = 1, size = I(50)) %&gt;% add_text( text = &quot;🤣&quot;, customdata = &quot;https://www.youtube.com/watch?v=oHg5SJYRHA0&quot;, hovertext = &quot;Click me!&quot;, hoverinfo = &quot;text&quot; ) %&gt;% onRender( &quot;function(gd) { var container = document.getElementById(&#39;video&#39;); gd.on(&#39;plotly_click&#39;, function(d) { var url = d.points[0].customdata; renderReactPlayer(container, {url: url, playing: true}); }) }&quot; ) # create the HTML page browsable(tagList(p, video, react_player)) FIGURE 30.2: Populating a video in response to a 'plotly_click' event. If you’re not lucky enough to be working with a JS library that provides a standalone library and/or if you want to leverage some of the features of modern JS (e.g., namespacing, tree-shaking, async+await, etc), then you may have to dive into node.js (i.e., server-side JavaScript) command-line tools like npm, yarn, and webpack. As it turns out, though, R packages like V8 and reactR are making it easier to leverage server-side JavaScript from R with minimal fuss. The V8 package provides a low-level interface to a JS runtime that allows you run server-side JavaScript from R (Ooms 2017). V8 provides a foundation for packages like reactR to provide functions like babel_transform() which compile modern JS (e.g., ES6, ES2017, etc) code to a version of JavaScript that all browsers support (e.g., ES5) (Inc, Russell, and Dipert 2019). For a simple example, Figure 30.3 demonstrates how one could leverage ES6, React, and JSX syntax to populate a &lt;h1&gt; title filled with a customdata message in response to a 'plotly_click' event. library(reactR) # a message placeholder msg &lt;- tags$div(id = &quot;msg&quot;) p &lt;- plot_ly(x = 1, y = 1) %&gt;% add_markers(customdata = &quot;Powered by React&quot;) %&gt;% onRender(babel_transform( &quot;gd =&gt; { gd.on(&#39;plotly_click&#39;, d =&gt; { let msg = d.points[0].customdata; ReactDOM.render( &lt;h1&gt;{msg}&lt;/h1&gt;, document.getElementById(&#39;msg&#39;) ); }); }&quot; ), validate = TRUE) # create the HTML page browsable(tagList( p, msg, html_dependency_corejs(), html_dependency_react() )) FIGURE 30.3: Using babel_transform() to leverage ES6, React, and JSX. References "],
["is-plotly-free.html", "31 Is plotly free?", " 31 Is plotly free? Yes! Both the R package and the underlying JavaScript library (plotly.js) are MIT licensed. That means you are free to distribute and commericalize anything you create with plotly. Optionally, you can sign up for a https://plot.ly account and use the api_create() function to upload plotly graphs to your account, but a https://plot.ly account is not required to use plotly. "],
["is-my-data-secure.html", "32 Is my data secure?", " 32 Is my data secure? Yes! The data behind a plotly graph won’t leave your computer unless you: You sign up for a plotly cloud account and use the api_create() function to upload your graph or data. This service is free for public-facing graphs, but private hosting costs money. You add the ‘send data to cloud’ modebar button. By default, this button is not included, but you can add it by doing config(p, cloud = TRUE). In other words, unless you specifically request otherwise, your graph runs entirely offline (i.e. no requests to external services are made). That means you can be confident that your data is not being shared with anyone/anything without your knowledge. "],
["tooltip-text.html", "33 Control tooltip text", " 33 Control tooltip text There are two main approaches to controlling the tooltip: hoverinfo and hovertemplate. I suggest starting with the former approach since it’s simpler, more mature, and enjoys universal support across trace types. On the other hand, hovertemplate does offer a convenient approach for flexible control over tooltip text, so it can be useful as well. The hoverinfo attribute controls what other plot attributes are shown into the tooltip text. The default value of hoverinfo is x+y+text+name (you can verify this with schema()), meaning that plotly.js will use the relevant values of x, y, text, and name to populate the tooltip text. As in Figure 33.1 shows, you can supply custom text (without the other ‘calculated values’) by supplying a character string text and setting hoverinfo = \"text\". The character string can include Glyphs, unicode characters, a some (white-listed) HTML entities and tags.27 At least currently, plotly.js doesn’t support rendering of LaTeX or images in the tooltip, but as demonstrated in Figure 29.3, if you know some HTML/JavaScript, you can always build your own custom tooltip. library(tibble) library(forcats) tooltip_data &lt;- tibble( x = &quot; &quot;, y = 1, categories = as_factor(c(&quot;Glyphs&quot;, &quot;HTML tags&quot;, &quot;Unicode&quot;, &quot;HTML entities&quot;, &quot;A combination&quot;)), text = c( &quot;👋 glyphs ಠ_ಠ&quot;, &quot;Hello &lt;span style=&#39;color:red&#39;&gt;&lt;sup&gt;1&lt;/sup&gt;⁄&lt;sub&gt;2&lt;/sub&gt;&lt;/span&gt; fraction&quot;, &quot;\\U0001f44b unicode \\U00AE \\U00B6 \\U00BF&quot;, &quot;&amp;mu; &amp;plusmn; &amp;amp; &amp;lt; &amp;gt; &amp;nbsp; &amp;times; &amp;plusmn; &amp;deg;&quot;, paste(&quot;&lt;b&gt;Wow&lt;/b&gt; &lt;i&gt;much&lt;/i&gt; options&quot;, emo::ji(&quot;dog2&quot;), &quot;(╯°□°）╯︵ ┻┻&quot;) ) ) plot_ly(tooltip_data, hoverinfo = &quot;text&quot;) %&gt;% add_bars( x = ~x, y = ~y, color = ~fct_rev(categories), text = ~text ) %&gt;% layout( barmode =&quot;stack&quot;, hovermode = &quot;x&quot; ) FIGURE 33.1: Customizing the tooltip by supplying glyphs, Unicode, HTML markup to the text attributes and restricting displayed attributes with hoverinfo='text'. Whenever a fill is relevant (e.g., add_sf(), add_polygons(), add_ribbons(), etc), you have the option of using the hoveron attribute to generate a tooltip for the supplied data points, the filled polygon that those points define, or both. As Figure 33.2 demonstrates, if you want a tooltip attached to a fill, you probably want text to be of length 1 for a given trace. On the other hand, if you want to each point along a fill to have a tooltip, you probably want text to have numerous strings. p &lt;- plot_ly( x = c(1, 2, 3), y = c(1, 2, 1), fill = &quot;toself&quot;, mode = &quot;markers+lines&quot;, hoverinfo = &quot;text&quot; ) subplot( add_trace(p, text = &quot;triangle&quot;, hoveron = &quot;fills&quot;), add_trace(p, text = paste0(&quot;point&quot;, 1:3), hoveron = &quot;points&quot;) ) FIGURE 33.2: Using the hoveron attribute to control whether a tooltip is attached to fill or each point along that fill. You can’t supply custom text in this way to a statistical aggregation, but there are ways to control the formatting of values computed and displayed by plotly.js (e.g. x, y, and z). If the value that you’d like to format corresponds to an axis, you can use *axis.hoverformat. The syntax behind hoverformat follows d3js’ format conventions. For numbers, see: https://github.com/d3/d3-format/blob/master/README.md#locale_format and for dates see: https://github.com/d3/d3-time-format/blob/master/README.md#locale_format set.seed(1000) plot_ly(x = rnorm(100), name = &quot; &quot;) %&gt;% add_boxplot(hoverinfo = &quot;x&quot;) %&gt;% layout(xaxis = list(hoverformat = &quot;.2f&quot;)) FIGURE 33.3: Using xaxis.hoverformat to round aggregated values displayed in the tooltip to two decimal places. Computed values that don’t have a corresponding axis likely have a *hoverformat trace attribute. Probably the most common example is the z attribute in a heatmap or histogram2d chart. Figure 33.4 shows how to format z values to have one decimal. plot_ly(z = ~volcano) %&gt;% add_heatmap(zhoverformat = &quot;.1f&quot;) %&gt;% layout(xaxis = list(hoverformat = &quot;.2f&quot;)) FIGURE 33.4: Formatting the displayed z values in a heatmap using zhoverformat. It’s admittedly difficult to remember where to specify these hoverformat attributes, so if you want a combination of custom text and formatting of computed values you can use hovertemplate, which overrides hoverinfo and allows you to fully specify the tooltip in one consistent location. For a full description of this attribute, see https://plot.ly/r/reference/#scatter-hovertemplate. set.seed(10) plot_ly(x = rnorm(100, 0, 1e5)) %&gt;% add_histogram( histnorm = &quot;density&quot;, hovertemplate = &quot;The height is %{y:.1e} &lt;extra&gt;That&#39;s very small!&lt;/extra&gt;&quot; ) FIGURE 33.5: Using the hovertemplate attribute to reference computed variables and their display format inside a custom string. If you need really specific control over the tooltip, you might consider hiding the tooltip altogether (using hoverinfo='none') and defining your own tooltip. Defining your own tooltip, however, will require knowledge of HTML and JavaScript – see Figure 29.3 for an example of how to display an image on hover instead of a tooltip. If you find a tag or entity that you want isn’t supported, please request it to be added in the plotly.js repo https://github.com/plotly/plotly.js/issues/new↩ "],
["tooltip-text-ggplotly.html", "34 Control ggplotly() tooltips", " 34 Control ggplotly() tooltips Similar to how you can use the text attribute to supply a custom string in plot_ly() (see Section 33), you can supply a text aesthetic to your ggplot2 graph, as shown in 34.1: p &lt;- ggplot(mtcars, aes(wt, mpg, text = row.names(mtcars))) + geom_point() ggplotly(p) FIGURE 34.1: Using the text ggplot2 aesthetic to supply custom tooltip text to By default, ggplotly() will display all relevant aesthetic mappings (or computed values), but you can restrict what aesthetics are used to populate the tooltip, as shown in Figure 34.2: ggplotly(p, tooltip = &quot;text&quot;) FIGURE 34.2: Using the tooltip arugment in ggplotly() to only display the text aesthetic. When constructing the text to display, ggplotly() runs format() on the computed values. Since some parameters of the format() function can be controlled through global options(), you can use these options() to control the displayed text. This includes the digits option for controlling the number of significant digits used for numerical values as well as scipen for setting a penalty for deciding whether scientific or fixed notation is used for displaying. Figure 34.3 shows how you can temporarily set these options (i.e., avoid altering of your global environment) using the withr package (Hester et al. 2018). library(withr) p &lt;- ggplot(faithfuld, aes(waiting, eruptions)) + geom_raster(aes(fill = density)) subplot( with_options(list(digits = 1), ggplotly(p)), with_options(list(digits = 6, scipen = 20), ggplotly(p)) ) FIGURE 34.3: Leveraging global R options for controlling the displayed values in a ggplotly() tooltip. These global options are nice for specifying significant/scientific notation, but what about more sophisicated formatting? Sometimes a clever use of the text aesthetic provides a sufficient workaround. Specifically, as Figure 34.4 shows, if one wanted to control a displayed aesthetic value (e.g., y), one could generate a custom string from that variable and supply it to text, then essentially replace text for y in the tooltip: library(scales) p &lt;- ggplot(txhousing, aes(date, median)) + geom_line(aes(group = city, text = paste(&quot;median:&quot;, number_si(median)))) ggplotly(p, tooltip = c(&quot;text&quot;, &quot;x&quot;, &quot;city&quot;)) FIGURE 34.4: Using the text aesthetic to replace an auto-generated aesthetic (y). The approach depicted in Figure 34.4 works for computed values that pertain to raw data values, but what about sophisicated formatting of a summary statistics generated by ggplot2? In this case, you’ll have to use the return value of ggplotly() which, remember, is a plotly object that conforms to the plotly.js spec. That means you can identify trace attribute(s) that contain relevant info (note: the plotly_json() function is incredibly for helping to find that information), then use that info to populate a text attribute. Figure 34.5 applies this technique to customize the text that appears when hovering over a geom_smooth() line. # Add a smooth to the previous figure and convert to plotly w &lt;- ggplotly(p + geom_smooth(se = FALSE)) # This plotly object has two traces: one for # the raw time series and one for the smooth. # Try using `plotly_json(w)` to confirm the 2nd # trace is the smooth line. length(w$x$data) # use the `y` attribute of the smooth line # to generate a custom string (to appear in tooltip) text_y &lt;- number_si( w$x$data[[2]]$y, prefix = &quot;Typical median house price: $&quot; ) # suppress the tooltip on the raw time series # and supply custom text to the smooth line w %&gt;% style(hoverinfo = &quot;skip&quot;, traces = 1) %&gt;% style(text = text_y, traces = 2) FIGURE 34.5: Using the return value of ggplotly() to populate a custom text attribute. References "],
["control-tooltip-styling.html", "35 Control tooltip styling", " 35 Control tooltip styling There is currently one main attribute for controlling the style of a tooltip: hoverlabel. With this attribute you can currently set the background color (bgcolor), border color (bordercolor), and font family/size/color. Figure 35.1 demonstrates how to use it with plot_ly() (basically any chart type you use should support it): font &lt;- list( family = &quot;Roboto Condensed&quot;, size = 15, color = &quot;white&quot; ) label &lt;- list( bgcolor = &quot;#232F34&quot;, bordercolor = &quot;transparent&quot;, font = font ) plot_ly(x = iris$Petal.Length, hoverlabel = label) FIGURE 35.1: Using the hoverlabel attribute to customize the color and font of the tooltip. On the other hand, when using ggplotly(), you have to modfy the hoverlabel attribute via style() as shown in Figure 35.2 qplot(x = Petal.Length, data = iris) %&gt;% ggplotly() %&gt;% style(hoverlabel = label, marker.color = &quot;#232F34&quot;) %&gt;% layout(font = font) FIGURE 35.2: Using the hoverlabel attribute with ggplotly(). As shown in sections 33 and 34 the approach to customized the actual text of a tooltip is slightly different depending on whether you’re using ggplotly() or plot_ly(), but styling the appearance of the tooltip is more or less the same in either approach. "],
["control-axis-labels.html", "36 Control axis labels", " 36 Control axis labels TODO: * using factors to control ordering of axis labels * specifying your own tickvals/ticktext? * discuss pros and cons "],
["locales.html", "37 Language support", " 37 Language support The locale argument of the config() function allows one to render on-graph text using another language. Figure 37.1 shows how setting locale='ja' will render text in Japanese. today &lt;- Sys.Date() x &lt;- seq.Date(today, today + 360, by = &quot;day&quot;) plot_ly(x = x, y = rnorm(length(x))) %&gt;% add_lines() %&gt;% config(locale = &quot;ja&quot;) FIGURE 37.1: Using the locale argument of the config() function to render on-graph text in another language. Table 37.1 contains a list of all the supported locale codes and the language they correspond to: TABLE 37.1: Language support in plotly. To use one of these languages, supply the locale code to the locale argument in the config() function. "],
["mathjax.html", "38 LaTeX rendering 38.1 MathJax caveats", " 38 LaTeX rendering LaTeX rendering via MathJax is possible via the TeX() function which flags a character vector as LaTeX. To load MathJaX externally (meaning an internet connection is needed for TeX rendering), set the new mathjax argument in config() to \"cdn\". Figure 38.1 demonstrates how to render LaTeX in the plot and axis titles. library(plotly) data(co2, package = &quot;datasets&quot;) plot_ly() %&gt;% add_lines(x = zoo::index(co2), y = co2) %&gt;% layout( title = TeX(&quot;CO_2 \\\\text{measured in } \\\\frac{parts}{million}&quot;), xaxis = list(title = &quot;Time&quot;), yaxis = list(title = TeX(&quot;\\\\text{Atmospheric concentraion of CO}_2&quot;)) ) %&gt;% config(mathjax = &quot;cdn&quot;) FIGURE 38.1: Rendering LaTeX in the plot and axis titles. Figure 38.2 demonstrates how to render LaTeX with on-graph text. There are two ways to draw on-graph text: add_text() which is a scatter trace with a mode of text and add_annotations() which is part of the graph’s layout. The main difference is that add_text() is able to display tooltips and add_annotations() is able to display arrows. plotly_empty(showlegend = FALSE, hoverinfo = &quot;x+y&quot;) %&gt;% add_annotations(x = 1, y = 2, text = TeX(&quot;\\\\text{The sample mean:} \\\\sum_{i=1}^n x_i \\\\text{ where}&quot;), showarrow = FALSE) %&gt;% add_text(x = 1, y = 1, text = TeX(&quot;x_i \\\\sim N(\\\\mu, \\\\sigma)&quot;), size = I(100)) %&gt;% add_annotations(x = 1, y = 0, text = TeX(&quot;E[x_i]&quot;)) %&gt;% add_text(x = 1, y = 0, text = TeX(&quot;\\\\mu&quot;), textposition = &quot;bottom&quot;) %&gt;% config(mathjax = &quot;cdn&quot;) FIGURE 38.2: Rendering LaTeX using add_text() and add_annotations(). To use a local version of MathJax (so that your graphs will render without an internet connection), you need to inform plotly where it’s located. If you don’t already have MathJax locally, I recommend downloading the official MathJax git repo. Here’s how to do that using terminal commands: $ git clone https://github.com/mathjax/MathJax.git $ cd MathJax Now set the PLOTLY_MATHJAX_PATH environment variable so that plotly knows where that MathJax folder lives. I recommend setting this variable in you .Rprofile so you don’t have to reset it everytime you restart R: $ export PLOTLY_MATHJAX_PATH=`pwd` $ echo &quot;Sys.setenv(&#39;PLOTLY_MATHJAX_PATH&#39; = &#39;$PLOTLY_MATHJAX_PATH&#39;)&quot; &gt;&gt; ~/.Rprofile Finally, once PLOTLY_MATHJAX_PATH is set, specify mathjax=\"local\" in config(): config(last_plot(), mathjax=&quot;local&quot;) 38.1 MathJax caveats MathJax rendering in tooltips currently isn’t supported. At least currently, plotly.js requires SVG-based rendering which doesn’t play nicely with HTML-based rendering (e.g. rmarkdown documents and shiny apps) . If you need both the SVG and HTML rendering, consider &lt;iframe&gt;-ing your plotly graph(s) into the larger document (see here for an example). Due to the size and nature of MathJax, using htmlwidget::saveWidget() with selfcontained = TRUE won’t work. At least for now, when you need to save a plotly graph (p) with local MathJax, do htmlwidget::saveWidget(p, selfcontained = FALSE) "],
["working-with-colors.html", "39 Working with colors", " 39 Working with colors The JavaScript library underlying plotly (plotly.js) has it’s own support for specifying colors, which is different from how R specifies colors. It currently supports: hex (e.g. \"#FF0000\") rgb (e.g. \"rgb(255, 0, 0)\") rgba (e.g. \"rgba(255, 0, 0, 1)\") hsl (e.g. 'hsl(0, 100%, 50%)') hsv (e.g. 'hsv(0, 100%, 50%)') Named CSS3 colors http://www.w3.org/TR/css3-color/#svg-color If you use plot_ly() and directly specify a plotly.js color attribute (e.g. marker.color), you can use any of these formats. Figure 39.1 uses the the hsl format: plot_ly(x = iris$Petal.Length, marker = list(color = &quot;hsl(0, 100%, 50%)&quot;)) FIGURE 39.1: Specifying a color in plotly.js’ supported format If you’re doing something specific to R, like using ggplotly() and/or the top-level color/stroke argument in plot_ly(), you’ll need to be careful to about specifying colors in way that R and plotly can understand. For example, at least currently, you can’t specify an hsl string in this way: plot_ly(x = 1, y = 1, color = I(&quot;hsl(0, 100%, 50%)&quot;)) #&gt; Error in grDevices::col2rgb(x, alpha = TRUE): invalid color name &#39;hsl(0, 100%, 50%)&#39; Just like in ggplot2, you’ll have to specify a color in one of the following ways: A hexadecimal string of the form “#rrggbb” or “#rrggbbaa”. Named colors (e.g. “blue”). All supported names are listed in colors(). An NA for transparent. This doesn’t imply that you can’t work in other colorspaces though (e.g. rgb, rgba, hsl, or hsl). The colorspace package provides a nice way to create colors in any of these colorspaces and provides a hex() function that you can use to convert any color to a hexidecimal format (Ihaka et al. 2019). library(colorspace) red &lt;- hex(HLS(0, 0.5, 1)) plot_ly(x = iris$Petal.Length, color = I(red)) If you’d like to learn more about how to use the color argument as well as specify different types of color palettes, see Section 4. References "],
["working-with-symbols-glyphs.html", "40 Working with symbols &amp; glyphs", " 40 Working with symbols &amp; glyphs The JavaScript library underlying plotly (plotly.js) has it’s own special support for specifying marker symbols by name. As Figure 40.1 shows, there are currently many acceptable marker.symbol values, and all the acceptable values can be accessed through plotly.js’ schema(). s &lt;- schema() vals &lt;- grep(&quot;-&quot;, s$traces$scatter$attributes$marker$symbol$values, value = T) plot_ly() %&gt;% add_markers( x = rep(1:12, each = 11, length.out = length(vals)), y = rep(1:11, times = 12, length.out = length(vals)), text = vals, hoverinfo = &quot;text&quot;, marker = list( symbol = vals, size = 30, line = list( color = &quot;black&quot;, width = 2 ) ) ) FIGURE 40.1: All marker symbols currently supported by plotly. In addition to these marker symbols, you can also use add_text() to encode data with on-graph text. Moreover, the add_text() function (i.e. a scatter trace with mode=\"markers\") enjoys a lot of the same properties as add_markers() (i.e. a scatter trace with mode=\"text\"). As Figure 40.2 shows, similar to how we can supply typographical glyphs and/or unicode in a custom tooltip, you can supply a character vector of similar content to add_text() (i.e. a scatter trace with mode='text') which renders on-graph text. Furthermore, when using text to render on-graph text, one can leverage the hovertext attribute to display some different text on hover. plot_ly() %&gt;% add_text( x = rep(2, 2), y = 1:2, size = I(15), text = c( &quot;Glyphs: Ѳ, （╯°□°）╯ ┻━┻&quot;, &quot;Unicode: \\U00AE \\U00B6 \\U00BF&quot; ), hovertext = c( &quot;glyphs&quot;, &quot;unicode&quot; ), textposition = &quot;left center&quot;, hoverinfo = &quot;text&quot; ) FIGURE 40.2: Using add_text() to render on-graph text with typographical glyphs and/or unicode. Having the ability to encode data with unicode means that we have a virtually endless number of ways to encode data in symbols/glyphs. Just for fun, Figure 40.3 demonstrates how you could plot all the activity emojis using the emo package and display the name of the emoji on hover (Wickham, François, and D’Agostino McGowan 2018). library(emo) set.seed(100) jis %&gt;% filter(group == &quot;Activities&quot;) %&gt;% plot_ly(x = runif(nrow(.)), y = runif(nrow(.))) %&gt;% add_text( text = ~emoji, hovertext = ~name, hoverinfo = &quot;text&quot;, size = I(20) ) FIGURE 40.3: Using add_text() to plot all the activity emojis and leveraging hovertext to place the emoji names in the tooltip text. References "],
["customize-the-modebar.html", "41 Customize the modebar 41.1 Remove the entire modebar 41.2 Remove the plotly logo 41.3 Remove modebar buttons by name 41.4 Add custom modebar buttons 41.5 Control image downloads 41.6 The data-plot-pipeline", " 41 Customize the modebar By default, the modebar appears in the top right-hand side of a plotly graph on mouse hover, and can lead to poor user-experience on small displays. Fortunately, the modebar can be completely customized via the config() function. The config() function can be helpful for a lot of things: language support (Section 37), enabling mathjax (Section 38), suppressing tip dialogs (e.g., showTips), when to scroll on zoom, etc. However, this topic is all about options related to the modebar. To see a complete list of config() options, as well as their description, see the config section of the plotly.js schema(). 41.1 Remove the entire modebar The displayModeBar option makes it quick and easy to remove the entire modebar. plot_ly() %&gt;% config(displayModeBar = FALSE) 41.2 Remove the plotly logo The displaylogo option makes it quick and easy to remove the entire modebar. plot_ly() %&gt;% config(displaylogo = FALSE) FIGURE 41.1: Removing the plotly logo from the modebar. 41.3 Remove modebar buttons by name Any modebar buttons can be removed by name via modeBarButtonsToRemove. The current list of modebar buttons can be found at https://github.com/plotly/plotly.js/blob/master/src/components/modebar/buttons.js plot_ly() %&gt;% config(modeBarButtonsToRemove = c(&quot;zoomIn2d&quot;, &quot;zoomOut2d&quot;)) FIGURE 41.2: Removing the ‘zoomIn2d’ and ‘zoomOut2d’ modebar buttons by name. 41.4 Add custom modebar buttons It is possible to supply your own modebar button icon that triggers a custom JavaScript function when clicked. You must provide a name for the icon and either a SVG path (with just the d attribute) or a full SVG element (to svg). Nowadays, there are a number of free websites that allow you to search icons and download their corresponding SVG information. When supplying path, as in Figure 41.3, you can also define an SVG transform to help size and position the icon. To define a JavaScript function to call upon clicking the icon, you can provide a string to htmlwidgets::JS(). The interactive version of Figure 41.3 adds on-graph text everytime the octocat icon is clicked. To learn more about how to leverage JavaScript from R, see Section 26. octocat &lt;- list( name = &quot;octocat&quot;, icon = list( path = &quot;M24.92 12.183c0-1.586-.604-2.864-1.585-3.83.172-.547.398-1.763-.229-3.321 0 0-1.114-.348-3.628 1.315a12.695 12.695 0 0 0-3.081-.366c-1.154 0-2.322.143-3.409.44-2.596-1.747-3.74-1.391-3.74-1.391-.748 1.847-.287 3.215-.145 3.554-.883.936-1.414 2.133-1.414 3.594 0 1.111.128 2.099.44 2.964l.325.732c.879 1.614 2.606 2.655 5.677 2.983-.434.289-.885.779-1.062 1.612-.594.28-2.475.966-3.603-.944 0 0-.633-1.148-1.842-1.235 0 0-1.174-.017-.08.722 0 0 .782.367 1.326 1.738 0 0 .705 2.342 4.114 1.593v2.417s-.076.857-.867 1.143c0 0-.469.312.034.497 0 0 2.205.174 2.205-1.604v-2.643s-.09-1.047.429-1.404v4.332s-.032 1.031-.576 1.421c0 0-.362.646.433.468 0 0 1.517-.211 1.584-1.967l.035-4.383h.363l.033 4.383c.076 1.748 1.59 1.967 1.59 1.967.793.179.429-.468.429-.468-.54-.389-.579-1.421-.579-1.421v-4.297c.52.402.436 1.369.436 1.369v2.643c0 1.777 2.2 1.604 2.2 1.604.505-.186.036-.498.036-.498-.793-.286-.867-1.143-.867-1.143v-3.461c0-1.346-.574-2.056-1.137-2.435 3.277-.318 4.845-1.368 5.572-2.99-.015.027.26-.726.26-.726.25-.859.325-1.855.325-2.963h-.002z&quot;, transform = &#39;matrix(1 0 0 1 -2 -2) scale(0.7)&#39; ), click = htmlwidgets::JS( &quot;function(gd) { var txt = {x: [1], y: [1], text: &#39;Octocat!&#39;, mode: &#39;text&#39;}; Plotly.addTraces(gd, txt); }&quot; ) ) plot_ly() %&gt;% config(modeBarButtonsToAdd = list(octocat)) FIGURE 41.3: Supplying a custom modebar button with custom behavior. Note that you can also use modeBarButtons to completely specify which buttons to include in the modebar. With this option, you can supply existing button names and/or your own custom buttons: plot_ly() %&gt;% config(modeBarButtons = list(list(&quot;zoomIn2d&quot;), list(octocat))) FIGURE 41.4: Specifying the full list of modebar buttons. 41.5 Control image downloads By default, the toImage modebar button downloads a png file using the current size and state of the graph. With toImageButtonOptions, one can specify different sizes and filetypes, which is particularly useful for obtaining a static pdf/webp/jpeg/etc image of the plot after components have been directly manipulated, as leveraged in Figure 16.1. Here’s a basic example of configuring the 'toImage' button to download an svg file that’s 200 x 100 pixels: plot_ly() %&gt;% config( toImageButtonOptions = list( format = &quot;svg&quot;, width = 200, height = 100 ) ) After downloading the svg file, you can convert it to pdf using the rsvg_pdf() function from the rsvg package (Ooms 2018). 41.6 The data-plot-pipeline Since every plotly function modifies a plotly object (or the data underlying that object), we can express complex multi-layer plots as a sequence (or, more specifically, a directed acyclic graph) of data manipulations and mappings to the visual space. Moreover, plotly functions are designed to take a plotly object as input, and return a modified plotly object, making it easy to chain together operations via the pipe operator (%&gt;%) from the magrittr package (Bache and Wickham 2014). Consequently, we can re-express Figure ?? in a much more readable and understandable fashion. allCities &lt;- txhousing %&gt;% group_by(city) %&gt;% plot_ly(x = ~date, y = ~median) %&gt;% add_lines(alpha = 0.2, name = &quot;Texan Cities&quot;, hoverinfo = &quot;none&quot;) allCities %&gt;% filter(city == &quot;Houston&quot;) %&gt;% add_lines(name = &quot;Houston&quot;) Sometimes the directed acyclic graph property of a pipeline can be too restrictive for certain types of plots. In this example, after filtering the data down to Houston, there is no way to recover the original data inside the pipeline. The add_fun() function helps to work-around this restriction28 – it works by applying a function to the plotly object, but does not affect the data associated with the plotly object. This effectively provides a way to isolate data transformations within the pipeline29. Figure 41.5 uses this idea to highlight both Houston and San Antonio. allCities %&gt;% add_fun(function(plot) { plot %&gt;% filter(city == &quot;Houston&quot;) %&gt;% add_lines(name = &quot;Houston&quot;) }) %&gt;% add_fun(function(plot) { plot %&gt;% filter(city == &quot;San Antonio&quot;) %&gt;% add_lines(name = &quot;San Antonio&quot;) }) FIGURE 41.5: Monthly median house price in Houston and San Antonio in comparison to other Texan cities. It is useful to think of the function supplied to add_fun() as a “layer” function – a function that accepts a plot object as input, possibly applies a transformation to the data, and maps that data to visual objects. To make layering functions more modular, flexible, and expressive, the add_fun() allows you to pass additional arguments to a layer function. Figure 41.6 makes use of this pattern, by creating a reusable function for layering both a particular city as well as the first, second, and third quartile of median monthly house sales (by city). # reusable function for highlighting a particular city layer_city &lt;- function(plot, name) { plot %&gt;% filter(city == name) %&gt;% add_lines(name = name) } # reusable function for plotting overall median &amp; IQR layer_iqr &lt;- function(plot) { plot %&gt;% group_by(date) %&gt;% summarise( q1 = quantile(median, 0.25, na.rm = TRUE), m = median(median, na.rm = TRUE), q3 = quantile(median, 0.75, na.rm = TRUE) ) %&gt;% add_lines(y = ~m, name = &quot;median&quot;, color = I(&quot;black&quot;)) %&gt;% add_ribbons(ymin = ~q1, ymax = ~q3, name = &quot;IQR&quot;, color = I(&quot;black&quot;)) } allCities %&gt;% add_fun(layer_iqr) %&gt;% add_fun(layer_city, &quot;Houston&quot;) %&gt;% add_fun(layer_city, &quot;San Antonio&quot;) FIGURE 41.6: First, second, and third quartile of median monthly house price in Texas. A layering function does not have to be a data-plot-pipeline itself. Its only requirement on a layering function is that the first argument is a plot object and it returns a plot object. This provides an opportunity to say, fit a model to the plot data, extract the model components you desire, and map those components to visuals. Furthermore, since plotly’s add_*() functions don’t require a data.frame, you can supply those components directly to attributes (as long as they are well-defined), as done in Figure 41.7 via the forecast package (Hyndman, n.d.). library(forecast) layer_forecast &lt;- function(plot) { d &lt;- plotly_data(plot) series &lt;- with(d, ts(median, frequency = 12, start = c(2000, 1), end = c(2015, 7)) ) fore &lt;- forecast(ets(series), h = 48, level = c(80, 95)) plot %&gt;% add_ribbons(x = time(fore$mean), ymin = fore$lower[, 2], ymax = fore$upper[, 2], color = I(&quot;gray95&quot;), name = &quot;95% confidence&quot;, inherit = FALSE) %&gt;% add_ribbons(x = time(fore$mean), ymin = fore$lower[, 1], ymax = fore$upper[, 1], color = I(&quot;gray80&quot;), name = &quot;80% confidence&quot;, inherit = FALSE) %&gt;% add_lines(x = time(fore$mean), y = fore$mean, color = I(&quot;blue&quot;), name = &quot;prediction&quot;) } txhousing %&gt;% group_by(city) %&gt;% plot_ly(x = ~date, y = ~median) %&gt;% add_lines(alpha = 0.2, name = &quot;Texan Cities&quot;, hoverinfo = &quot;none&quot;) %&gt;% add_fun(layer_iqr) %&gt;% add_fun(layer_forecast) FIGURE 41.7: Layering on a 4-year forecast from a exponential smoothing state space model. In summary, the “data-plot-pipeline” is desirable for a number of reasons: (1) makes your code easier to read and understand, (2) encourages you to think of both your data and plots using a single, uniform data structure, which (3) makes it easy to combine and reuse transformations. As it turns out, we can even use these ideas when creating a plotly object via ggplotly(), as discussed in the next section Extending ggplotly(). References "],
["facets-with-subplot.html", "42 Facets with subplot()", " 42 Facets with subplot() library(plotly) library(dplyr) my_plot &lt;- . %&gt;% plot_ly(x = ~date, y = ~value) %&gt;% add_annotations( text = ~unique(variable), x = 0.5, y = 1, yref = &quot;paper&quot;, xref = &quot;paper&quot;, xanchor = &quot;middle&quot;, yanchor = &quot;top&quot;, showarrow = FALSE, font = list(size = 15) ) %&gt;% layout( shapes = list( type = &quot;rect&quot;, x = 0, x = 1 ) ) economics_long %&gt;% group_by(variable) %&gt;% do(p = my_plot(.)) %&gt;% subplot(nrows = NROW(.), shareX = TRUE) "],
["control-axes.html", "43 Control axes", " 43 Control axes Anything better to say than https://plot.ly/r/axes/? "],
["improving-performance-optimizing-views.html", "44 Improving performance (optimizing views?)", " 44 Improving performance (optimizing views?) Define print-time vs run-time performance. 44.0.1 SVG vs WebGL Borrow examples from workshop? Borrow from maps blog post? 44.0.2 Reducing runtime dependencies Point to partial_bundle() use in publishing "],
["why-is-my-plot-blank.html", "45 Why is my plot blank?", " 45 Why is my plot blank? There are numerous reasons why your plot may not render. Malformed group definition Talk about WebGL compatibility in browsers (e.g. RStudio) R developers that have authored a custom ggplot2 geom and want to inform ggplotly() about the rendering rules of their geom. R developers that want to build a similar interface to another JavaScript graphing library. "],
["translating-custom-ggplot2-geoms.html", "46 Translating custom ggplot2 geoms", " 46 Translating custom ggplot2 geoms Version 2.0.0 of ggplot2 introduced a way for other R packages to implement custom geoms. Some great examples include: ggrepel, ggalt, ggraph, geomnet, ggmosaic and ggtern (Rudis 2016); (Pedersen 2016); (Tyner and Hofmann 2016); (Jeppson, Hofmann, and Cook 2016); (Hamilton 2016).30 Although the ggplotly() function translates most of the geoms bundled with the ggplot2 package, it has no way of knowing about the rendering rules for custom geoms. The plotly package does, however, provide 2 generic functions based on the S3 scheme that can leveraged to inform ggplotly() about these rules (Chambers 1992).31 To date, the ggmosaic and ggalt packages have taken advantage of this infrastructure to provide translations of their custom geoms to plotly. In ggplot2, many geoms are special cases of other geoms. For example, geom_line() is equivalent to geom_path() once the data is sorted by the x variable. For cases like this, when a geom can be reduced to another lower-level (i.e., basic) geom, authors just have to write a method for the to_basic() generic function in plotly. In fact, within the package itself, the to_basic() function has a GeomLine method which simply sorts the data by the x variable then returns it with a class of GeomPath prefixed. getS3method(&quot;to_basic&quot;, &quot;GeomLine&quot;) #&gt; function(data, prestats_data, layout, params, p, ...) { #&gt; data &lt;- data[order(data[[&quot;x&quot;]]), ] #&gt; prefix_class(data, &quot;GeomPath&quot;) #&gt; } #&gt; &lt;bytecode: 0x7fae08173f30&gt; #&gt; &lt;environment: namespace:plotly&gt; If you have implemented a custom geom, say GeomCustom, rest assured that the data passed to to_basic() will be of class GeomCustom when ggplotly() is called on a plot with your geom. And assuming GeomCustom may be reduced to another lower-level geom support by plotly, a to_basic.GeomCustom() method that transforms the data into a form suitable for that lower-level geom is sufficient for adding support. Moreover, note that the data passed to to_basic() is essentially the last form of the data before the render stage and after statistics have been performed. This makes it trivial to add support for geoms like GeomXspline from the ggalt package. # devtools::install_github(&quot;hrbrmstr/ggalt&quot;) library(ggalt) getS3method(&quot;to_basic&quot;, &quot;GeomXspline&quot;) #&gt; function (data, prestats_data, layout, params, p, ...) #&gt; { #&gt; data &lt;- data[order(data[[&quot;x&quot;]]), ] #&gt; prefix_class(data, &quot;GeomPath&quot;) #&gt; } #&gt; &lt;bytecode: 0x7fae09364eb0&gt; #&gt; &lt;environment: namespace:plotly&gt; As shown in Figure 46.1, once the conversion has been provided. Users can call ggplotly() on the ggplot object containing the custom geom just like any other ggplot object. # example from `help(geom_xspline)` set.seed(1492) dat &lt;- data.frame( x = c(1:10, 1:10, 1:10), y = c(sample(15:30, 10), 2 * sample(15:30, 10), 3 * sample(15:30, 10)), group = factor(c(rep(1, 10), rep(2, 10), rep(3, 10))) ) p &lt;- ggplot(dat, aes(x, y, group = group, color = factor(group))) + geom_point(color = &quot;black&quot;) + geom_smooth(se = FALSE, linetype = &quot;dashed&quot;, size = 0.5) + geom_xspline(spline_shape = 1, size = 0.5) ggplotly(p) %&gt;% hide_legend() FIGURE 46.1: Converting GeomXspline from the ggalt package to plotly.js via ggplotly(). In more complicated cases, where your custom geom can not be converted to a lower level geom, a custom method for the geom2trace() generic is required (methods(geom2trace) lists all the basic geoms that we natively support). This method should involve a conversion from a data frame to a list-like object conforming to the plotly.js figure reference. References "],
["designing-an-htmlwidget-interface.html", "47 Designing an htmlwidget interface", " 47 Designing an htmlwidget interface The plotly.js library, as with many other JavaScript graphing libraries, strives to describe any plot through a plot specification defined via JavaScript Object Notation (JSON). JSON is a language independent data-interchange format that was originally designed for JavaScript, but parsers for many different languages now exist, including R (Temple Lang 2014); (Ooms 2014). JSON is a recursive key-value data structure (similar to a list in R), and essentially any valid JavaScript value has a natural R equivalent (e.g., NULL/null). As a result, any JSON object can be created from an appropriate R list, meaning that theoretically any plotly.js plot can be described via an R list. However, simply providing a bridge between R lists and JSON does not guarantee a powerful or usable interface, especially for a general purpose graphing library. Although it can be complicated to implement, R interfaces to JavaScript graphing libraries should leverage R’s strong resources for computing on the language to design a more expressive interface (Wickham 2014). It should also look and feel like (and work well with!) other commonly used interfaces in R. A good way to do this is to embrace (pure and predictable) functional programming. Most importantly, this implies that every function modifies a central type of object – meaning that every function input and output the same type of object (predictable). Furthermore, if the output of a function can be determined completely by the input (i.e., pure), it removes any need to search for other code that may be affecting the output. In the case of providing an interface to a JavaScript graphing library, there are a number of reasons why the central object should inherit from the central object provided by the htmlwidgets package. The idea of interfacing R with JavaScript libraries via JSON data transfer has been popular approach for quite some time (Vaidyanathan 2013); (Hocking, VanderPlas, and Sievert 2015); (Sievert and Shirley 2014). The R package htmlwidgets standardized this bridge, and provides some additional infrastructure for making sure the HTML output works as expected in multiple contexts (in the R console or RStudio, within rmarkdown documents, and even embedded inside shiny apps). The htmlwidgets package itself is opinionated about the data structure used to represent the widget in R since it needs to retain meta-information about the widget, such as the sizing policy. To avoid surprise, widget authors should strive to have all functions in their interface modify this data structure.32 JavaScript graphing libraries usually have strong requirements about the JSON structure used to create a plot. In some cases, the R interface needs to know about these requirements in order to faithfully translate R objects to JSON. For example, in plotly.js some attributes must always be an array (e.g. x/y), even if they are length 1, while other attributes cannot be an array must be a literal constant (e.g. name). This leads to a situation where the translation rules from R to JSON cannot be simply “box all vectors of length 1 into an array (or not)”: list(x = 1, y = 1, name = &quot;A point&quot;) =&gt; {x: [1], y: [1], name: &quot;A point&quot;} Thankfully plotly.js provides a plot schema which declares types for each attribute that plotly leverages internally. If necessary, plotly tries to coerce each attribute to its expected type at print time, and also searches for any unsupported attributes that may have been specified by the user (and throws a warning that the attribute will be ignored). This helps References "],
["references.html", "References", " References "]
]
